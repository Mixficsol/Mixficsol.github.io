<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Pika的增量同步 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="背景本篇介绍一下 Pika 的增量同步，Pika 的增量同步依赖 Binlog 机制">
<meta property="og:type" content="article">
<meta property="og:title" content="Pika的增量同步">
<meta property="og:url" content="http://example.com/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="背景本篇介绍一下 Pika 的增量同步，Pika 的增量同步依赖 Binlog 机制">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-01-04T06:42:36.672Z">
<meta property="article:modified_time" content="2024-01-09T08:57:10.126Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Pika的增量同步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2024-01-04T06:42:36.672Z" itemprop="datePublished">2024-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Pika的增量同步
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本篇介绍一下 Pika 的增量同步，Pika 的增量同步依赖 Binlog 机制<span id="more"></span>，我将分以下三个部分来讲解：</p>
<ul>
<li>单机 Binlog 生产</li>
<li>Master 端发送 Binlog 到 Slave 端</li>
<li>Slave 端生产和消费 Binlog</li>
</ul>
<h2 id="单机-Binlog-生产"><a href="#单机-Binlog-生产" class="headerlink" title="单机 Binlog 生产"></a>单机 Binlog 生产</h2><p><strong>src&#x2F;pika.command.cc</strong></p>
<p>在执行完命令的流程后执行 <code>DoBinlog</code> 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cmd::InternalProcessCommand</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Slot&gt;&amp; slot, <span class="type">const</span> std::shared_ptr&lt;SyncMasterSlot&gt;&amp; sync_slot,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> HintKeys&amp; hint_keys)</span> </span>&#123;</span><br><span class="line">  pstd::<span class="function">lock::MultiRecordLock <span class="title">record_lock</span><span class="params">(slot-&gt;LockMgr())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_write</span>()) &#123;</span><br><span class="line">    record_lock.<span class="built_in">Lock</span>(<span class="built_in">current_key</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> start_us = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    start_us = pstd::<span class="built_in">NowMicros</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DoCommand</span>(slot, hint_keys); <span class="comment">// 执行命令流程</span></span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    do_duration_ += pstd::<span class="built_in">NowMicros</span>() - start_us;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DoBinlog</span>(sync_slot); <span class="comment">// 这里执行Binlog逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_write</span>()) &#123;</span><br><span class="line">    record_lock.<span class="built_in">Unlock</span>(<span class="built_in">current_key</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika.command.cc</strong></p>
<p>在 <code>DoBinlog</code> 函数中，首先判断当前的命令是不是写命令，只有写命令才需要记录 <code>Binlog</code> 然后获取到当前的 <code>conn</code> 和 <code>response</code>, 然后执行 <code>SyncMasterSlot</code> 的 <code>ConsensusProposeLog</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cmd::DoBinlog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SyncMasterSlot&gt;&amp; slot)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">res</span>().<span class="built_in">ok</span>() &amp;&amp; <span class="built_in">is_write</span>() &amp;&amp; g_pika_conf-&gt;<span class="built_in">write_binlog</span>()) &#123; <span class="comment">// 判断是不是写命令</span></span><br><span class="line">    std::shared_ptr&lt;net::NetConn&gt; conn_ptr = <span class="built_in">GetConn</span>();</span><br><span class="line">    std::shared_ptr&lt;std::string&gt; resp_ptr = <span class="built_in">GetResp</span>();</span><br><span class="line">    <span class="comment">// Consider that dummy cmd appended by system, both conn and resp are null.</span></span><br><span class="line">    <span class="keyword">if</span> ((!conn_ptr || !resp_ptr) &amp;&amp; (name_ != kCmdDummy)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!conn_ptr) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; slot-&gt;<span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; conn empty.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!resp_ptr) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; slot-&gt;<span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; resp empty.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">res</span>().<span class="built_in">SetRes</span>(CmdRes::kErrOther);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status s =</span><br><span class="line">        slot-&gt;<span class="built_in">ConsensusProposeLog</span>(<span class="built_in">shared_from_this</span>(), std::<span class="built_in">dynamic_pointer_cast</span>&lt;PikaClientConn&gt;(conn_ptr), resp_ptr);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; slot-&gt;<span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; Writing binlog failed, maybe no space left on device &quot;</span></span><br><span class="line">                   &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      <span class="built_in">res</span>().<span class="built_in">SetRes</span>(CmdRes::kErrOther, s.<span class="built_in">ToString</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里的 <code>coordinator_</code> 是 <code>ConsensusCoordinator</code> 类，是 <code>SyncSlaveSlot</code> 类的私有成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ConsensusProposeLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> coordinator_.<span class="built_in">ProposeLog</span>(cmd_ptr, std::<span class="built_in">move</span>(conn_ptr), std::<span class="built_in">move</span>(resp_ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>在 <code>ProposeLog</code> 中，定义了一个 <code>LogOffset</code> 和 <code>BinlogItem</code> 变量，然后调用 <code>InternalAppendLog</code> 去执行写 <code>Binlog</code>, 同时调用 <code>SignalAuxiliary</code> 去唤醒辅助线程去通知主节点同步 <code>Binlog</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::ProposeLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; keys = cmd_ptr-&gt;<span class="built_in">current_key</span>();</span><br><span class="line">  <span class="comment">// slotkey shouldn&#x27;t add binlog</span></span><br><span class="line">  <span class="keyword">if</span> (cmd_ptr-&gt;<span class="built_in">name</span>() == kCmdNameSAdd &amp;&amp; !keys.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">      (keys[<span class="number">0</span>].<span class="built_in">compare</span>(<span class="number">0</span>, SlotKeyPrefix.<span class="built_in">length</span>(), SlotKeyPrefix) == <span class="number">0</span> || keys[<span class="number">0</span>].<span class="built_in">compare</span>(<span class="number">0</span>, SlotTagPrefix.<span class="built_in">length</span>(), SlotTagPrefix) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LogOffset log_offset;</span><br><span class="line"></span><br><span class="line">  BinlogItem item;</span><br><span class="line">  <span class="comment">// make sure stable log and mem log consistent</span></span><br><span class="line">  Status s = <span class="built_in">InternalAppendLog</span>(item, cmd_ptr, std::<span class="built_in">move</span>(conn_ptr), std::<span class="built_in">move</span>(resp_ptr));</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_pika_server-&gt;<span class="built_in">SignalAuxiliary</span>();</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaServer::SignalAuxiliary</span><span class="params">()</span> </span>&#123; pika_auxiliary_thread_-&gt;cv_.<span class="built_in">notify_one</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>其中在 <code>BinlogItem</code> 类中有 <code>exec_time</code>， <code>term_id</code> ， <code>logic_id</code>， <code>filenum</code>， <code>offset</code>， <code>content</code>， <code>extends</code> 等指标</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinlogItem</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BinlogItem</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">PikaBinlogTransverter</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">exec_time</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">term_id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">logic_id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">filenum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">content</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint32_t</span> exec_time_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> term_id_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> logic_id_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> filenum_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> offset_ = <span class="number">0</span>;</span><br><span class="line">  std::string content_;</span><br><span class="line">  std::vector&lt;std::string&gt; extends_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>这里调用 <code>InternalAppendBinlog</code> 方法写 <code>Binlog</code>, 这里传入的是 <code>cmd_ptr</code> , <code>BinlogItem</code> , <code>LogOffset</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendLog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  LogOffset log_offset;</span><br><span class="line">  Status s = <span class="built_in">InternalAppendBinlog</span>(item, cmd_ptr, &amp;log_offset);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>这里先把 <code>cmd_ptr</code> 中的命令根据 Redis 协议序列化成 <code>content</code> ，这里的 <code>stable_logger_</code> 是 <code>StableLog</code> 对象，这里调用 <code>Put</code> 函数将 <code>content</code> 的内容写到文件中，然后调用 <code>GetProducerStatus</code> ，然后调用 <code>LogOffset</code>, 更新 offset</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendBinlog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  LogOffset* log_offset)</span> </span>&#123;</span><br><span class="line">  std::string content = cmd_ptr-&gt;<span class="built_in">ToRedisProtocol</span>();</span><br><span class="line">  Status s = stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">Put</span>(content);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::string db_name = cmd_ptr-&gt;<span class="built_in">db_name</span>().<span class="built_in">empty</span>() ? g_pika_conf-&gt;<span class="built_in">default_db</span>() : cmd_ptr-&gt;<span class="built_in">db_name</span>();</span><br><span class="line">    std::shared_ptr&lt;DB&gt; db = g_pika_server-&gt;<span class="built_in">GetDB</span>(db_name);</span><br><span class="line">    <span class="keyword">if</span> (db) &#123;</span><br><span class="line">      db-&gt;<span class="built_in">SetBinlogIoError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> filenum;</span><br><span class="line">  <span class="type">uint64_t</span> offset;</span><br><span class="line">  stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">GetProducerStatus</span>(&amp;filenum, &amp;offset);</span><br><span class="line">  *log_offset = <span class="built_in">LogOffset</span>(<span class="built_in">BinlogOffset</span>(filenum, offset), <span class="built_in">LogicOffset</span>(item.<span class="built_in">term_id</span>(), item.<span class="built_in">logic_id</span>()));</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>这里 <code>Binlog</code> 重载了 <code>Put </code> 函数，第一个 <code>Put</code> 先初始化 <code>filenum</code>, <code>term_id</code> , <code>offset</code>, <code>logic_id</code> 变量，调用 <code>GetProduceStatus</code> 获取当前 Binlog 中的最新值（filenum，pro_offset，term_id，logic_id)，然后调用 <code>BinlogEncode</code> 组装 <code>Binlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: mutex lock should be held</span></span><br><span class="line"><span class="function">Status <span class="title">Binlog::Put</span><span class="params">(<span class="type">const</span> std::string&amp; item)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!opened_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Busy</span>(<span class="string">&quot;Binlog is not open yet&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> filenum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> term = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> logic_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Lock</span>();</span><br><span class="line">  DEFER &#123;</span><br><span class="line">    <span class="built_in">Unlock</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Status s = <span class="built_in">GetProducerStatus</span>(&amp;filenum, &amp;offset, &amp;term, &amp;logic_id);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  logic_id++;</span><br><span class="line">  std::string data = PikaBinlogTransverter::<span class="built_in">BinlogEncode</span>(BinlogType::TypeFirst,</span><br><span class="line">      <span class="built_in">time</span>(<span class="literal">nullptr</span>), term, logic_id, filenum, offset, item, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  s = <span class="built_in">Put</span>(data.<span class="built_in">c_str</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data.<span class="built_in">size</span>()));</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    binlog_io_error_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika_binlog_transverter.cc</strong></p>
<p>这里的 <code>BinlogEncode</code> 来组装 <code>Binlog</code> 的信息，返回一个组装好的 binlog</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">PikaBinlogTransverter::BinlogEncode</span><span class="params">(BinlogType type, <span class="type">uint32_t</span> exec_time, <span class="type">uint32_t</span> term_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">uint64_t</span> logic_id, <span class="type">uint32_t</span> filenum, <span class="type">uint64_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">const</span> std::string&amp; content, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; extends)</span> </span>&#123;</span><br><span class="line">  std::string binlog;</span><br><span class="line">  pstd::<span class="built_in">PutFixed16</span>(&amp;binlog, type);</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, exec_time);</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, term_id);</span><br><span class="line">  pstd::<span class="built_in">PutFixed64</span>(&amp;binlog, logic_id);</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, filenum);</span><br><span class="line">  pstd::<span class="built_in">PutFixed64</span>(&amp;binlog, offset);</span><br><span class="line">  <span class="type">uint32_t</span> content_length = content.<span class="built_in">size</span>();</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, content_length);</span><br><span class="line">  binlog.<span class="built_in">append</span>(content);</span><br><span class="line">  <span class="keyword">return</span> binlog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>

<p>这个就是 <code>Binlog</code> 这里的组装，一共 34 字节</p>
<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>我们看下第二个 Put 函数里面做了什么操作，这里如果当前文件大于预设定的文件大小，我们会调用 <code>NewWritableFile</code> 函数将新创建一个 <code>Binlog</code> 文件，并将 Binlog 中的 <code>pro_offset</code> 置为 0， <code>pro_num</code> 文件名索引加一，更新，然后调用 <code>Produce</code> 方法，处理 <code>Binlog</code>  逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: mutex lock should be held</span></span><br><span class="line"><span class="function">Status <span class="title">Binlog::Put</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* item, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check to roll log file */</span></span><br><span class="line">  <span class="type">uint64_t</span> filesize = queue_-&gt;<span class="built_in">Filesize</span>();</span><br><span class="line">  <span class="keyword">if</span> (filesize &gt; file_size_) &#123;</span><br><span class="line">    std::unique_ptr&lt;pstd::WritableFile&gt; queue;</span><br><span class="line">    std::string profile = <span class="built_in">NewFileName</span>(filename_, pro_num_ + <span class="number">1</span>);</span><br><span class="line">    s = pstd::<span class="built_in">NewWritableFile</span>(profile, queue);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Binlog: new &quot;</span> &lt;&lt; filename_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    queue_.<span class="built_in">reset</span>();</span><br><span class="line">    queue_ = std::<span class="built_in">move</span>(queue);</span><br><span class="line">    pro_num_++;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard <span class="title">l</span><span class="params">(version_-&gt;rwlock_)</span></span>;</span><br><span class="line">      version_-&gt;pro_offset_ = <span class="number">0</span>;</span><br><span class="line">      version_-&gt;pro_num_ = pro_num_;</span><br><span class="line">      version_-&gt;<span class="built_in">StableSave</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitLogFile</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pro_offset;</span><br><span class="line">  s = <span class="built_in">Produce</span>(pstd::<span class="built_in">Slice</span>(item, len), &amp;pro_offset);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(version_-&gt;rwlock_)</span></span>;</span><br><span class="line">    version_-&gt;pro_offset_ = pro_offset;</span><br><span class="line">    version_-&gt;logic_id_++;</span><br><span class="line">    version_-&gt;<span class="built_in">StableSave</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>在 <code>Produce</code> 函数中，<code>tmp_pro_offset</code> 是当前 <code>Binlog</code> 文件中的偏移量</p>
<p>我们用 <code>left</code> 记录了当前需要写入的一条 <code>Binlog</code> 的字节大小，用 <code>leftover</code> 记录当前 <code>block</code> 还剩下可填充的字节数，如果当前剩余可用的字节数都小于 <code>kHeaderSize(组成Binlog的头部)</code> 的话，则当前的 <code>Block</code> 后续用 <code>\x00</code> 填充，然后新起一个 <code>Block</code>, 然后将 <code>block_offset_</code> 置为 0，表示新的 <code>Block</code> 的偏移量，同时 <code>tmp_pro_offset</code> 也进行更新. <code>avail</code>来记录当前除了 <code>kHeadSize</code> 和 <code>block_offset_(当前block已写进的部分)</code> 之后一个 <code>block</code> 中还能记录的字节数，然后用 <code>left</code> 和 <code>avail</code> 作比较，看是否在当前的 <code>block</code> 装载下，如果 <code>left</code> &lt; <code>avail</code> 说明当前的 <code>block</code>可以装载下这一条 <code>record</code> 记录，我们把 <code>type</code> 置为 <code>kFullType</code> 其余的情况我们就置为其他的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Binlog::Produce</span><span class="params">(<span class="type">const</span> pstd::Slice&amp; item, <span class="type">int</span>* temp_pro_offset)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = item.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = item.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  *temp_pro_offset = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(version_-&gt;pro_offset_);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(kBlockSize) - block_offset_;</span><br><span class="line">    <span class="built_in">assert</span>(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(leftover) &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = queue_-&gt;<span class="built_in">Append</span>(pstd::<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        *temp_pro_offset += leftover;</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length, temp_pro_offset);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>这里就是把需要写入的东西放到 <code>queue_</code> 里面，然后下次打开 <code>Binlog</code> 文件的时候就会把新加的部分更新上去，至此一条 <code>Record</code> 记录就落盘了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Binlog::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr, <span class="type">size_t</span> n, <span class="type">int</span>* temp_pro_offset)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="built_in">assert</span>(n &lt;= <span class="number">0xffffff</span>);</span><br><span class="line">  <span class="built_in">assert</span>(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> now;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">nullptr</span>);</span><br><span class="line">  now = tv.tv_sec;</span><br><span class="line">  buf[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((n &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buf[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(now &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((now &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((now &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((now &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">  buf[<span class="number">7</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  s = queue_-&gt;<span class="built_in">Append</span>(pstd::<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = queue_-&gt;<span class="built_in">Append</span>(pstd::<span class="built_in">Slice</span>(ptr, n));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = queue_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(kHeaderSize + n);</span><br><span class="line"></span><br><span class="line">  *temp_pro_offset += <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(kHeaderSize + n);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| length | time | Type | type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|   <span class="number">3B</span>   |  <span class="number">4B</span>  |  <span class="number">1B</span>  |  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>

<p>所以最终的一条 <code>record</code> 就是以这样的形式记录的</p>
<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>通过以上的代码，大家发现好像这个 Binlog 数据没有落盘，只是在 <code>queue_</code> (内存)中，这里的 <code>AppendWritableFile</code> 函数就是利用 <code>mmap</code> 进行落盘操作，它在 Binlog 的构造函数中调用，操作系统会定期的将内存中的数据映射到磁盘上来实现落盘</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Binlog::<span class="built_in">Binlog</span>(std::string  binlog_path, <span class="type">const</span> <span class="type">int</span> file_size)</span><br><span class="line">    : <span class="built_in">opened_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">binlog_path_</span>(std::<span class="built_in">move</span>(binlog_path)),</span><br><span class="line">      <span class="built_in">file_size_</span>(file_size),</span><br><span class="line">      <span class="built_in">binlog_io_error_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="comment">// To intergrate with old version, we don&#x27;t set mmap file size to 100M;</span></span><br><span class="line">  <span class="comment">// pstd::SetMmapBoundSize(file_size);</span></span><br><span class="line">  <span class="comment">// pstd::kMmapBoundSize = 1024 * 1024 * 100;</span></span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  pstd::<span class="built_in">CreateDir</span>(binlog_path_);</span><br><span class="line"></span><br><span class="line">  filename_ = binlog_path_ + kBinlogPrefix;</span><br><span class="line">  <span class="type">const</span> std::string manifest = binlog_path_ + kManifest;</span><br><span class="line">  std::string profile;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pstd::<span class="built_in">FileExists</span>(manifest)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: Manifest file not exist, we create a new one.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    profile = <span class="built_in">NewFileName</span>(filename_, pro_num_);</span><br><span class="line">    s = pstd::<span class="built_in">NewWritableFile</span>(profile, queue_);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: new &quot;</span> &lt;&lt; filename_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;pstd::RWFile&gt; tmp_file;</span><br><span class="line">    s = pstd::<span class="built_in">NewRWFile</span>(manifest, tmp_file);</span><br><span class="line">    versionfile_.<span class="built_in">reset</span>(tmp_file.<span class="built_in">release</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: new versionfile error &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version_ = std::<span class="built_in">make_unique</span>&lt;Version&gt;(versionfile_);</span><br><span class="line">    version_-&gt;<span class="built_in">StableSave</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: Find the exist file.&quot;</span>;</span><br><span class="line">    std::unique_ptr&lt;pstd::RWFile&gt; tmp_file;</span><br><span class="line">    s = pstd::<span class="built_in">NewRWFile</span>(manifest, tmp_file);</span><br><span class="line">    versionfile_.<span class="built_in">reset</span>(tmp_file.<span class="built_in">release</span>());</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      version_ = std::<span class="built_in">make_unique</span>&lt;Version&gt;(versionfile_);</span><br><span class="line">      version_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">      pro_num_ = version_-&gt;pro_num_;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Debug</span></span><br><span class="line">      <span class="comment">// version_-&gt;debug();</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: open versionfile error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    profile = <span class="built_in">NewFileName</span>(filename_, pro_num_);</span><br><span class="line">    <span class="built_in">DLOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: open profile &quot;</span> &lt;&lt; profile;</span><br><span class="line">    s = pstd::<span class="built_in">AppendWritableFile</span>(profile, queue_, version_-&gt;pro_offset_); <span class="comment">// 落盘</span></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: Open file &quot;</span> &lt;&lt; profile &lt;&lt; <span class="string">&quot; error &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> filesize = queue_-&gt;<span class="built_in">Filesize</span>();</span><br><span class="line">    <span class="built_in">DLOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: filesize is &quot;</span> &lt;&lt; filesize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitLogFile</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们所说的 Binlog 其实就是 Pika 中存在的 <code>write2file</code> 文件，一个 <code>write2file</code> 文件由多个 <code>block</code> 组成，每个 <code>block</code> 大小固定为 <code>64KB</code>, 在 <code>block</code> 中记录的就是一条条 <code>record</code> ，一个 <code>record</code> 就是一条序列化后的 <code>redis</code> 命令(也可以是多条，当然也有一个 Binlog 用多个 record 记录)，每个 <code>write2file</code> 文件都有一定的大小，如果当前的 <code>block</code> 剩余字节量还不如填充一条 <code>record </code>的头部，则当前 <code>block</code> 当前剩余部分的字节用 <code>\x00</code>填充，然后新起一个 <code>block</code> 来装载 <code>record</code>。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ul>
<li><p>代码中的 Binlog 头部是 kHeadseSize 是 1+ 3 + 4 也就是 8 字节，但是在 <code>pika_binlog_transverter.h</code> 中对 Binlog 头部的描述是 <code>Type(2B)</code> + <code>exec_time(4B)</code> + <code>term_id(4B)</code> + <code>logic_id(8B)</code> + <code>filenum(4B)</code> + <code>offset(8B)</code> + <code>content_len(4B)</code> 算下来是 34 字节，为什么会不一样？</p>
<p><strong>真正头部的组装是 1(Type) + 3(length) + 4(time)</strong> <strong>后面再加 34 字节</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| length | time | Type | type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|   <span class="number">3B</span>   |  <span class="number">4B</span>  |  <span class="number">1B</span>  |  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>​</p>
</li>
<li><p>如果是调用 <code>AppendWritableFile</code> 每次进行 Binlog 数据落盘的话，为什么放在 <code>Binlog</code> 的构造函数中</p>
<p><strong>操作系统会定期把内存中的值映射写到磁盘上</strong></p>
<p>​</p>
</li>
<li><p>如果存在一种情况，当前 <code>Block</code> 剩余部分能存下一条 <code>record</code> 的头部和内容的一部分，那么当前这个 <code>block</code> 应该会存完整个 <code>record</code> 而不是新起一个 <code>Block</code> 存取吗？</p>
<p><strong>会新起一个 Block 存取，如果新起前已经到了文件设置的最大的 Block 数量依然会新起，所以 write2file 文件的大小不是固定的，但是 Block 的大小一定是固定的</strong></p>
<p>​</p>
</li>
<li><p>主节点写 Binlog 的时候怎么向辅助线程发送信号的？</p>
<p><strong>使用信号量</strong>，<code>pika_auxiliary_thread_-&gt;cv_.notify_one();</code></p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>在一条 <code>Binlog</code> 记录中，有字段重复的组装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| length | time | Type | type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|   <span class="number">3B</span>   |  <span class="number">4B</span>  |  <span class="number">1B</span>  |  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code> 字段一直都是 <code>TypeFirst</code> 这个默认值</p>
<p>​</p>
</li>
</ol>
<h2 id="Master-端发送-Binlog-到-Slave"><a href="#Master-端发送-Binlog-到-Slave" class="headerlink" title="Master 端发送 Binlog 到 Slave"></a>Master 端发送 Binlog 到 Slave</h2><p><strong>src&#x2F;pika_auxiliary_thread.cc</strong></p>
<p>在辅助线程中，<code>TriggerSendBinlogSync</code> 和 <code>SendToPeer</code>  分别负责将 Binlog 写到发送队列和将发送队列的 Binlog 发送给 Slave</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">PikaAuxiliaryThread::ThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">should_stop</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pika_server-&gt;<span class="built_in">ShouldMetaSync</span>()) &#123;</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">SendMetaSyncRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g_pika_server-&gt;<span class="built_in">MetaSyncDone</span>()) &#123;</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">RunSyncSlaveSlotStateMachine</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pstd::Status s = g_pika_rm-&gt;<span class="built_in">CheckSyncTimeout</span>(pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_pika_server-&gt;<span class="built_in">CheckLeaderProtectedMode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(whoiami) timeout</span></span><br><span class="line">    s = g_pika_server-&gt;<span class="built_in">TriggerSendBinlogSync</span>(); <span class="comment">// 将Binlog写入发送队列</span></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send to peer</span></span><br><span class="line">    <span class="type">int</span> res = g_pika_server-&gt;<span class="built_in">SendToPeer</span>(); <span class="comment">// 将发送队列的Binlog发给slave</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// sleep 100 ms</span></span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu_)</span></span>;</span><br><span class="line">      cv_.<span class="built_in">wait_for</span>(lock, <span class="number">100</span>ms);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// LOG_EVERY_N(INFO, 1000) &lt;&lt; &quot;Consume binlog number &quot; &lt;&lt; res;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Master-将-Binlog-写入发送队列"><a href="#Master-将-Binlog-写入发送队列" class="headerlink" title="Master 将 Binlog 写入发送队列"></a>Master 将 Binlog 写入发送队列</h3><p><strong>src&#x2F;pika_server.cc</strong></p>
<p>调用 <code>WakeUpBinlogSync</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaServer::TriggerSendBinlogSync</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g_pika_rm-&gt;<span class="built_in">WakeUpBinlogSync</span>(); &#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>WakeUpSlaveBinlogSync</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaReplicaManager::WakeUpBinlogSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_lock <span class="title">l</span><span class="params">(slots_rw_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : sync_master_slots_) &#123;</span><br><span class="line">    std::shared_ptr&lt;SyncMasterSlot&gt; slot = iter.second;</span><br><span class="line">    Status s = slot-&gt;<span class="built_in">WakeUpSlaveBinlogSync</span>();</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ReadBinlogFileWq</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::WakeUpSlaveBinlogSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unordered_map&lt;std::string, std::shared_ptr&lt;SlaveNode&gt;&gt; slaves = <span class="built_in">GetAllSlaveNodes</span>();</span><br><span class="line">  std::vector&lt;std::shared_ptr&lt;SlaveNode&gt;&gt; to_del;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; slave_iter : slaves) &#123;</span><br><span class="line">    std::shared_ptr&lt;SlaveNode&gt; slave_ptr = slave_iter.second;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(slave_ptr-&gt;slave_mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (slave_ptr-&gt;sent_offset == slave_ptr-&gt;acked_offset) &#123;</span><br><span class="line">      Status s = <span class="built_in">ReadBinlogFileToWq</span>(slave_ptr);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        to_del.<span class="built_in">push_back</span>(slave_ptr);</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;WakeUpSlaveBinlogSync falied, Delete from RM, slave: &quot;</span> &lt;&lt; slave_ptr-&gt;<span class="built_in">ToStringStatus</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; to_del_slave : to_del) &#123;</span><br><span class="line">    <span class="built_in">RemoveSlaveNode</span>(to_del_slave-&gt;<span class="built_in">Ip</span>(), to_del_slave-&gt;<span class="built_in">Port</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里将一个个 <code>Binlog</code> 用 <code>WriteTask</code> 封装起来记录了需要写的 <code>Binlog</code>  的元信息，这里的 <code>Status s = reader-&gt;Get(&amp;msg, &amp;filenum, &amp;offset);</code> 把 Binlog 中的信息提取到 <code>msg</code> 中，同时更新了 <code>filenum</code> 和 <code>offset</code>. 然后用 <code>BinlogItem</code> 进行组装，最终写到 <code>WriteTask</code> 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ReadBinlogFileToWq</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SlaveNode&gt;&amp; slave_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = slave_ptr-&gt;sync_win.<span class="built_in">Remaining</span>();</span><br><span class="line">  std::shared_ptr&lt;PikaBinlogReader&gt; reader = slave_ptr-&gt;binlog_reader;</span><br><span class="line">  <span class="keyword">if</span> (!reader) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;WriteTask&gt; tasks;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">    std::string msg;</span><br><span class="line">    <span class="type">uint32_t</span> filenum;</span><br><span class="line">    <span class="type">uint64_t</span> offset;</span><br><span class="line">    <span class="keyword">if</span> (slave_ptr-&gt;sync_win.<span class="built_in">GetTotalBinlogSize</span>() &gt; PIKA_MAX_CONN_RBUF_HB * <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; slave_ptr-&gt;<span class="built_in">ToString</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot; total binlog size in sync window is :&quot;</span> &lt;&lt; slave_ptr-&gt;sync_win.<span class="built_in">GetTotalBinlogSize</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Status s = reader-&gt;<span class="built_in">Get</span>(&amp;msg, &amp;filenum, &amp;offset);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">IsEndFile</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">IsCorruption</span>() || s.<span class="built_in">IsIOError</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; Read Binlog error : &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    BinlogItem item;</span><br><span class="line">    <span class="keyword">if</span> (!PikaBinlogTransverter::<span class="built_in">BinlogItemWithoutContentDecode</span>(TypeFirst, msg, &amp;item)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Binlog item decode failed&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Binlog item decode failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BinlogOffset sent_b_offset = <span class="built_in">BinlogOffset</span>(filenum, offset);</span><br><span class="line">    LogicOffset sent_l_offset = <span class="built_in">LogicOffset</span>(item.<span class="built_in">term_id</span>(), item.<span class="built_in">logic_id</span>());</span><br><span class="line">    <span class="function">LogOffset <span class="title">sent_offset</span><span class="params">(sent_b_offset, sent_l_offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    slave_ptr-&gt;sync_win.<span class="built_in">Push</span>(<span class="built_in">SyncWinItem</span>(sent_offset, msg.<span class="built_in">size</span>()));</span><br><span class="line">    slave_ptr-&gt;<span class="built_in">SetLastSendTime</span>(pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">    <span class="function">RmNode <span class="title">rm_node</span><span class="params">(slave_ptr-&gt;Ip(), slave_ptr-&gt;Port(), slave_ptr-&gt;DBName(), slave_ptr-&gt;SlotId(),</span></span></span><br><span class="line"><span class="params"><span class="function">                   slave_ptr-&gt;SessionId())</span></span>;</span><br><span class="line">    <span class="function">WriteTask <span class="title">task</span><span class="params">(rm_node, BinlogChip(sent_offset, msg), slave_ptr-&gt;sent_offset)</span></span>;</span><br><span class="line">    tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">    slave_ptr-&gt;sent_offset = sent_offset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    g_pika_rm-&gt;<span class="built_in">ProduceWriteQueue</span>(slave_ptr-&gt;<span class="built_in">Ip</span>(), slave_ptr-&gt;<span class="built_in">Port</span>(), slot_info_.slot_id_, tasks);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>在 Get 函数中，调用 <code>Consume</code> 用来提取 <code>Binlog</code> 中的信息，如果当前的 <code>Binlog</code> 文件已经读到底了，则切换 <code>Binlog</code> 文件，更新 <code>filenum</code>，<code>offset</code> 等值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a whole message;</span></span><br><span class="line"><span class="comment">// Append to scratch;</span></span><br><span class="line"><span class="comment">// the status will be OK, IOError or Corruption, EndFile;</span></span><br><span class="line"><span class="function">Status <span class="title">PikaBinlogReader::Get</span><span class="params">(std::string* scratch, <span class="type">uint32_t</span>* filenum, <span class="type">uint64_t</span>* offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!logger_ || !queue_) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Not seek&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  Status s = Status::<span class="built_in">OK</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReadToTheEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">EndFile</span>(<span class="string">&quot;End of cur log file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="built_in">Consume</span>(scratch, filenum, offset);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">IsEndFile</span>()) &#123;</span><br><span class="line">      std::string confile = <span class="built_in">NewFileName</span>(logger_-&gt;<span class="built_in">filename</span>(), cur_filenum_ + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// sleep 10ms wait produce thread generate the new binlog</span></span><br><span class="line">      <span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Roll to next file need retry;</span></span><br><span class="line">      <span class="keyword">if</span> (pstd::<span class="built_in">FileExists</span>(confile)) &#123;</span><br><span class="line">        <span class="built_in">DLOG</span>(INFO) &lt;&lt; <span class="string">&quot;BinlogSender roll to new binlog&quot;</span> &lt;&lt; confile;</span><br><span class="line">        queue_.<span class="built_in">reset</span>();</span><br><span class="line">        queue_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        pstd::<span class="built_in">NewSequentialFile</span>(confile, queue_);</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="function">std::lock_guard <span class="title">l</span><span class="params">(rwlock_)</span></span>;</span><br><span class="line">          cur_filenum_++;</span><br><span class="line">          cur_offset_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last_record_offset_ = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">IOError</span>(<span class="string">&quot;File Does Not Exists&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">IsEndFile</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>在 <code>Consume</code> 中，如果当前记录是 <code>kFullType</code> 则一次性将读到的数据写到 <code>scratch</code> 中，如果是其他的类型，则进行数据的追加或者报异常，这里是个 <code>while</code> 循环去处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaBinlogReader::Consume</span><span class="params">(std::string* scratch, <span class="type">uint32_t</span>* filenum, <span class="type">uint64_t</span>* offset)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  pstd::Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment, filenum, offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        *scratch = std::<span class="built_in">string</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">OK</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">NotFound</span>(<span class="string">&quot;Middle Status&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">NotFound</span>(<span class="string">&quot;Middle Status&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">OK</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kEof:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">EndFile</span>(<span class="string">&quot;Eof&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> kBadRecord:</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Read BadRecord record, will decode failed, this record may dbsync padded record, not processed here&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">IOError</span>(<span class="string">&quot;Data Corruption&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> kOldRecord:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">EndFile</span>(<span class="string">&quot;Eof&quot;</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">IOError</span>(<span class="string">&quot;Unknow reason&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// DLOG(INFO) &lt;&lt; &quot;Binlog Sender consumer a msg: &quot; &lt;&lt; scratch;</span></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>我们可以看到每个 slave节点中的 binlogreader 都保存了上次取到的文件偏移量，所以这样的设计方便解决了每次 Master 需要发生给 slave 哪些信息，首先我们先调用 <code>Read</code> 函数先取 <code>kHeaderSize</code> 的头部放到 <code>buffer_</code> 中，然后获取到 <code>length</code> 长度，然后继续往 <code>buffer_</code> 中追加后面的内容，将结果存在 <code>result</code> 里面，同时更新 <code>last_record_offset</code> 偏移量，然后继续返回上一层的循环中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">PikaBinlogReader::ReadPhysicalRecord</span><span class="params">(pstd::Slice* result, <span class="type">uint32_t</span>* filenum, <span class="type">uint64_t</span>* offset)</span> </span>&#123;</span><br><span class="line">  pstd::Status s;</span><br><span class="line">  <span class="keyword">if</span> (kBlockSize - last_record_offset_ &lt;= kHeaderSize) &#123;</span><br><span class="line">    queue_-&gt;<span class="built_in">Skip</span>(kBlockSize - last_record_offset_);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(rwlock_)</span></span>;</span><br><span class="line">    cur_offset_ += (kBlockSize - last_record_offset_);</span><br><span class="line">    last_record_offset_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  s = queue_-&gt;<span class="built_in">Read</span>(kHeaderSize, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">IsEndFile</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> kEof;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">0</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">1</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">2</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">7</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>) | (c &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (length &gt; (kBlockSize - kHeaderSize)) &#123;</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == kZeroType || length == <span class="number">0</span>) &#123;</span><br><span class="line">    buffer_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> kOldRecord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  s = queue_-&gt;<span class="built_in">Read</span>(length, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">  *result = pstd::<span class="built_in">Slice</span>(buffer_.<span class="built_in">data</span>(), buffer_.<span class="built_in">size</span>());</span><br><span class="line">  last_record_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(rwlock_)</span></span>;</span><br><span class="line">    *filenum = cur_filenum_;</span><br><span class="line">    cur_offset_ += (kHeaderSize + length);</span><br><span class="line">    *offset = cur_offset_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>把所有的 <code>WriteTask</code> 写到 <code>write_queues_</code> 里面待发送</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplicaManager::ProduceWriteQueue</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">uint32_t</span> slot_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> std::vector&lt;WriteTask&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard <span class="title">l</span><span class="params">(write_queue_mu_)</span></span>;</span><br><span class="line">  std::string index = ip + <span class="string">&quot;:&quot;</span> + std::<span class="built_in">to_string</span>(port);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">    write_queues_[index][slot_id].<span class="built_in">push</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h3><ul>
<li><p>这里的 <code>write_queues</code> 中的 task 只记录了 <code>RmNode</code> 信息和 <code>BinlogChip</code>， 在 <code>BinlogChip</code> 中记录了 <code>offset_</code> 和 string 类型的 <code>binlog_</code>, 这里的 binlog_ 就是 <code>record</code> 的信息</p>
<p><strong>是的，主要使用的就是binlog_</strong></p>
<p>​</p>
</li>
</ul>
<h3 id="Master-发送队列中的-binlog-发送给-Slave-节点"><a href="#Master-发送队列中的-binlog-发送给-Slave-节点" class="headerlink" title="Master 发送队列中的 binlog 发送给 Slave 节点"></a>Master 发送队列中的 binlog 发送给 Slave 节点</h3><p><strong>src&#x2F;pika_server.cc</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PikaServer::SendToPeer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g_pika_rm-&gt;<span class="built_in">ConsumeWriteQueue</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里把发往同一批机器的 <code>Binlog</code> 存放在 <code>p_map</code> 中，然后调用 <code>SendSlaveBinlogChips</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PikaReplicaManager::ConsumeWriteQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;WriteTask&gt;&gt;&gt; to_send_map;</span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(write_queue_mu_)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : write_queues_) &#123;</span><br><span class="line">      <span class="type">const</span> std::string&amp; ip_port = iter.first;</span><br><span class="line">      std::unordered_map&lt;<span class="type">uint32_t</span>, std::queue&lt;WriteTask&gt;&gt;&amp; p_map = iter.second;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; slot_queue : p_map) &#123;</span><br><span class="line">        std::queue&lt;WriteTask&gt;&amp; queue = slot_queue.second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kBinlogSendPacketNum; ++i) &#123;</span><br><span class="line">          <span class="keyword">if</span> (queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">size_t</span> batch_index = queue.<span class="built_in">size</span>() &gt; kBinlogSendBatchNum ? kBinlogSendBatchNum : queue.<span class="built_in">size</span>();</span><br><span class="line">          std::vector&lt;WriteTask&gt; to_send;</span><br><span class="line">          <span class="type">size_t</span> batch_size = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; batch_index; ++i) &#123;</span><br><span class="line">            WriteTask&amp; task = queue.<span class="built_in">front</span>();</span><br><span class="line">            batch_size += task.binlog_chip_.binlog_.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// make sure SerializeToString will not over 2G</span></span><br><span class="line">            <span class="keyword">if</span> (batch_size &gt; PIKA_MAX_CONN_RBUF_HB) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            to_send.<span class="built_in">push_back</span>(task);</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            counter++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!to_send.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            to_send_map[ip_port].<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(to_send));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; to_delete;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : to_send_map) &#123;</span><br><span class="line">    std::string ip;</span><br><span class="line">    <span class="type">int</span> port = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pstd::<span class="built_in">ParseIpPortString</span>(iter.first, ip, port)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Parse ip_port error &quot;</span> &lt;&lt; iter.first;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; to_send : iter.second) &#123;</span><br><span class="line">      Status s = pika_repl_server_-&gt;<span class="built_in">SendSlaveBinlogChips</span>(ip, port, to_send); <span class="comment">//发送</span></span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;send binlog to &quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot; failed, &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">        to_delete.<span class="built_in">push_back</span>(iter.first);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!to_delete.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard <span class="title">l</span><span class="params">(write_queue_mu_)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; del_queue : to_delete) &#123;</span><br><span class="line">        write_queues_.<span class="built_in">erase</span>(del_queue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_server.cc</strong></p>
<p><code>BuildBinlogSyncResp</code> 将 Binlog 的元信息写给 Slave</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pstd::Status <span class="title">PikaReplServer::SendSlaveBinlogChips</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> std::vector&lt;WriteTask&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">  InnerMessage::InnerResponse response;</span><br><span class="line">  <span class="built_in">BuildBinlogSyncResp</span>(tasks, &amp;response);</span><br><span class="line"></span><br><span class="line">  std::string binlog_chip_pb;</span><br><span class="line">  <span class="keyword">if</span> (!response.<span class="built_in">SerializeToString</span>(&amp;binlog_chip_pb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Serialized Failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (binlog_chip_pb.<span class="built_in">size</span>() &gt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(g_pika_conf-&gt;<span class="built_in">max_conn_rbuf_size</span>())) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">      InnerMessage::InnerResponse response;</span><br><span class="line">      std::vector&lt;WriteTask&gt; tmp_tasks;</span><br><span class="line">      tmp_tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">      <span class="built_in">BuildBinlogSyncResp</span>(tmp_tasks, &amp;response);</span><br><span class="line">      <span class="keyword">if</span> (!response.<span class="built_in">SerializeToString</span>(&amp;binlog_chip_pb)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Serialized Failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pstd::Status s = <span class="built_in">Write</span>(ip, port, binlog_chip_pb);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pstd::Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(ip, port, binlog_chip_pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_server.cc</strong></p>
<p>写给 Slave</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pstd::Status <span class="title">PikaReplServer::Write</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">const</span> <span class="type">int</span> port, <span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_lock <span class="title">l</span><span class="params">(client_conn_rwlock_)</span></span>;</span><br><span class="line">  <span class="type">const</span> std::string ip_port = pstd::<span class="built_in">IpPortString</span>(ip, port);</span><br><span class="line">  <span class="keyword">if</span> (client_conn_map_.<span class="built_in">find</span>(ip_port) == client_conn_map_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(<span class="string">&quot;The &quot;</span> + ip_port + <span class="string">&quot; fd cannot be found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> fd = client_conn_map_[ip_port];</span><br><span class="line">  std::shared_ptr&lt;net::PbConn&gt; conn = std::<span class="built_in">dynamic_pointer_cast</span>&lt;net::PbConn&gt;(pika_repl_server_thread_-&gt;<span class="built_in">get_conn</span>(fd));</span><br><span class="line">  <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(<span class="string">&quot;The&quot;</span> + ip_port + <span class="string">&quot; conn cannot be found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (conn-&gt;<span class="built_in">WriteResp</span>(msg)) &#123;</span><br><span class="line">    conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;The&quot;</span> + ip_port + <span class="string">&quot; conn, Write Resp Failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  conn-&gt;<span class="built_in">NotifyWrite</span>();</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p><code>sent_offset</code> 和 <code>acked_offset</code> 有什么区别？</p>
<p><strong>对比前后传递的offset偏移量</strong></p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Master 节点通过 Pb 给从节点发送 Binlog 信息，其中包括 <code>binlog_</code> (即命令本身)， 以及 <code>offset_</code> ，以及 <code>DBName</code> , <code>SlotID</code> , <code>SessionID</code>.</p>
<h2 id="Slave-端生产和消费-Binlog"><a href="#Slave-端生产和消费-Binlog" class="headerlink" title="Slave 端生产和消费 Binlog"></a>Slave 端生产和消费 Binlog</h2><p><strong>src&#x2F;pika_repl_client_conn.cc</strong></p>
<p>这里的 <code>DispatchBinlogRes</code> 是 Slave 端处理由 Master 端发过来的 <code>Binlog</code> 请求，调用 <code>SchduleWriteBinlogTask</code> 去处理 <code>Binlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplClientConn::DispatchBinlogRes</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerResponse&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// slot to a bunch of binlog chips</span></span><br><span class="line">  std::unordered_map&lt;SlotInfo, std::vector&lt;<span class="type">int</span>&gt;*, hash_slot_info&gt; par_binlog;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res-&gt;<span class="built_in">binlog_sync_size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::InnerResponse::BinlogSync&amp; binlog_res = res-&gt;<span class="built_in">binlog_sync</span>(i);</span><br><span class="line">    <span class="comment">// hash key: db + slot_id</span></span><br><span class="line">    <span class="function">SlotInfo <span class="title">p_info</span><span class="params">(binlog_res.slot().db_name(), binlog_res.slot().slot_id())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (par_binlog.<span class="built_in">find</span>(p_info) == par_binlog.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      par_binlog[p_info] = <span class="keyword">new</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    par_binlog[p_info]-&gt;<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SyncSlaveSlot&gt; slave_slot = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; binlog_nums : par_binlog) &#123;</span><br><span class="line">    <span class="function">RmNode <span class="title">node</span><span class="params">(binlog_nums.first.db_name_, binlog_nums.first.slot_id_)</span></span>;</span><br><span class="line">    slave_slot = g_pika_rm-&gt;<span class="built_in">GetSyncSlaveSlotByName</span>(</span><br><span class="line">        <span class="built_in">SlotInfo</span>(binlog_nums.first.db_name_, binlog_nums.first.slot_id_));</span><br><span class="line">    <span class="keyword">if</span> (!slave_slot) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slave Slot: &quot;</span> &lt;&lt; binlog_nums.first.db_name_ &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; binlog_nums.first.slot_id_</span><br><span class="line">                   &lt;&lt; <span class="string">&quot; not exist&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slave_slot-&gt;<span class="built_in">SetLastRecvTime</span>(pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">    g_pika_rm-&gt;<span class="built_in">ScheduleWriteBinlogTask</span>(binlog_nums.first.db_name_ + std::<span class="built_in">to_string</span>(binlog_nums.first.slot_id_),</span><br><span class="line">                                       res, std::<span class="built_in">dynamic_pointer_cast</span>&lt;PikaReplClientConn&gt;(<span class="built_in">shared_from_this</span>()),</span><br><span class="line">                                       <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(binlog_nums.second));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里调用了 <code>ScheduleWriteBinlogTask</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplicaManager::ScheduleWriteBinlogTask</span><span class="params">(<span class="type">const</span> std::string&amp; db_slot,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerResponse&gt;&amp; res,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> std::shared_ptr&lt;net::PbConn&gt;&amp; conn, <span class="type">void</span>* res_private_data)</span> </span>&#123;</span><br><span class="line">  pika_repl_client_-&gt;<span class="built_in">ScheduleWriteBinlogTask</span>(db_slot, res, conn, res_private_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_clint.cc</strong></p>
<p>这里调用了 <code>Schedule</code> 让 work 线程去异步处理 <code>HandleBGWokerWriteBinlog</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplClient::ScheduleWriteBinlogTask</span><span class="params">(<span class="type">const</span> std::string&amp; db_slot,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerResponse&gt;&amp; res,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> std::shared_ptr&lt;net::PbConn&gt;&amp; conn, <span class="type">void</span>* res_private_data)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">GetHashIndex</span>(db_slot, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">auto</span> task_arg = <span class="keyword">new</span> <span class="built_in">ReplClientWriteBinlogTaskArg</span>(res, conn, res_private_data, bg_workers_[index].<span class="built_in">get</span>());</span><br><span class="line">  bg_workers_[index]-&gt;<span class="built_in">Schedule</span>(&amp;PikaReplBgWorker::HandleBGWorkerWriteBinlog, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(task_arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_bgworker.cc</strong></p>
<p>这里将 <code>binlog_res</code> 里面的 <code>binlog().data()</code>进行序列化解析，然后放在 <code>ProcessInputBuffer</code> 里面处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplBgWorker::HandleBGWorkerWriteBinlog</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> task_arg = <span class="built_in">static_cast</span>&lt;ReplClientWriteBinlogTaskArg*&gt;(arg);</span><br><span class="line">  <span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerResponse&gt; res = task_arg-&gt;res;</span><br><span class="line">  std::shared_ptr&lt;net::PbConn&gt; conn = task_arg-&gt;conn;</span><br><span class="line">  <span class="keyword">auto</span> index = <span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="type">int</span>&gt;*&gt;(task_arg-&gt;res_private_data);</span><br><span class="line">  PikaReplBgWorker* worker = task_arg-&gt;worker;</span><br><span class="line">  worker-&gt;ip_port_ = conn-&gt;<span class="built_in">ip_port</span>();</span><br><span class="line"></span><br><span class="line">  DEFER &#123; </span><br><span class="line">    <span class="keyword">delete</span> index;</span><br><span class="line">    <span class="keyword">delete</span> task_arg;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::string db_name;</span><br><span class="line">  <span class="type">uint32_t</span> slot_id = <span class="number">0</span>;</span><br><span class="line">  LogOffset pb_begin;</span><br><span class="line">  LogOffset pb_end;</span><br><span class="line">  <span class="type">bool</span> only_keepalive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the first not keepalive binlogsync</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; index-&gt;<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::InnerResponse::BinlogSync&amp; binlog_res = res-&gt;<span class="built_in">binlog_sync</span>((*index)[i]);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      db_name = binlog_res.<span class="built_in">slot</span>().<span class="built_in">db_name</span>();</span><br><span class="line">      slot_id = binlog_res.<span class="built_in">slot</span>().<span class="built_in">slot_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!binlog_res.<span class="built_in">binlog</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">ParseBinlogOffset</span>(binlog_res.<span class="built_in">binlog_offset</span>(), &amp;pb_begin);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the last not keepalive binlogsync</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(index-&gt;<span class="built_in">size</span>() - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::InnerResponse::BinlogSync&amp; binlog_res = res-&gt;<span class="built_in">binlog_sync</span>((*index)[i]);</span><br><span class="line">    <span class="keyword">if</span> (!binlog_res.<span class="built_in">binlog</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">ParseBinlogOffset</span>(binlog_res.<span class="built_in">binlog_offset</span>(), &amp;pb_end);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pb_begin == <span class="built_in">LogOffset</span>()) &#123;</span><br><span class="line">    only_keepalive = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LogOffset ack_start;</span><br><span class="line">  <span class="keyword">if</span> (only_keepalive) &#123;</span><br><span class="line">    ack_start = <span class="built_in">LogOffset</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ack_start = pb_begin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// db_name and slot_id in the vector are same in the bgworker,</span></span><br><span class="line">  <span class="comment">// because DispatchBinlogRes() have been order them.</span></span><br><span class="line">  worker-&gt;db_name_ = db_name;</span><br><span class="line">  worker-&gt;slot_id_ = slot_id;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SyncMasterSlot&gt; slot =</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">GetSyncMasterSlotByName</span>(<span class="built_in">SlotInfo</span>(db_name, slot_id));</span><br><span class="line">  <span class="keyword">if</span> (!slot) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slot &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; Not Found&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SyncSlaveSlot&gt; slave_slot =</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">GetSyncSlaveSlotByName</span>(<span class="built_in">SlotInfo</span>(db_name, slot_id));</span><br><span class="line">  <span class="keyword">if</span> (!slave_slot) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slave Slot &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; Not Found&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res-&gt;<span class="built_in">has_consensus_meta</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::ConsensusMeta&amp; meta = res-&gt;<span class="built_in">consensus_meta</span>();</span><br><span class="line">    <span class="keyword">if</span> (meta.<span class="built_in">term</span>() &gt; slot-&gt;<span class="built_in">ConsensusTerm</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Update &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; term from &quot;</span> &lt;&lt; slot-&gt;<span class="built_in">ConsensusTerm</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; meta.<span class="built_in">term</span>();</span><br><span class="line">      slot-&gt;<span class="built_in">ConsensusUpdateTerm</span>(meta.<span class="built_in">term</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.<span class="built_in">term</span>() &lt; slot-&gt;<span class="built_in">ConsensusTerm</span>()) <span class="comment">/*outdated pb*/</span> &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Drop outdated binlog sync response &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; slot_id</span><br><span class="line">                   &lt;&lt; <span class="string">&quot; recv term: &quot;</span> &lt;&lt; meta.<span class="built_in">term</span>() &lt;&lt; <span class="string">&quot; local term: &quot;</span> &lt;&lt; slot-&gt;<span class="built_in">ConsensusTerm</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!only_keepalive) &#123;</span><br><span class="line">      LogOffset last_offset = slot-&gt;<span class="built_in">ConsensusLastIndex</span>();</span><br><span class="line">      LogOffset prev_offset;</span><br><span class="line">      <span class="built_in">ParseBinlogOffset</span>(res-&gt;<span class="built_in">consensus_meta</span>().<span class="built_in">log_offset</span>(), &amp;prev_offset);</span><br><span class="line">      <span class="keyword">if</span> (last_offset.l_offset.index != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (last_offset.l_offset != prev_offset.l_offset || last_offset.b_offset != prev_offset.b_offset)) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;last_offset &quot;</span> &lt;&lt; last_offset.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; NOT equal to pb prev_offset &quot;</span></span><br><span class="line">                     &lt;&lt; prev_offset.<span class="built_in">ToString</span>();</span><br><span class="line">        slave_slot-&gt;<span class="built_in">SetReplState</span>(ReplState::kTryConnect);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i : *index) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::InnerResponse::BinlogSync&amp; binlog_res = res-&gt;<span class="built_in">binlog_sync</span>(i);</span><br><span class="line">    <span class="comment">// if pika are not current a slave or Slot not in</span></span><br><span class="line">    <span class="comment">// BinlogSync state, we drop remain write binlog task</span></span><br><span class="line">    <span class="keyword">if</span> (((g_pika_server-&gt;<span class="built_in">role</span>() &amp; PIKA_ROLE_SLAVE) == <span class="number">0</span>) ||</span><br><span class="line">        ((slave_slot-&gt;<span class="built_in">State</span>() != ReplState::kConnected) &amp;&amp; (slave_slot-&gt;<span class="built_in">State</span>() != ReplState::kWaitDBSync))) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slave_slot-&gt;<span class="built_in">MasterSessionId</span>() != binlog_res.<span class="built_in">session_id</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Check SessionId Mismatch: &quot;</span> &lt;&lt; slave_slot-&gt;<span class="built_in">MasterIp</span>() &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">                   &lt;&lt; slave_slot-&gt;<span class="built_in">MasterPort</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; slave_slot-&gt;<span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>()</span><br><span class="line">                   &lt;&lt; <span class="string">&quot; expected_session: &quot;</span> &lt;&lt; binlog_res.<span class="built_in">session_id</span>()</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;, actual_session:&quot;</span> &lt;&lt; slave_slot-&gt;<span class="built_in">MasterSessionId</span>();</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Check Session failed &quot;</span> &lt;&lt; binlog_res.<span class="built_in">slot</span>().<span class="built_in">db_name</span>() &lt;&lt; <span class="string">&quot;_&quot;</span></span><br><span class="line">                   &lt;&lt; binlog_res.<span class="built_in">slot</span>().<span class="built_in">slot_id</span>();</span><br><span class="line">      slave_slot-&gt;<span class="built_in">SetReplState</span>(ReplState::kTryConnect);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty binlog treated as keepalive packet</span></span><br><span class="line">    <span class="keyword">if</span> (binlog_res.<span class="built_in">binlog</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PikaBinlogTransverter::<span class="built_in">BinlogItemWithoutContentDecode</span>(TypeFirst, binlog_res.<span class="built_in">binlog</span>(), &amp;worker-&gt;binlog_item_)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Binlog item decode failed&quot;</span>;</span><br><span class="line">      slave_slot-&gt;<span class="built_in">SetReplState</span>(ReplState::kTryConnect);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* redis_parser_start = binlog_res.<span class="built_in">binlog</span>().<span class="built_in">data</span>() + BINLOG_ENCODE_LEN;</span><br><span class="line">    <span class="type">int</span> redis_parser_len = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(binlog_res.<span class="built_in">binlog</span>().<span class="built_in">size</span>()) - BINLOG_ENCODE_LEN;</span><br><span class="line">    <span class="type">int</span> processed_len = <span class="number">0</span>;</span><br><span class="line">    net::RedisParserStatus ret =</span><br><span class="line">        worker-&gt;redis_parser_.<span class="built_in">ProcessInputBuffer</span>(redis_parser_start, redis_parser_len, &amp;processed_len); <span class="comment">// 处理Binlog</span></span><br><span class="line">    <span class="keyword">if</span> (ret != net::kRedisParserDone) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Redis parser failed&quot;</span>;</span><br><span class="line">      slave_slot-&gt;<span class="built_in">SetReplState</span>(ReplState::kTryConnect);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res-&gt;<span class="built_in">has_consensus_meta</span>()) &#123;</span><br><span class="line">    LogOffset leader_commit;</span><br><span class="line">    <span class="built_in">ParseBinlogOffset</span>(res-&gt;<span class="built_in">consensus_meta</span>().<span class="built_in">commit</span>(), &amp;leader_commit);</span><br><span class="line">    <span class="comment">// Update follower commit &amp;&amp; apply</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LogOffset ack_end;</span><br><span class="line">  <span class="keyword">if</span> (only_keepalive) &#123;</span><br><span class="line">    ack_end = <span class="built_in">LogOffset</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LogOffset productor_status;</span><br><span class="line">    <span class="comment">// Reply Ack to master immediately</span></span><br><span class="line">    std::shared_ptr&lt;Binlog&gt; logger = slot-&gt;<span class="built_in">Logger</span>();</span><br><span class="line">    logger-&gt;<span class="built_in">GetProducerStatus</span>(&amp;productor_status.b_offset.filenum, &amp;productor_status.b_offset.offset,</span><br><span class="line">                              &amp;productor_status.l_offset.term, &amp;productor_status.l_offset.index);</span><br><span class="line">    ack_end = productor_status;</span><br><span class="line">    ack_end.l_offset.term = pb_end.l_offset.term;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_pika_rm-&gt;<span class="built_in">SendSlotBinlogSyncAckRequest</span>(db_name, slot_id, ack_start, ack_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;redis_parser.cc</strong></p>
<p>调用 <code>ProcessRequestBuffer</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisParserStatus <span class="title">RedisParser::ProcessInputBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input_buf, <span class="type">int</span> length, <span class="type">int</span>* parsed_len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status_code_ == kRedisParserInitDone || status_code_ == kRedisParserHalf || status_code_ == kRedisParserDone) &#123;</span><br><span class="line">    <span class="comment">// TODO(): AZ: avoid copy</span></span><br><span class="line">    <span class="function">std::string <span class="title">tmp_str</span><span class="params">(input_buf, length)</span></span>;</span><br><span class="line">    input_str_ = half_argv_ + tmp_str;</span><br><span class="line">    input_buf_ = input_str_.<span class="built_in">c_str</span>();</span><br><span class="line">    length_ = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(length + half_argv_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (redis_parser_type_ == REDIS_PARSER_REQUEST) &#123;</span><br><span class="line">      <span class="built_in">ProcessRequestBuffer</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redis_parser_type_ == REDIS_PARSER_RESPONSE) &#123;</span><br><span class="line">      <span class="built_in">ProcessResponseBuffer</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserInitError);</span><br><span class="line">      <span class="keyword">return</span> status_code_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur_pos_ starts from 0, val of cur_pos_ is the parsed_len</span></span><br><span class="line">    *parsed_len = cur_pos_;</span><br><span class="line">    <span class="built_in">ResetRedisParser</span>();</span><br><span class="line">    <span class="comment">// PrintCurrentStatus();</span></span><br><span class="line">    <span class="keyword">return</span> status_code_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserInitError);</span><br><span class="line">  <span class="keyword">return</span> status_code_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;redis_parser.cc</strong></p>
<p>这里将解析好的 <code>cmd</code> 放到 <code>argv_</code> 中，然后触发 <code>DealMessage</code> 调用 <code>HandleWriteBinlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisParserStatus <span class="title">RedisParser::ProcessRequestBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  RedisParserStatus ret;</span><br><span class="line">  <span class="keyword">while</span> (cur_pos_ &lt;= length_ - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redis_type_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (input_buf_[cur_pos_] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        redis_type_ = REDIS_REQ_MULTIBULK;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis_type_ = REDIS_REQ_INLINE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redis_type_ == REDIS_REQ_INLINE) &#123;</span><br><span class="line">      ret = <span class="built_in">ProcessInlineBuffer</span>();</span><br><span class="line">      <span class="keyword">if</span> (ret != kRedisParserDone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redis_type_ == REDIS_REQ_MULTIBULK) &#123;</span><br><span class="line">      ret = <span class="built_in">ProcessMultibulkBuffer</span>();</span><br><span class="line">      <span class="keyword">if</span> (ret != kRedisParserDone) &#123;  <span class="comment">// FULL_ERROR || HALF || PARSE_ERROR</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Unknown requeset type;</span></span><br><span class="line">      <span class="keyword">return</span> kRedisParserError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!argv_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      argvs_.<span class="built_in">push_back</span>(argv_);</span><br><span class="line">      <span class="keyword">if</span> (parser_settings_.DealMessage) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parser_settings_.<span class="built_in">DealMessage</span>(<span class="keyword">this</span>, argv_) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserDealError);</span><br><span class="line">          <span class="keyword">return</span> status_code_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// Reset</span></span><br><span class="line">    <span class="built_in">ResetCommandStatus</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (parser_settings_.Complete) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parser_settings_.<span class="built_in">Complete</span>(<span class="keyword">this</span>, argvs_) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserCompleteError);</span><br><span class="line">      <span class="keyword">return</span> status_code_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  argvs_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">SetParserStatus</span>(kRedisParserDone);</span><br><span class="line">  <span class="keyword">return</span> status_code_;  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_bgworker.cc</strong></p>
<p>这里调用 <code>ConsensusProcessLeaderLog</code> 处理 <code>Binlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PikaReplBgWorker::HandleWriteBinlog</span><span class="params">(net::RedisParser* parser, <span class="type">const</span> net::RedisCmdArgsType&amp; argv)</span> </span>&#123;</span><br><span class="line">  std::string opt = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">auto</span> worker = <span class="built_in">static_cast</span>&lt;PikaReplBgWorker*&gt;(parser-&gt;data);</span><br><span class="line">  <span class="comment">// Monitor related</span></span><br><span class="line">  std::string monitor_message;</span><br><span class="line">  <span class="keyword">if</span> (g_pika_server-&gt;<span class="built_in">HasMonitorClients</span>()) &#123;</span><br><span class="line">    std::string db_name = worker-&gt;db_name_.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">    std::string monitor_message =</span><br><span class="line">        std::<span class="built_in">to_string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(pstd::<span class="built_in">NowMicros</span>()) / <span class="number">1000000</span>) + <span class="string">&quot; [&quot;</span> + db_name + <span class="string">&quot; &quot;</span> + worker-&gt;ip_port_ + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : argv) &#123;</span><br><span class="line">      monitor_message += <span class="string">&quot; &quot;</span> + pstd::<span class="built_in">ToRead</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    g_pika_server-&gt;<span class="built_in">AddMonitorMessage</span>(monitor_message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;Cmd&gt; c_ptr = g_pika_cmd_table_manager-&gt;<span class="built_in">GetCmd</span>(pstd::<span class="built_in">StringToLower</span>(opt));</span><br><span class="line">  <span class="keyword">if</span> (!c_ptr) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Command &quot;</span> &lt;&lt; opt &lt;&lt; <span class="string">&quot; not in the command db&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Initial</span></span><br><span class="line">  c_ptr-&gt;<span class="built_in">Initial</span>(argv, worker-&gt;db_name_);</span><br><span class="line">  <span class="keyword">if</span> (!c_ptr-&gt;<span class="built_in">res</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Fail to initial command from binlog: &quot;</span> &lt;&lt; opt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_pika_server-&gt;<span class="built_in">UpdateQueryNumAndExecCountDB</span>(worker-&gt;db_name_, opt, c_ptr-&gt;<span class="built_in">is_write</span>());</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SyncMasterSlot&gt; slot =</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">GetSyncMasterSlotByName</span>(<span class="built_in">SlotInfo</span>(worker-&gt;db_name_, worker-&gt;slot_id_));</span><br><span class="line">  <span class="keyword">if</span> (!slot) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; worker-&gt;db_name_ &lt;&lt; worker-&gt;slot_id_ &lt;&lt; <span class="string">&quot;Not found.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  slot-&gt;<span class="built_in">ConsensusProcessLeaderLog</span>(c_ptr, worker-&gt;binlog_item_);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ProposeLog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ConsensusProcessLeaderLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> BinlogItem&amp; attribute)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> coordinator_.<span class="built_in">ProcessLeaderLog</span>(cmd_ptr, attribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>InternalAppendLog</code> 写 Binlog，然后 <code>InternalApplyFollower</code>异步消费 Binlog</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// precheck if prev_offset match &amp;&amp; drop this log if this log exist</span></span><br><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::ProcessLeaderLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> BinlogItem&amp; attribute)</span> </span>&#123;</span><br><span class="line">  LogOffset last_index = mem_logger_-&gt;<span class="built_in">last_offset</span>();</span><br><span class="line">  <span class="keyword">if</span> (attribute.<span class="built_in">logic_id</span>() &lt; last_index.l_offset.index) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="built_in">SlotInfo</span>(db_name_, slot_id_).<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;Drop log from leader logic_id &quot;</span></span><br><span class="line">                 &lt;&lt; attribute.<span class="built_in">logic_id</span>() &lt;&lt; <span class="string">&quot; cur last index &quot;</span> &lt;&lt; last_index.l_offset.index;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Status s = <span class="built_in">InternalAppendLog</span>(attribute, cmd_ptr, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InternalApplyFollower</span>(MemLog::<span class="built_in">LogItem</span>(<span class="built_in">LogOffset</span>(), cmd_ptr, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::UpdateSlave</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> LogOffset&amp; end)</span> </span>&#123;</span><br><span class="line">  LogOffset committed_index;</span><br><span class="line">  Status s = sync_pros_.<span class="built_in">Update</span>(ip, port, start, end, &amp;committed_index);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写-Binlog"><a href="#写-Binlog" class="headerlink" title="写 Binlog"></a>写 Binlog</h3><p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>InternalAppendBinlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendLog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  LogOffset log_offset;</span><br><span class="line">  Status s = <span class="built_in">InternalAppendBinlog</span>(item, cmd_ptr, &amp;log_offset);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendBinlog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  LogOffset* log_offset)</span> </span>&#123;</span><br><span class="line">  std::string content = cmd_ptr-&gt;<span class="built_in">ToRedisProtocol</span>();</span><br><span class="line">  Status s = stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">Put</span>(content);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::string db_name = cmd_ptr-&gt;<span class="built_in">db_name</span>().<span class="built_in">empty</span>() ? g_pika_conf-&gt;<span class="built_in">default_db</span>() : cmd_ptr-&gt;<span class="built_in">db_name</span>();</span><br><span class="line">    std::shared_ptr&lt;DB&gt; db = g_pika_server-&gt;<span class="built_in">GetDB</span>(db_name);</span><br><span class="line">    <span class="keyword">if</span> (db) &#123;</span><br><span class="line">      db-&gt;<span class="built_in">SetBinlogIoError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> filenum;</span><br><span class="line">  <span class="type">uint64_t</span> offset;</span><br><span class="line">  stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">GetProducerStatus</span>(&amp;filenum, &amp;offset);</span><br><span class="line">  *log_offset = <span class="built_in">LogOffset</span>(<span class="built_in">BinlogOffset</span>(filenum, offset), <span class="built_in">LogicOffset</span>(item.<span class="built_in">term_id</span>(), item.<span class="built_in">logic_id</span>()));</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="消费-Binlog"><a href="#消费-Binlog" class="headerlink" title="消费 Binlog"></a>消费 Binlog</h3><p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>SchduleWriteDBTask</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsensusCoordinator::InternalApplyFollower</span><span class="params">(<span class="type">const</span> MemLog::LogItem&amp; log)</span> </span>&#123;</span><br><span class="line">  g_pika_rm-&gt;<span class="built_in">ScheduleWriteDBTask</span>(log.cmd_ptr, log.offset, db_name_, slot_id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ScheduleWriteDBTask</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplicaManager::ScheduleWriteDBTask</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> LogOffset&amp; offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> std::string&amp; db_name, <span class="type">uint32_t</span> slot_id)</span> </span>&#123;</span><br><span class="line">  pika_repl_client_-&gt;<span class="built_in">ScheduleWriteDBTask</span>(cmd_ptr, offset, db_name, slot_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_client.cc</strong></p>
<p>调用 <code>Schedule</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplClient::ScheduleWriteDBTask</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> LogOffset&amp; offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> std::string&amp; db_name, <span class="type">uint32_t</span> slot_id)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> PikaCmdArgsType&amp; argv = cmd_ptr-&gt;<span class="built_in">argv</span>();</span><br><span class="line">  std::string dispatch_key = argv.<span class="built_in">size</span>() &gt;= <span class="number">2</span> ? argv[<span class="number">1</span>] : argv[<span class="number">0</span>];</span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">GetHashIndex</span>(dispatch_key, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">auto</span> task_arg = <span class="keyword">new</span> <span class="built_in">ReplClientWriteDBTaskArg</span>(cmd_ptr, offset, db_name, slot_id);</span><br><span class="line">  bg_workers_[index]-&gt;<span class="built_in">Schedule</span>(&amp;PikaReplBgWorker::HandleBGWorkerWriteDB, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(task_arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>pika_repl_bgworker.cc</strong></p>
<p>这里执行了消费 Binlog 的步骤</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplBgWorker::HandleBGWorkerWriteDB</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;ReplClientWriteDBTaskArg&gt; <span class="title">task_arg</span><span class="params">(<span class="keyword">static_cast</span>&lt;ReplClientWriteDBTaskArg*&gt;(arg))</span></span>;</span><br><span class="line">  <span class="type">const</span> std::shared_ptr&lt;Cmd&gt; c_ptr = task_arg-&gt;cmd_ptr;</span><br><span class="line">  <span class="type">const</span> PikaCmdArgsType&amp; argv = c_ptr-&gt;<span class="built_in">argv</span>();</span><br><span class="line">  LogOffset offset = task_arg-&gt;offset;</span><br><span class="line">  std::string db_name = task_arg-&gt;db_name;</span><br><span class="line">  <span class="type">uint32_t</span> slot_id = task_arg-&gt;slot_id;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> start_us = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    start_us = pstd::<span class="built_in">NowMicros</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;Slot&gt; slot = g_pika_server-&gt;<span class="built_in">GetDBSlotById</span>(db_name, slot_id);</span><br><span class="line">  <span class="comment">// Add read lock for no suspend command</span></span><br><span class="line">  <span class="keyword">if</span> (!c_ptr-&gt;<span class="built_in">IsSuspend</span>()) &#123;</span><br><span class="line">    slot-&gt;<span class="built_in">DbRWLockReader</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c_ptr-&gt;<span class="built_in">IsNeedCacheDo</span>()</span><br><span class="line">      &amp;&amp; PIKA_CACHE_NONE != g_pika_conf-&gt;<span class="built_in">cache_model</span>()</span><br><span class="line">      &amp;&amp; slot-&gt;<span class="built_in">cache</span>()-&gt;<span class="built_in">CacheStatus</span>() == PIKA_CACHE_STATUS_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c_ptr-&gt;<span class="built_in">is_write</span>()) &#123;</span><br><span class="line">      c_ptr-&gt;<span class="built_in">DoThroughDB</span>(slot);</span><br><span class="line">      <span class="keyword">if</span> (c_ptr-&gt;<span class="built_in">IsNeedUpdateCache</span>()) &#123;</span><br><span class="line">        c_ptr-&gt;<span class="built_in">DoUpdateCache</span>(slot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;This branch is not impossible reach&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c_ptr-&gt;<span class="built_in">Do</span>(slot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!c_ptr-&gt;<span class="built_in">IsSuspend</span>()) &#123;</span><br><span class="line">    slot-&gt;<span class="built_in">DbRWUnLock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(start_us / <span class="number">1000000</span>);</span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(pstd::<span class="built_in">NowMicros</span>() - start_us);</span><br><span class="line">    <span class="keyword">if</span> (duration &gt; g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>()) &#123;</span><br><span class="line">      g_pika_server-&gt;<span class="built_in">SlowlogPushEntry</span>(argv, start_time, duration);</span><br><span class="line">      <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_write_errorlog</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;command: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, start_time(s): &quot;</span> &lt;&lt; start_time &lt;&lt; <span class="string">&quot;, duration(us): &quot;</span> &lt;&lt; duration;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里调用 <code>SendSlotBinlogSync</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaReplicaManager::SendSlotBinlogSyncAckRequest</span><span class="params">(<span class="type">const</span> std::string&amp; db, <span class="type">uint32_t</span> slot_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">const</span> LogOffset&amp; ack_start, <span class="type">const</span> LogOffset&amp; ack_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">bool</span> is_first_send)</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;SyncSlaveSlot&gt; slave_slot = <span class="built_in">GetSyncSlaveSlotByName</span>(<span class="built_in">SlotInfo</span>(db, slot_id));</span><br><span class="line">  <span class="keyword">if</span> (!slave_slot) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slave Slot: &quot;</span> &lt;&lt; db &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot;, NotFound&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Slave Slot not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pika_repl_client_-&gt;<span class="built_in">SendSlotBinlogSync</span>(slave_slot-&gt;<span class="built_in">MasterIp</span>(), slave_slot-&gt;<span class="built_in">MasterPort</span>(), db,</span><br><span class="line">                                                    slot_id, ack_start, ack_end, slave_slot-&gt;<span class="built_in">LocalIp</span>(),</span><br><span class="line">                                                    is_first_send);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>src&#x2F;pika_repl_client.cc</strong></p>
<p>这里使用 Pb 组装返回给 Master 的信息，与 Master 发过来不同的是，这里返回了 <code>ack_start</code> 和 <code>ack_end</code> 就是 Slave 这边已经消费了的 <code>Binlog</code> 的起始结束的偏移量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaReplClient::SendSlotBinlogSync</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">uint32_t</span> port, <span class="type">const</span> std::string&amp; db_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> slot_id, <span class="type">const</span> LogOffset&amp; ack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">const</span> LogOffset&amp; ack_end, <span class="type">const</span> std::string&amp; local_ip,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">bool</span> is_first_send)</span> </span>&#123;</span><br><span class="line">  InnerMessage::InnerRequest request;</span><br><span class="line">  request.<span class="built_in">set_type</span>(InnerMessage::kBinlogSync);</span><br><span class="line">  InnerMessage::InnerRequest::BinlogSync* binlog_sync = request.<span class="built_in">mutable_binlog_sync</span>();</span><br><span class="line">  InnerMessage::Node* node = binlog_sync-&gt;<span class="built_in">mutable_node</span>();</span><br><span class="line">  node-&gt;<span class="built_in">set_ip</span>(local_ip);</span><br><span class="line">  node-&gt;<span class="built_in">set_port</span>(g_pika_server-&gt;<span class="built_in">port</span>());</span><br><span class="line">  binlog_sync-&gt;<span class="built_in">set_db_name</span>(db_name);</span><br><span class="line">  binlog_sync-&gt;<span class="built_in">set_slot_id</span>(slot_id);</span><br><span class="line">  binlog_sync-&gt;<span class="built_in">set_first_send</span>(is_first_send);</span><br><span class="line"></span><br><span class="line">  InnerMessage::BinlogOffset* ack_range_start = binlog_sync-&gt;<span class="built_in">mutable_ack_range_start</span>();</span><br><span class="line">  ack_range_start-&gt;<span class="built_in">set_filenum</span>(ack_start.b_offset.filenum);</span><br><span class="line">  ack_range_start-&gt;<span class="built_in">set_offset</span>(ack_start.b_offset.offset);</span><br><span class="line">  ack_range_start-&gt;<span class="built_in">set_term</span>(ack_start.l_offset.term);</span><br><span class="line">  ack_range_start-&gt;<span class="built_in">set_index</span>(ack_start.l_offset.index);</span><br><span class="line"></span><br><span class="line">  InnerMessage::BinlogOffset* ack_range_end = binlog_sync-&gt;<span class="built_in">mutable_ack_range_end</span>();</span><br><span class="line">  ack_range_end-&gt;<span class="built_in">set_filenum</span>(ack_end.b_offset.filenum);</span><br><span class="line">  ack_range_end-&gt;<span class="built_in">set_offset</span>(ack_end.b_offset.offset);</span><br><span class="line">  ack_range_end-&gt;<span class="built_in">set_term</span>(ack_end.l_offset.term);</span><br><span class="line">  ack_range_end-&gt;<span class="built_in">set_index</span>(ack_end.l_offset.index);</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SyncSlaveSlot&gt; slave_slot =</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">GetSyncSlaveSlotByName</span>(<span class="built_in">SlotInfo</span>(db_name, slot_id));</span><br><span class="line">  <span class="keyword">if</span> (!slave_slot) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slave Slot: &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; not exist&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(<span class="string">&quot;SyncSlaveSlot NotFound&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int32_t</span> session_id = slave_slot-&gt;<span class="built_in">MasterSessionId</span>();</span><br><span class="line">  binlog_sync-&gt;<span class="built_in">set_session_id</span>(session_id);</span><br><span class="line"></span><br><span class="line">  std::string to_send;</span><br><span class="line">  <span class="keyword">if</span> (!request.<span class="built_in">SerializeToString</span>(&amp;to_send)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Serialize Slot BinlogSync Request Failed, to Master (&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Serialize Failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> client_thread_-&gt;<span class="built_in">Write</span>(ip, <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(port + kPortShiftReplServer), to_send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Master-回复-Slave-的-kBinlogSync-请求"><a href="#Master-回复-Slave-的-kBinlogSync-请求" class="headerlink" title="Master 回复 Slave 的 kBinlogSync 请求"></a>Master 回复 Slave 的 kBinlogSync 请求</h2><p><strong>src&#x2F;pika_repl_server_conn.cc</strong></p>
<p>这里调用 <code>UpdateSyncBinlogStatus</code> 更新一下 <code>Binlog</code> 的信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplServerConn::HandleBinlogSyncRequest</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;ReplServerTaskArg&gt; <span class="title">task_arg</span><span class="params">(<span class="keyword">static_cast</span>&lt;ReplServerTaskArg*&gt;(arg))</span></span>;</span><br><span class="line">  <span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerRequest&gt; req = task_arg-&gt;req;</span><br><span class="line">  std::shared_ptr&lt;net::PbConn&gt; conn = task_arg-&gt;conn;</span><br><span class="line">  <span class="keyword">if</span> (!req-&gt;<span class="built_in">has_binlog_sync</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Pb parse error&quot;</span>;</span><br><span class="line">    <span class="comment">// conn-&gt;NotifyClose();</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> InnerMessage::InnerRequest::BinlogSync&amp; binlog_req = req-&gt;<span class="built_in">binlog_sync</span>();</span><br><span class="line">  <span class="type">const</span> InnerMessage::Node&amp; node = binlog_req.<span class="built_in">node</span>();</span><br><span class="line">  <span class="type">const</span> std::string&amp; db_name = binlog_req.<span class="built_in">db_name</span>();</span><br><span class="line">  <span class="type">uint32_t</span> slot_id = binlog_req.<span class="built_in">slot_id</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> is_first_send = binlog_req.<span class="built_in">first_send</span>();</span><br><span class="line">  <span class="type">int32_t</span> session_id = binlog_req.<span class="built_in">session_id</span>();</span><br><span class="line">  <span class="type">const</span> InnerMessage::BinlogOffset&amp; ack_range_start = binlog_req.<span class="built_in">ack_range_start</span>();</span><br><span class="line">  <span class="type">const</span> InnerMessage::BinlogOffset&amp; ack_range_end = binlog_req.<span class="built_in">ack_range_end</span>();</span><br><span class="line">  <span class="function">BinlogOffset <span class="title">b_range_start</span><span class="params">(ack_range_start.filenum(), ack_range_start.offset())</span></span>;</span><br><span class="line">  <span class="function">BinlogOffset <span class="title">b_range_end</span><span class="params">(ack_range_end.filenum(), ack_range_end.offset())</span></span>;</span><br><span class="line">  <span class="function">LogicOffset <span class="title">l_range_start</span><span class="params">(ack_range_start.term(), ack_range_start.index())</span></span>;</span><br><span class="line">  <span class="function">LogicOffset <span class="title">l_range_end</span><span class="params">(ack_range_end.term(), ack_range_end.index())</span></span>;</span><br><span class="line">  <span class="function">LogOffset <span class="title">range_start</span><span class="params">(b_range_start, l_range_start)</span></span>;</span><br><span class="line">  <span class="function">LogOffset <span class="title">range_end</span><span class="params">(b_range_end, l_range_end)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SyncMasterSlot&gt; master_slot =</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">GetSyncMasterSlotByName</span>(<span class="built_in">SlotInfo</span>(db_name, slot_id));</span><br><span class="line">  <span class="keyword">if</span> (!master_slot) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Sync Master Slot: &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot;, NotFound&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req-&gt;<span class="built_in">has_consensus_meta</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::ConsensusMeta&amp; meta = req-&gt;<span class="built_in">consensus_meta</span>();</span><br><span class="line">    <span class="keyword">if</span> (meta.<span class="built_in">term</span>() &gt; master_slot-&gt;<span class="built_in">ConsensusTerm</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Update &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; term from &quot;</span> &lt;&lt; master_slot-&gt;<span class="built_in">ConsensusTerm</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; meta.<span class="built_in">term</span>();</span><br><span class="line">      master_slot-&gt;<span class="built_in">ConsensusUpdateTerm</span>(meta.<span class="built_in">term</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta.<span class="built_in">term</span>() &lt; master_slot-&gt;<span class="built_in">ConsensusTerm</span>()) <span class="comment">/*outdated pb*/</span> &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Drop outdated binlog sync req &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; slot_id</span><br><span class="line">                   &lt;&lt; <span class="string">&quot; recv term: &quot;</span> &lt;&lt; meta.<span class="built_in">term</span>() &lt;&lt; <span class="string">&quot; local term: &quot;</span> &lt;&lt; master_slot-&gt;<span class="built_in">ConsensusTerm</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!master_slot-&gt;<span class="built_in">CheckSessionId</span>(node.<span class="built_in">ip</span>(), node.<span class="built_in">port</span>(), db_name, slot_id, session_id)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Check Session failed &quot;</span> &lt;&lt; node.<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; node.<span class="built_in">port</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;_&quot;</span></span><br><span class="line">                 &lt;&lt; slot_id;</span><br><span class="line">    <span class="comment">// conn-&gt;NotifyClose();</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set ack info from slave</span></span><br><span class="line">  RmNode slave_node = <span class="built_in">RmNode</span>(node.<span class="built_in">ip</span>(), node.<span class="built_in">port</span>(), db_name, slot_id);</span><br><span class="line"></span><br><span class="line">  Status s = master_slot-&gt;<span class="built_in">SetLastRecvTime</span>(node.<span class="built_in">ip</span>(), node.<span class="built_in">port</span>(), pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;SetMasterLastRecvTime failed &quot;</span> &lt;&lt; node.<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; node.<span class="built_in">port</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot;_&quot;</span></span><br><span class="line">                 &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_first_send) &#123;</span><br><span class="line">    <span class="keyword">if</span> (range_start.b_offset != range_end.b_offset) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;first binlogsync request pb argument invalid&quot;</span>;</span><br><span class="line">      conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status s = master_slot-&gt;<span class="built_in">ActivateSlaveBinlogSync</span>(node.<span class="built_in">ip</span>(), node.<span class="built_in">port</span>(), range_start);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Activate Binlog Sync failed &quot;</span> &lt;&lt; slave_node.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// not the first_send the range_ack cant be 0</span></span><br><span class="line">  <span class="comment">// set this case as ping</span></span><br><span class="line">  <span class="keyword">if</span> (range_start.b_offset == <span class="built_in">BinlogOffset</span>() &amp;&amp; range_end.b_offset == <span class="built_in">BinlogOffset</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s = g_pika_rm-&gt;<span class="built_in">UpdateSyncBinlogStatus</span>(slave_node, range_start, range_end);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Update binlog ack failed &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_pika_server-&gt;<span class="built_in">SignalAuxiliary</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ConsensusUpdateSlave</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaReplicaManager::UpdateSyncBinlogStatus</span><span class="params">(<span class="type">const</span> RmNode&amp; slave, <span class="type">const</span> LogOffset&amp; offset_start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> LogOffset&amp; offset_end)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_lock <span class="title">l</span><span class="params">(slots_rw_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sync_master_slots_.<span class="built_in">find</span>(slave.<span class="built_in">NodeSlotInfo</span>()) == sync_master_slots_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(slave.<span class="built_in">ToString</span>() + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;SyncMasterSlot&gt; slot = sync_master_slots_[slave.<span class="built_in">NodeSlotInfo</span>()];</span><br><span class="line">  Status s = slot-&gt;<span class="built_in">ConsensusUpdateSlave</span>(slave.<span class="built_in">Ip</span>(), slave.<span class="built_in">Port</span>(), offset_start, offset_end);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  s = slot-&gt;<span class="built_in">SyncBinlogToWq</span>(slave.<span class="built_in">Ip</span>(), slave.<span class="built_in">Port</span>());</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>UpdateSlave</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ConsensusUpdateSlave</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> LogOffset&amp; end)</span> </span>&#123;</span><br><span class="line">  Status s = coordinator_.<span class="built_in">UpdateSlave</span>(ip, port, start, end);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>Update</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::UpdateSlave</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> LogOffset&amp; end)</span> </span>&#123;</span><br><span class="line">  LogOffset committed_index;</span><br><span class="line">  Status s = sync_pros_.<span class="built_in">Update</span>(ip, port, start, end, &amp;committed_index);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>Update</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncProgress::Update</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; start, <span class="type">const</span> LogOffset&amp; end,</span></span></span><br><span class="line"><span class="params"><span class="function">                            LogOffset* committed_index)</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;SlaveNode&gt; slave_ptr = <span class="built_in">GetSlaveNode</span>(ip, port);</span><br><span class="line">  <span class="keyword">if</span> (!slave_ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(<span class="string">&quot;ip &quot;</span> + ip + <span class="string">&quot; port &quot;</span> + std::<span class="built_in">to_string</span>(port));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LogOffset acked_offset;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// update slave_ptr</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(slave_ptr-&gt;slave_mu)</span></span>;</span><br><span class="line">    Status s = slave_ptr-&gt;<span class="built_in">Update</span>(start, end, &amp;acked_offset);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update match_index_</span></span><br><span class="line">    <span class="comment">// shared slave_ptr-&gt;slave_mu</span></span><br><span class="line">    match_index_[ip + std::<span class="built_in">to_string</span>(port)] = acked_offset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_slave_node.cc</strong></p>
<p>这里可以看到更新了 <code>acked_offset</code> 的值，同时更新了 <code>sync_win</code> 滑动窗口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SlaveNode::Update</span><span class="params">(<span class="type">const</span> LogOffset&amp; start, <span class="type">const</span> LogOffset&amp; end, LogOffset* updated_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (slave_state != kSlaveBinlogSync) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="built_in">ToString</span>() + <span class="string">&quot;state not BinlogSync&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *updated_offset = <span class="built_in">LogOffset</span>();</span><br><span class="line">  <span class="type">bool</span> res = sync_win.<span class="built_in">Update</span>(<span class="built_in">SyncWinItem</span>(start), <span class="built_in">SyncWinItem</span>(end), updated_offset);</span><br><span class="line">  <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;UpdateAckedInfo failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (*updated_offset == <span class="built_in">LogOffset</span>()) &#123;</span><br><span class="line">    <span class="comment">// nothing to update return current acked_offset</span></span><br><span class="line">    *updated_offset = acked_offset;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// update acked_offset</span></span><br><span class="line">  acked_offset = *updated_offset;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_slave_node.cc</strong></p>
<p>这里的 <code>win_</code> 实际上是一个双端队列，里面存的是 <code>SyncWinItem</code> 类型的信息，传入的 <code>start_item</code> 和 <code>end_itme</code> 就是已经被从消费过的 <code>Binlog</code> 偏移量，然后把这些从 <code>win_</code> 中 <code>pop_front</code> 出来，使 win_ 中剩下下次需要传递的 <code>Binlog</code> 偏移量的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SyncWindow::Update</span><span class="params">(<span class="type">const</span> SyncWinItem&amp; start_item, <span class="type">const</span> SyncWinItem&amp; end_item, LogOffset* acked_offset)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> start_pos = win_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> end_pos = win_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; win_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (win_[i] == start_item) &#123;</span><br><span class="line">      start_pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (win_[i] == end_item) &#123;</span><br><span class="line">      end_pos = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (start_pos == win_.<span class="built_in">size</span>() || end_pos == win_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Ack offset Start: &quot;</span> &lt;&lt; start_item.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;End: &quot;</span> &lt;&lt; end_item.<span class="built_in">ToString</span>()</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; not found in binlog controller window.&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;window status &quot;</span> &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; <span class="built_in">ToStringStatus</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = start_pos; i &lt;= end_pos; ++i) &#123;</span><br><span class="line">    win_[i].acked_ = <span class="literal">true</span>;</span><br><span class="line">    total_size_ -= win_[i].binlog_size_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!win_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (win_[<span class="number">0</span>].acked_) &#123;</span><br><span class="line">      *acked_offset = win_[<span class="number">0</span>].offset_;</span><br><span class="line">      win_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在增量同步中，Master 先把自己的 Binlog 的偏移量和序列化后的 <code>record</code> 信息发送给 Slave，并记录这个偏移量为 <code>sent_offset</code> ，然后 Slave 端消费完之后回给 Master 一个 <code>ack_start</code> 和 <code>ack_end</code> 去更新 Master 这边的 <code>ack_offset</code> ，只有 <code>sent_offset</code> 和 <code>ack_offset</code> 相同时 Master 才能继续和 Slave 做增量同步</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/" data-id="clrg6uw1u001f08rfa2zb27vi" data-title="Pika的增量同步" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Blog/" rel="tag">Blog</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/01/09/Pika%E7%9A%84%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Pika的全量同步
        
      </div>
    </a>
  
  
    <a href="/2023/12/05/Floyd%E6%97%A0%E6%95%88%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%96%B9%E6%A1%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Floyd无效数据清理方案</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blog/" rel="tag">Blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Blog/" style="font-size: 10px;">Blog</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/15/C++%E9%94%81%E6%9C%BA%E5%88%B6/">C++锁机制</a>
          </li>
        
          <li>
            <a href="/2024/01/09/Pika%E7%9A%84%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5/">Pika的全量同步</a>
          </li>
        
          <li>
            <a href="/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/">Pika的增量同步</a>
          </li>
        
          <li>
            <a href="/2023/12/05/Floyd%E6%97%A0%E6%95%88%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%96%B9%E6%A1%88/">Floyd无效数据清理方案</a>
          </li>
        
          <li>
            <a href="/2023/12/04/Pika%E5%BF%AB%E6%85%A2%E5%91%BD%E4%BB%A4%E5%88%86%E7%A6%BB%E6%96%B9%E6%A1%88/">Pika快慢命令分离方案</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>