<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Pika的增量同步源码剖析 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="背景本篇介绍一下 Pika 的增量同步，Pika 的增量同步依赖 Binlog 机制">
<meta property="og:type" content="article">
<meta property="og:title" content="Pika的增量同步源码剖析">
<meta property="og:url" content="http://example.com/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="背景本篇介绍一下 Pika 的增量同步，Pika 的增量同步依赖 Binlog 机制">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/OpenAtomFoundation/pika/assets/73943232/2b243e08-d128-4f93-8e51-7d64595d0f08">
<meta property="article:published_time" content="2024-01-04T06:42:36.672Z">
<meta property="article:modified_time" content="2024-01-25T02:14:54.857Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/OpenAtomFoundation/pika/assets/73943232/2b243e08-d128-4f93-8e51-7d64595d0f08">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Pika的增量同步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2024-01-04T06:42:36.672Z" itemprop="datePublished">2024-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Pika的增量同步源码剖析
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本篇介绍一下 Pika 的增量同步，Pika 的增量同步依赖 Binlog 机制<span id="more"></span>，我将分以下五个部分来讲解：</p>
<ul>
<li><p>Master 接收 BinlogSyncRequest</p>
</li>
<li><p>Slave 端生产和消费 Binlog</p>
</li>
<li><p>单机 Binlog 生产</p>
</li>
<li><p>辅助线程驱动 BinlogSync</p>
</li>
<li><p>Binlog 的过期策略</p>
</li>
</ul>
<h2 id="Master-接收-BinlogSyncRequest"><a href="#Master-接收-BinlogSyncRequest" class="headerlink" title="Master 接收 BinlogSyncRequest"></a>Master 接收 BinlogSyncRequest</h2><p>接着上篇的全量同步的文章继续说，上面我们说到从节点在收到主节点的 <code>TrySync</code> 回包之后马上给主节点发送了第一个 <code>kBinlogSync</code>请求，从这里开始就是开始进行增量同步了</p>
<p><strong>src&#x2F;pika_repl_server_conn.cc</strong></p>
<p>这里由于从节点设置了一个 <code>is_first_send</code> ，这个时候从节点传过来的 <code>ack_range_start</code> 和 <code>ack_range_end</code> 都是一样的，<code>BinlogOffset</code>里面的 <code>offset</code>都是从节点保存的主节点当时 <code>dump</code> 时候的偏移量， 这里调用 <code>ActivateSlaveBinlogSync</code> , 这里传了一个 <code>LogOffset	</code> 类型的入参 <code>range_start</code>(LogOffset)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplServerConn::HandleBinlogSyncRequest</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;ReplServerTaskArg&gt; <span class="title">task_arg</span><span class="params">(<span class="keyword">static_cast</span>&lt;ReplServerTaskArg*&gt;(arg))</span></span>;</span><br><span class="line">  <span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerRequest&gt; req = task_arg-&gt;req;</span><br><span class="line">  std::shared_ptr&lt;net::PbConn&gt; conn = task_arg-&gt;conn;</span><br><span class="line">  <span class="keyword">if</span> (!req-&gt;<span class="built_in">has_binlog_sync</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Pb parse error&quot;</span>;</span><br><span class="line">    <span class="comment">// conn-&gt;NotifyClose();</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (is_first_send) &#123;</span><br><span class="line">    <span class="keyword">if</span> (range_start.b_offset != range_end.b_offset) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;first binlogsync request pb argument invalid&quot;</span>;</span><br><span class="line">      conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status s = master_slot-&gt;<span class="built_in">ActivateSlaveBinlogSync</span>(node.<span class="built_in">ip</span>(), node.<span class="built_in">port</span>(), range_start);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Activate Binlog Sync failed &quot;</span> &lt;&lt; slave_node.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul>
<li><p>为什么这里部分 <code>conn-&gt;NotifyClose</code> 注释掉了</p>
<p>​</p>
</li>
</ul>
<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>首先我们会获取到指定从节点的 <code>slave_ptr</code> 然后把它的 <code>sent_offset</code> 和 <code>acked_offset</code> 置为入参 <code>offset</code>的值, 然后调用 <code>InitBinlogFileReader</code> 初始化 <code>BinlogReader</code>，传入了一个入参 <code>offset</code>，然后调用 <code>SyncBinlogToWq</code> 把需要写的 Binlog 放到 <code>write_queue</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ActivateSlaveBinlogSync</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; offset)</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;SlaveNode&gt; slave_ptr = <span class="built_in">GetSlaveNode</span>(ip, port);</span><br><span class="line">  <span class="keyword">if</span> (!slave_ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(<span class="string">&quot;ip &quot;</span> + ip + <span class="string">&quot; port &quot;</span> + std::<span class="built_in">to_string</span>(port));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(slave_ptr-&gt;slave_mu)</span></span>;</span><br><span class="line">    slave_ptr-&gt;slave_state = kSlaveBinlogSync;</span><br><span class="line">    slave_ptr-&gt;sent_offset = offset;</span><br><span class="line">    slave_ptr-&gt;acked_offset = offset;</span><br><span class="line">    <span class="comment">// read binlog file from file</span></span><br><span class="line">    Status s = slave_ptr-&gt;<span class="built_in">InitBinlogFileReader</span>(<span class="built_in">Logger</span>(), offset.b_offset);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Init binlog file reader failed&quot;</span> + s.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Since we init a new reader, we should drop items in write queue and reset sync_window.</span></span><br><span class="line">    <span class="comment">//Or the sent_offset and acked_offset will not match</span></span><br><span class="line">    g_pika_rm-&gt;<span class="built_in">DropItemInWriteQueue</span>(ip, port);</span><br><span class="line">    slave_ptr-&gt;sync_win.<span class="built_in">Reset</span>();</span><br><span class="line">    slave_ptr-&gt;b_state = kReadFromFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Status s = <span class="built_in">SyncBinlogToWq</span>(ip, port);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_slave_node.cc</strong></p>
<p>在 <code>InitBinlogFileReader</code> 中构造出一个 <code>binlog_reader</code> 这里会调用 <code>Seek</code> 去更新 <code>binlog_reader</code>中的 <code>filenum</code> 和 <code>offset</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SlaveNode::InitBinlogFileReader</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Binlog&gt;&amp; binlog, <span class="type">const</span> BinlogOffset&amp; offset)</span> </span>&#123;</span><br><span class="line">  binlog_reader = std::<span class="built_in">make_shared</span>&lt;PikaBinlogReader&gt;();</span><br><span class="line">  <span class="type">int</span> res = binlog_reader-&gt;<span class="built_in">Seek</span>(binlog, offset.filenum, offset.offset);</span><br><span class="line">  <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="built_in">ToString</span>() + <span class="string">&quot;  binlog reader init failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>在 <code>Seek</code> 中这里调用 <code>NewFileName</code> 将指定的 <code>Binlog</code> 文件打开，然后将文件 <code>move </code>给 <code>queue</code>, 初始化了 <code>BinlogReader</code> 中的成员变量偏移量 <code>cur_offset_</code> 和 <code>last_record_offset_</code>, 这里有个 <code>While</code> 循环去更改 <code>cur_offset</code>, 其中调用了 <code>GetNext</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PikaBinlogReader::Seek</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Binlog&gt;&amp; logger, <span class="type">uint32_t</span> filenum, <span class="type">uint64_t</span> offset)</span> </span>&#123;</span><br><span class="line">  std::string confile = <span class="built_in">NewFileName</span>(logger-&gt;<span class="built_in">filename</span>(), filenum);</span><br><span class="line">  ...</span><br><span class="line">  std::unique_ptr&lt;pstd::SequentialFile&gt; readfile;</span><br><span class="line">  <span class="keyword">if</span> (!pstd::<span class="built_in">NewSequentialFile</span>(confile, readfile).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;New swquential &quot;</span> &lt;&lt; confile &lt;&lt; <span class="string">&quot; failed&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  queue_ = std::<span class="built_in">move</span>(readfile);</span><br><span class="line">  logger_ = logger;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::lock_guard <span class="title">l</span><span class="params">(rwlock_)</span></span>;</span><br><span class="line">  cur_filenum_ = filenum;</span><br><span class="line">  cur_offset_ = offset;</span><br><span class="line">  last_record_offset_ = cur_filenum_ % kBlockSize;</span><br><span class="line"></span><br><span class="line">  pstd::Status s;</span><br><span class="line">  <span class="type">uint64_t</span> start_block = (cur_offset_ / kBlockSize) * kBlockSize;</span><br><span class="line">  s = queue_-&gt;<span class="built_in">Skip</span>((cur_offset_ / kBlockSize) * kBlockSize);</span><br><span class="line">  <span class="type">uint64_t</span> block_offset = cur_offset_ % kBlockSize;</span><br><span class="line">  <span class="type">uint64_t</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> is_error = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= block_offset) &#123;</span><br><span class="line">      cur_offset_ = start_block + res;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    is_error = <span class="built_in">GetNext</span>(&amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (is_error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res += ret;</span><br><span class="line">  &#125;</span><br><span class="line">  last_record_offset_ = cur_offset_ % kBlockSize;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>这里将 Binlog 文件重新开始读取，然后每次读完之后，<code>res</code> 会累加偏移量，等偏移量大于等于从节点的偏移量的时候停止，然后记录在 <code>last_record_offset_</code> 中，<code>last_record_offset_</code> 记录的是在某个 <code>Block</code> 中的偏移量，<code>cur_offset</code> 中记录的是在一整个文件中的偏移量.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PikaBinlogReader::GetNext</span><span class="params">(<span class="type">uint64_t</span>* size)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  pstd::Status s;</span><br><span class="line">  <span class="type">bool</span> is_error = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    buffer_.<span class="built_in">clear</span>();</span><br><span class="line">    s = queue_-&gt;<span class="built_in">Read</span>(kHeaderSize, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      is_error = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> is_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">0</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">1</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">2</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">7</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>) | (c &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &gt; (kBlockSize - kHeaderSize)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == kFullType) &#123;</span><br><span class="line">      s = queue_-&gt;<span class="built_in">Read</span>(length, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">      offset += kHeaderSize + length;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == kFirstType) &#123;</span><br><span class="line">      s = queue_-&gt;<span class="built_in">Read</span>(length, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">      offset += kHeaderSize + length;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == kMiddleType) &#123;</span><br><span class="line">      s = queue_-&gt;<span class="built_in">Read</span>(length, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">      offset += kHeaderSize + length;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == kLastType) &#123;</span><br><span class="line">      s = queue_-&gt;<span class="built_in">Read</span>(length, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">      offset += kHeaderSize + length;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == kBadRecord) &#123;</span><br><span class="line">      s = queue_-&gt;<span class="built_in">Read</span>(length, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">      offset += kHeaderSize + length;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      is_error = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *size = offset;</span><br><span class="line">  <span class="keyword">return</span> is_error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结</strong></p>
<p>在初始化 <code>BinlogReader</code> 步骤中，我们更新了在 Master 端记录的 SlaveNode 中 <code>BinlogReader</code> 的 <code>logger_</code>, <code>cur_filenum_</code>, <code>cur_offset_</code> , <code>last_record_offset</code> 的值，使其与从节点传过来的点位值保持一致，方便下一次从更新后点位开始读数据</p>
<h2 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h2><ul>
<li><p>在 TrySync 请求中已经对比过 <code>Master</code> 和 <code>Slave</code>  的 <code>Binlog</code>点位了，为什么这里要重新再次 <code>Seek</code> 一次</p>
<p>​</p>
</li>
</ul>
<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>更新完偏移量信息后，调用 <code>ReadBinlogFIleToWq</code> 将读取 Binlog 信息到 <code>write_queue</code> 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::SyncBinlogToWq</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port)</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;SlaveNode&gt; slave_ptr = <span class="built_in">GetSlaveNode</span>(ip, port);</span><br><span class="line">  <span class="keyword">if</span> (!slave_ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(<span class="string">&quot;ip &quot;</span> + ip + <span class="string">&quot; port &quot;</span> + std::<span class="built_in">to_string</span>(port));</span><br><span class="line">  &#125;</span><br><span class="line">  Status s;</span><br><span class="line">  slave_ptr-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  s = <span class="built_in">ReadBinlogFileToWq</span>(slave_ptr);</span><br><span class="line">  slave_ptr-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>首先查看滑动窗口 <code>sync_win</code>中剩余可写的 Binlog 的条数，由于是第一次写数据到滑动窗口，在配置文件中滑动窗口的最大值是 <code>9000</code>，所以我们可以最大一次性可以把 <code>9000</code> 条 <code>Binlog</code> 写到窗口里面，进入 <code>for</code> 循环之后，我们会先判断当前滑动窗口的所有的 <code>Binlog</code>字节大小是不是大于 1 个 <code>G</code> ，如果大于的话，本次就不会再往滑动窗口里面写数据，等待下一次发送，如果不大于就用 <code>reader</code> 调用 <code>Get</code>,  这里的 <code>Status s = reader-&gt;Get(&amp;msg, &amp;filenum, &amp;offset);</code> 把 Binlog 中的信息提取到 <code>msg</code> 中，同时更新了 <code>filenum</code> 和 <code>offset</code>. 然后把将信息封装成 <code>SyncWinItem</code>，这里说明一下一个 <code>SyncWinItem</code> 代表了一个完整的 <code>Binlog</code>，封装好了之后往滑动窗口里面 <code>Push</code>,  最后用 <code>WriteTask</code> 进行组装，最终装载到 <code>tasks</code> 中，每次 <code>Push</code>完一个 <code>task</code> 后，<code>Slave_ptr</code> 都会更新一下 <code>sent_offset</code> ，就是这次 <code>Reader</code> 的读取点位，在 <code>WriteTask</code> 中封装了一个 <code>RmNode</code> 和 <code>BinlogChip</code>,所以最终的 <code>tasks</code> 装载的都是发往同一个节点的 <code>Binlog</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ReadBinlogFileToWq</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SlaveNode&gt;&amp; slave_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = slave_ptr-&gt;sync_win.<span class="built_in">Remaining</span>();</span><br><span class="line">  std::shared_ptr&lt;PikaBinlogReader&gt; reader = slave_ptr-&gt;binlog_reader;</span><br><span class="line">  <span class="keyword">if</span> (!reader) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;WriteTask&gt; tasks;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">    std::string msg;</span><br><span class="line">    <span class="type">uint32_t</span> filenum;</span><br><span class="line">    <span class="type">uint64_t</span> offset;</span><br><span class="line">    <span class="keyword">if</span> (slave_ptr-&gt;sync_win.<span class="built_in">GetTotalBinlogSize</span>() &gt; PIKA_MAX_CONN_RBUF_HB * <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; slave_ptr-&gt;<span class="built_in">ToString</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot; total binlog size in sync window is :&quot;</span> &lt;&lt; slave_ptr-&gt;sync_win.<span class="built_in">GetTotalBinlogSize</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Status s = reader-&gt;<span class="built_in">Get</span>(&amp;msg, &amp;filenum, &amp;offset);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">IsEndFile</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">IsCorruption</span>() || s.<span class="built_in">IsIOError</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; Read Binlog error : &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    BinlogItem item;</span><br><span class="line">    <span class="keyword">if</span> (!PikaBinlogTransverter::<span class="built_in">BinlogItemWithoutContentDecode</span>(TypeFirst, msg, &amp;item)) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Binlog item decode failed&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Binlog item decode failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BinlogOffset sent_b_offset = <span class="built_in">BinlogOffset</span>(filenum, offset);</span><br><span class="line">    LogicOffset sent_l_offset = <span class="built_in">LogicOffset</span>(item.<span class="built_in">term_id</span>(), item.<span class="built_in">logic_id</span>());</span><br><span class="line">    <span class="function">LogOffset <span class="title">sent_offset</span><span class="params">(sent_b_offset, sent_l_offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    slave_ptr-&gt;sync_win.<span class="built_in">Push</span>(<span class="built_in">SyncWinItem</span>(sent_offset, msg.<span class="built_in">size</span>()));</span><br><span class="line">    slave_ptr-&gt;<span class="built_in">SetLastSendTime</span>(pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">    <span class="function">RmNode <span class="title">rm_node</span><span class="params">(slave_ptr-&gt;Ip(), slave_ptr-&gt;Port(), slave_ptr-&gt;DBName(), slave_ptr-&gt;SlotId(),</span></span></span><br><span class="line"><span class="params"><span class="function">                   slave_ptr-&gt;SessionId())</span></span>;</span><br><span class="line">    <span class="function">WriteTask <span class="title">task</span><span class="params">(rm_node, BinlogChip(sent_offset, msg), slave_ptr-&gt;sent_offset)</span></span>;</span><br><span class="line">    tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">    slave_ptr-&gt;sent_offset = sent_offset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    g_pika_rm-&gt;<span class="built_in">ProduceWriteQueue</span>(slave_ptr-&gt;<span class="built_in">Ip</span>(), slave_ptr-&gt;<span class="built_in">Port</span>(), slot_info_.slot_id_, tasks);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>在 Get 函数中，调用 <code>Consume</code> 用来提取 <code>Binlog</code> 中的信息，如果当前的 <code>Binlog</code> 文件已经读到底了，则切换 <code>Binlog</code> 文件，更新 <code>filenum</code> 使其加 1，<code>offset</code> 初始化为 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a whole message;</span></span><br><span class="line"><span class="comment">// Append to scratch;</span></span><br><span class="line"><span class="comment">// the status will be OK, IOError or Corruption, EndFile;</span></span><br><span class="line"><span class="function">Status <span class="title">PikaBinlogReader::Get</span><span class="params">(std::string* scratch, <span class="type">uint32_t</span>* filenum, <span class="type">uint64_t</span>* offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!logger_ || !queue_) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Not seek&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  Status s = Status::<span class="built_in">OK</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReadToTheEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">EndFile</span>(<span class="string">&quot;End of cur log file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="built_in">Consume</span>(scratch, filenum, offset);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">IsEndFile</span>()) &#123;</span><br><span class="line">      std::string confile = <span class="built_in">NewFileName</span>(logger_-&gt;<span class="built_in">filename</span>(), cur_filenum_ + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// sleep 10ms wait produce thread generate the new binlog</span></span><br><span class="line">      <span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Roll to next file need retry;</span></span><br><span class="line">      <span class="keyword">if</span> (pstd::<span class="built_in">FileExists</span>(confile)) &#123;</span><br><span class="line">        <span class="built_in">DLOG</span>(INFO) &lt;&lt; <span class="string">&quot;BinlogSender roll to new binlog&quot;</span> &lt;&lt; confile;</span><br><span class="line">        queue_.<span class="built_in">reset</span>();</span><br><span class="line">        queue_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        pstd::<span class="built_in">NewSequentialFile</span>(confile, queue_);</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="function">std::lock_guard <span class="title">l</span><span class="params">(rwlock_)</span></span>;</span><br><span class="line">          cur_filenum_++;</span><br><span class="line">          cur_offset_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last_record_offset_ = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">IOError</span>(<span class="string">&quot;File Does Not Exists&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">IsEndFile</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>在 <code>Consume</code> 中，如果当前记录是 <code>kFullType</code> 则一次性将读到的数据写到 <code>scratch</code> 中，如果是其他的类型，则进行数据的追加或者报异常，这里是个 <code>while</code> 循环去处理，每次取到一个完整的 <code>Binlog</code> 条数就退出循环（一条 <code>Binlog</code> 可能由一条或者多条 <code>Record</code> 组成）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaBinlogReader::Consume</span><span class="params">(std::string* scratch, <span class="type">uint32_t</span>* filenum, <span class="type">uint64_t</span>* offset)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  pstd::Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment, filenum, offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        *scratch = std::<span class="built_in">string</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">OK</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">NotFound</span>(<span class="string">&quot;Middle Status&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">NotFound</span>(<span class="string">&quot;Middle Status&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        s = Status::<span class="built_in">OK</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kEof:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">EndFile</span>(<span class="string">&quot;Eof&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> kBadRecord:</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Read BadRecord record, will decode failed, this record may dbsync padded record, not processed here&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">IOError</span>(<span class="string">&quot;Data Corruption&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> kOldRecord:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">EndFile</span>(<span class="string">&quot;Eof&quot;</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">IOError</span>(<span class="string">&quot;Unknow reason&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// DLOG(INFO) &lt;&lt; &quot;Binlog Sender consumer a msg: &quot; &lt;&lt; scratch;</span></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog_reader.cc</strong></p>
<p>我们可以看到每个 <code>Slave</code>节点中的 <code>binlogreader</code> 都保存了上次读取到的文件偏移量以及文件名，所以这样的设计解决了每次 Master 需要发生给 slave 哪些信息，首先我们先判断当前读取的这个 <code>Block</code> 剩下的字节数是不是小于 <code>kHreadSize</code> ，如果小于的话，我们则跳过当前这个 <code>block</code>， 从下一个 <code>block</code> 开始，然后调用 <code>Read</code> 函数先取元信息 <code>kHeaderSize</code> 的头部放到 <code>buffer_</code> 中，然后获取到 <code>length</code> 长度，然后继续往 <code>buffer_</code> 中追加后面的内容，将结果存在 <code>result</code> 里面，同时更新 <code>last_record_offset</code> 偏移量，然后继续返回上一层的循环中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">PikaBinlogReader::ReadPhysicalRecord</span><span class="params">(pstd::Slice* result, <span class="type">uint32_t</span>* filenum, <span class="type">uint64_t</span>* offset)</span> </span>&#123;</span><br><span class="line">  pstd::Status s;</span><br><span class="line">  <span class="keyword">if</span> (kBlockSize - last_record_offset_ &lt;= kHeaderSize) &#123;</span><br><span class="line">    queue_-&gt;<span class="built_in">Skip</span>(kBlockSize - last_record_offset_);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(rwlock_)</span></span>;</span><br><span class="line">    cur_offset_ += (kBlockSize - last_record_offset_);</span><br><span class="line">    last_record_offset_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  s = queue_-&gt;<span class="built_in">Read</span>(kHeaderSize, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">IsEndFile</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> kEof;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">0</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">1</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">2</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">7</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>) | (c &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (length &gt; (kBlockSize - kHeaderSize)) &#123;</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == kZeroType || length == <span class="number">0</span>) &#123;</span><br><span class="line">    buffer_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> kOldRecord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  s = queue_-&gt;<span class="built_in">Read</span>(length, &amp;buffer_, backing_store_.<span class="built_in">get</span>());</span><br><span class="line">  *result = pstd::<span class="built_in">Slice</span>(buffer_.<span class="built_in">data</span>(), buffer_.<span class="built_in">size</span>());</span><br><span class="line">  last_record_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(rwlock_)</span></span>;</span><br><span class="line">    *filenum = cur_filenum_;</span><br><span class="line">    cur_offset_ += (kHeaderSize + length);</span><br><span class="line">    *offset = cur_offset_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>把所有的 <code>WriteTask</code> 写到 <code>write_queues_</code> 里面待发送，这里的 <code>task</code> 里面包括了每个 <code>Binlog</code> 的偏移量以及数据内容，而且这里的 <code>tasks</code> 是发往同一批 <code>slot</code> 的 <code>Binlog</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplicaManager::ProduceWriteQueue</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">uint32_t</span> slot_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> std::vector&lt;WriteTask&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard <span class="title">l</span><span class="params">(write_queue_mu_)</span></span>;</span><br><span class="line">  std::string index = ip + <span class="string">&quot;:&quot;</span> + std::<span class="built_in">to_string</span>(port);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">    write_queues_[index][slot_id].<span class="built_in">push</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_auxiliary_thread.cc</strong></p>
<p>辅助线程中的 <code>SendToPeer</code> 是将上面的 <code>write_queues_</code> 的数据发送给从节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">PikaAuxiliaryThread::ThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">should_stop</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pika_server-&gt;<span class="built_in">ShouldMetaSync</span>()) &#123;</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">SendMetaSyncRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g_pika_server-&gt;<span class="built_in">MetaSyncDone</span>()) &#123;</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">RunSyncSlaveSlotStateMachine</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pstd::Status s = g_pika_rm-&gt;<span class="built_in">CheckSyncTimeout</span>(pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_pika_server-&gt;<span class="built_in">CheckLeaderProtectedMode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(whoiami) timeout</span></span><br><span class="line">    s = g_pika_server-&gt;<span class="built_in">TriggerSendBinlogSync</span>();</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send to peer</span></span><br><span class="line">    <span class="type">int</span> res = g_pika_server-&gt;<span class="built_in">SendToPeer</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// sleep 100 ms</span></span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu_)</span></span>;</span><br><span class="line">      cv_.<span class="built_in">wait_for</span>(lock, <span class="number">100</span>ms);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// LOG_EVERY_N(INFO, 1000) &lt;&lt; &quot;Consume binlog number &quot; &lt;&lt; res;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_server.cc</strong></p>
<p>调用 <code>ConsumWriterQueue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PikaServer::SendToPeer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g_pika_rm-&gt;<span class="built_in">ConsumeWriteQueue</span>(); &#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里把发往同一批机器的 <code>Binlog</code> 存放在 <code>to_send_map</code> 中，然后调用 <code>SendSlaveBinlogChips</code> 发送 <code>BinlogSync</code> 回包，这里注意一次发往一个 <code>slot</code> 的 <code>Binlog</code>信息最大不会超过 <code>4000</code> 条, 同时这里的 <code>SendSlaveBinlogChips</code> 是在一个 <code>for</code> 循环里面的，说明主节点在一次 <code>BinlogSync</code> 中可能给从节点回复了多次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PikaReplicaManager::ConsumeWriteQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;WriteTask&gt;&gt;&gt; to_send_map;</span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(write_queue_mu_)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : write_queues_) &#123;</span><br><span class="line">      <span class="type">const</span> std::string&amp; ip_port = iter.first;</span><br><span class="line">      std::unordered_map&lt;<span class="type">uint32_t</span>, std::queue&lt;WriteTask&gt;&gt;&amp; p_map = iter.second;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; slot_queue : p_map) &#123;</span><br><span class="line">        std::queue&lt;WriteTask&gt;&amp; queue = slot_queue.second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kBinlogSendPacketNum; ++i) &#123;</span><br><span class="line">          <span class="keyword">if</span> (queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">size_t</span> batch_index = queue.<span class="built_in">size</span>() &gt; kBinlogSendBatchNum ? kBinlogSendBatchNum : queue.<span class="built_in">size</span>();</span><br><span class="line">          std::vector&lt;WriteTask&gt; to_send;</span><br><span class="line">          <span class="type">size_t</span> batch_size = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; batch_index; ++i) &#123;</span><br><span class="line">            WriteTask&amp; task = queue.<span class="built_in">front</span>();</span><br><span class="line">            batch_size += task.binlog_chip_.binlog_.<span class="built_in">size</span>();</span><br><span class="line">            ...</span><br><span class="line">            to_send.<span class="built_in">push_back</span>(task);</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            counter++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!to_send.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            to_send_map[ip_port].<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(to_send));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; to_delete;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : to_send_map) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; to_send : iter.second) &#123;</span><br><span class="line">      Status s = pika_repl_server_-&gt;<span class="built_in">SendSlaveBinlogChips</span>(ip, port, to_send);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;send binlog to &quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot; failed, &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">        to_delete.<span class="built_in">push_back</span>(iter.first);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h2><ul>
<li>这里为什么是发送 <code>binlog</code> 信息失败了就把 <code>write_queues</code> 相应的数据删了</li>
</ul>
<p><strong>pika_repl_server.cc</strong></p>
<p>这里调用  <code>BuildSyncResp</code> 构造 <code>BinlogSync</code> 请求的回包，这里注意的是如果一个 <code>Proto</code> 回包数据大小大于 <code>256M</code> 的话，则将这里面的数据拆成多个 <code>Proro</code> 发送</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pstd::Status <span class="title">PikaReplServer::SendSlaveBinlogChips</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> std::vector&lt;WriteTask&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">  InnerMessage::InnerResponse response;</span><br><span class="line">  <span class="built_in">BuildBinlogSyncResp</span>(tasks, &amp;response);</span><br><span class="line"></span><br><span class="line">  std::string binlog_chip_pb;</span><br><span class="line">  <span class="keyword">if</span> (!response.<span class="built_in">SerializeToString</span>(&amp;binlog_chip_pb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Serialized Failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (binlog_chip_pb.<span class="built_in">size</span>() &gt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(g_pika_conf-&gt;<span class="built_in">max_conn_rbuf_size</span>())) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">      InnerMessage::InnerResponse response;</span><br><span class="line">      std::vector&lt;WriteTask&gt; tmp_tasks;</span><br><span class="line">      tmp_tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">      <span class="built_in">BuildBinlogSyncResp</span>(tmp_tasks, &amp;response);</span><br><span class="line">      <span class="keyword">if</span> (!response.<span class="built_in">SerializeToString</span>(&amp;binlog_chip_pb)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Serialized Failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pstd::Status s = <span class="built_in">Write</span>(ip, port, binlog_chip_pb);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pstd::Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(ip, port, binlog_chip_pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_server.cc</strong></p>
<p>主节点给从节点回了 <code>db_name</code>, <code>slot_id</code>, <code>session_id</code>, <code>boffset</code>，<code>binlog_</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplServer::BuildBinlogSyncResp</span><span class="params">(<span class="type">const</span> std::vector&lt;WriteTask&gt;&amp; tasks, InnerMessage::InnerResponse* response)</span> </span>&#123;</span><br><span class="line">  response-&gt;<span class="built_in">set_code</span>(InnerMessage::kOk);</span><br><span class="line">  response-&gt;<span class="built_in">set_type</span>(InnerMessage::Type::kBinlogSync);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">    InnerMessage::InnerResponse::BinlogSync* binlog_sync = response-&gt;<span class="built_in">add_binlog_sync</span>();</span><br><span class="line">    binlog_sync-&gt;<span class="built_in">set_session_id</span>(task.rm_node_.<span class="built_in">SessionId</span>());</span><br><span class="line">    InnerMessage::Slot* slot = binlog_sync-&gt;<span class="built_in">mutable_slot</span>();</span><br><span class="line">    slot-&gt;<span class="built_in">set_db_name</span>(task.rm_node_.<span class="built_in">DBName</span>());</span><br><span class="line">    slot-&gt;<span class="built_in">set_slot_id</span>(task.rm_node_.<span class="built_in">SlotId</span>());</span><br><span class="line">    InnerMessage::BinlogOffset* boffset = binlog_sync-&gt;<span class="built_in">mutable_binlog_offset</span>();</span><br><span class="line">    <span class="built_in">BuildBinlogOffset</span>(task.binlog_chip_.offset_, boffset);</span><br><span class="line">    binlog_sync-&gt;<span class="built_in">set_binlog</span>(task.binlog_chip_.binlog_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BinlogSync-总结"><a href="#BinlogSync-总结" class="headerlink" title="BinlogSync 总结"></a>BinlogSync 总结</h2><p>在主节点给从节点的 <code>kBinlogSync</code> 回复中，包括 <code>session_id</code>, <code>db_name</code>, <code>slot_id</code>, <code>binlog_offset</code>, <code>binlog_</code></p>
<img width="788" alt="截屏2024-01-25 10 14 22" src="https://github.com/OpenAtomFoundation/pika/assets/73943232/2b243e08-d128-4f93-8e51-7d64595d0f08">



<h2 id="Slave-端生产和消费-Binlog"><a href="#Slave-端生产和消费-Binlog" class="headerlink" title="Slave 端生产和消费 Binlog"></a>Slave 端生产和消费 Binlog</h2><p><strong>src&#x2F;pika_repl_client_conn.cc</strong></p>
<p>这里的 <code>DispatchBinlogRes</code> 是 Slave 端处理由 Master 端发过来的 <code>Binlog</code> 回包，调用 <code>SchduleWriteBinlogTask</code> 去处理 <code>Binlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplClientConn::DispatchBinlogRes</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerResponse&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// slot to a bunch of binlog chips</span></span><br><span class="line">  std::unordered_map&lt;SlotInfo, std::vector&lt;<span class="type">int</span>&gt;*, hash_slot_info&gt; par_binlog;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res-&gt;<span class="built_in">binlog_sync_size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::InnerResponse::BinlogSync&amp; binlog_res = res-&gt;<span class="built_in">binlog_sync</span>(i);</span><br><span class="line">    <span class="comment">// hash key: db + slot_id</span></span><br><span class="line">    <span class="function">SlotInfo <span class="title">p_info</span><span class="params">(binlog_res.slot().db_name(), binlog_res.slot().slot_id())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (par_binlog.<span class="built_in">find</span>(p_info) == par_binlog.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      par_binlog[p_info] = <span class="keyword">new</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    par_binlog[p_info]-&gt;<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;SyncSlaveSlot&gt; slave_slot = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; binlog_nums : par_binlog) &#123;</span><br><span class="line">    <span class="function">RmNode <span class="title">node</span><span class="params">(binlog_nums.first.db_name_, binlog_nums.first.slot_id_)</span></span>;</span><br><span class="line">    slave_slot = g_pika_rm-&gt;<span class="built_in">GetSyncSlaveSlotByName</span>(</span><br><span class="line">        <span class="built_in">SlotInfo</span>(binlog_nums.first.db_name_, binlog_nums.first.slot_id_));</span><br><span class="line">    <span class="keyword">if</span> (!slave_slot) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slave Slot: &quot;</span> &lt;&lt; binlog_nums.first.db_name_ &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; binlog_nums.first.slot_id_</span><br><span class="line">                   &lt;&lt; <span class="string">&quot; not exist&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slave_slot-&gt;<span class="built_in">SetLastRecvTime</span>(pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">    g_pika_rm-&gt;<span class="built_in">ScheduleWriteBinlogTask</span>(binlog_nums.first.db_name_ + std::<span class="built_in">to_string</span>(binlog_nums.first.slot_id_),</span><br><span class="line">                                       res, std::<span class="built_in">dynamic_pointer_cast</span>&lt;PikaReplClientConn&gt;(<span class="built_in">shared_from_this</span>()),</span><br><span class="line">                                       <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(binlog_nums.second));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里调用了 <code>ScheduleWriteBinlogTask</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplicaManager::ScheduleWriteBinlogTask</span><span class="params">(<span class="type">const</span> std::string&amp; db_slot,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerResponse&gt;&amp; res,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> std::shared_ptr&lt;net::PbConn&gt;&amp; conn, <span class="type">void</span>* res_private_data)</span> </span>&#123;</span><br><span class="line">  pika_repl_client_-&gt;<span class="built_in">ScheduleWriteBinlogTask</span>(db_slot, res, conn, res_private_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_clint.cc</strong></p>
<p>这里调用了 <code>Schedule</code> 让 <code>worker</code> 线程去异步处理 <code>HandleBGWokerWriteBinlog</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplClient::ScheduleWriteBinlogTask</span><span class="params">(<span class="type">const</span> std::string&amp; db_slot,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> std::shared_ptr&lt;InnerMessage::InnerResponse&gt;&amp; res,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> std::shared_ptr&lt;net::PbConn&gt;&amp; conn, <span class="type">void</span>* res_private_data)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">GetHashIndex</span>(db_slot, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">auto</span> task_arg = <span class="keyword">new</span> <span class="built_in">ReplClientWriteBinlogTaskArg</span>(res, conn, res_private_data, bg_workers_[index].<span class="built_in">get</span>());</span><br><span class="line">  bg_workers_[index]-&gt;<span class="built_in">Schedule</span>(&amp;PikaReplBgWorker::HandleBGWorkerWriteBinlog, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(task_arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_bgworker.cc</strong></p>
<p>这里将 <code>binlog_res</code> 里面的 <code>binlog().data()</code>进行序列化解析，然后放在 <code>ProcessInputBuffer</code> 里面处理，这里可以看到 <code>HandelBGWorkerWriteBinlog</code> 函数的最后调用了 <code>SendSlotBinlogSyncAckRequest</code> 就是说处理完上一个 <code>Binlog</code> 回包马上又发了一个新的 <code>BinlogSync</code> 请求过去，这里需要注意的是这个请求中的两个参数 <code>ack_start</code> 和 <code>ack_end</code>,  下次传过去时候的 <code>ack_start</code> 就是这次 <code>Binlog</code> 回包时传进来的 <code>ack_start</code> ，但是下次传过去的 <code>ack_end</code>是本次 <code>Binlog</code> 写完之后的偏移量，所以 <code>ack_start</code> 一定是一样的. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplBgWorker::HandleBGWorkerWriteBinlog</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the first not keepalive binlogsync</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; index-&gt;<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">const</span> InnerMessage::InnerResponse::BinlogSync&amp; binlog_res = res-&gt;<span class="built_in">binlog_sync</span>((*index)[i]);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      db_name = binlog_res.<span class="built_in">slot</span>().<span class="built_in">db_name</span>();</span><br><span class="line">      slot_id = binlog_res.<span class="built_in">slot</span>().<span class="built_in">slot_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!binlog_res.<span class="built_in">binlog</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">ParseBinlogOffset</span>(binlog_res.<span class="built_in">binlog_offset</span>(), &amp;pb_begin);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pb_begin == <span class="built_in">LogOffset</span>()) &#123;</span><br><span class="line">    only_keepalive = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LogOffset ack_start;</span><br><span class="line">  <span class="keyword">if</span> (only_keepalive) &#123;</span><br><span class="line">    ack_start = <span class="built_in">LogOffset</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ack_start = pb_begin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i : *index) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* redis_parser_start = binlog_res.<span class="built_in">binlog</span>().<span class="built_in">data</span>() + BINLOG_ENCODE_LEN;</span><br><span class="line">    <span class="type">int</span> redis_parser_len = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(binlog_res.<span class="built_in">binlog</span>().<span class="built_in">size</span>()) - BINLOG_ENCODE_LEN;</span><br><span class="line">    <span class="type">int</span> processed_len = <span class="number">0</span>;</span><br><span class="line">    net::RedisParserStatus ret =</span><br><span class="line">        worker-&gt;redis_parser_.<span class="built_in">ProcessInputBuffer</span>(redis_parser_start, redis_parser_len, &amp;processed_len); <span class="comment">// 处理Binlog</span></span><br><span class="line">    <span class="keyword">if</span> (ret != net::kRedisParserDone) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Redis parser failed&quot;</span>;</span><br><span class="line">      slave_slot-&gt;<span class="built_in">SetReplState</span>(ReplState::kTryConnect);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  LogOffset ack_end;</span><br><span class="line">  <span class="keyword">if</span> (only_keepalive) &#123;</span><br><span class="line">    ack_end = <span class="built_in">LogOffset</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LogOffset productor_status;</span><br><span class="line">    <span class="comment">// Reply Ack to master immediately</span></span><br><span class="line">    std::shared_ptr&lt;Binlog&gt; logger = slot-&gt;<span class="built_in">Logger</span>();</span><br><span class="line">    logger-&gt;<span class="built_in">GetProducerStatus</span>(&amp;productor_status.b_offset.filenum, &amp;productor_status.b_offset.offset,</span><br><span class="line">                              &amp;productor_status.l_offset.term, &amp;productor_status.l_offset.index);</span><br><span class="line">    ack_end = productor_status;</span><br><span class="line">    ack_end.l_offset.term = pb_end.l_offset.term;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_pika_rm-&gt;<span class="built_in">SendSlotBinlogSyncAckRequest</span>(db_name, slot_id, ack_start, ack_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;redis_parser.cc</strong></p>
<p>调用 <code>ProcessRequestBuffer</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisParserStatus <span class="title">RedisParser::ProcessInputBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input_buf, <span class="type">int</span> length, <span class="type">int</span>* parsed_len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status_code_ == kRedisParserInitDone || status_code_ == kRedisParserHalf || status_code_ == kRedisParserDone) &#123;</span><br><span class="line">    <span class="comment">// TODO(): AZ: avoid copy</span></span><br><span class="line">    <span class="function">std::string <span class="title">tmp_str</span><span class="params">(input_buf, length)</span></span>;</span><br><span class="line">    input_str_ = half_argv_ + tmp_str;</span><br><span class="line">    input_buf_ = input_str_.<span class="built_in">c_str</span>();</span><br><span class="line">    length_ = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(length + half_argv_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (redis_parser_type_ == REDIS_PARSER_REQUEST) &#123;</span><br><span class="line">      <span class="built_in">ProcessRequestBuffer</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redis_parser_type_ == REDIS_PARSER_RESPONSE) &#123;</span><br><span class="line">      <span class="built_in">ProcessResponseBuffer</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserInitError);</span><br><span class="line">      <span class="keyword">return</span> status_code_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur_pos_ starts from 0, val of cur_pos_ is the parsed_len</span></span><br><span class="line">    *parsed_len = cur_pos_;</span><br><span class="line">    <span class="built_in">ResetRedisParser</span>();</span><br><span class="line">    <span class="comment">// PrintCurrentStatus();</span></span><br><span class="line">    <span class="keyword">return</span> status_code_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserInitError);</span><br><span class="line">  <span class="keyword">return</span> status_code_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;redis_parser.cc</strong></p>
<p>这里将解析好的 <code>cmd</code> 放到 <code>argv_</code> 中，然后触发 <code>DealMessage</code> 调用 <code>HandleWriteBinlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisParserStatus <span class="title">RedisParser::ProcessRequestBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  RedisParserStatus ret;</span><br><span class="line">  <span class="keyword">while</span> (cur_pos_ &lt;= length_ - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redis_type_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (input_buf_[cur_pos_] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        redis_type_ = REDIS_REQ_MULTIBULK;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis_type_ = REDIS_REQ_INLINE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redis_type_ == REDIS_REQ_INLINE) &#123;</span><br><span class="line">      ret = <span class="built_in">ProcessInlineBuffer</span>();</span><br><span class="line">      <span class="keyword">if</span> (ret != kRedisParserDone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redis_type_ == REDIS_REQ_MULTIBULK) &#123;</span><br><span class="line">      ret = <span class="built_in">ProcessMultibulkBuffer</span>();</span><br><span class="line">      <span class="keyword">if</span> (ret != kRedisParserDone) &#123;  <span class="comment">// FULL_ERROR || HALF || PARSE_ERROR</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Unknown requeset type;</span></span><br><span class="line">      <span class="keyword">return</span> kRedisParserError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!argv_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      argvs_.<span class="built_in">push_back</span>(argv_);</span><br><span class="line">      <span class="keyword">if</span> (parser_settings_.DealMessage) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parser_settings_.<span class="built_in">DealMessage</span>(<span class="keyword">this</span>, argv_) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserDealError);</span><br><span class="line">          <span class="keyword">return</span> status_code_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// Reset</span></span><br><span class="line">    <span class="built_in">ResetCommandStatus</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (parser_settings_.Complete) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parser_settings_.<span class="built_in">Complete</span>(<span class="keyword">this</span>, argvs_) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">SetParserStatus</span>(kRedisParserError, kRedisParserCompleteError);</span><br><span class="line">      <span class="keyword">return</span> status_code_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  argvs_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">SetParserStatus</span>(kRedisParserDone);</span><br><span class="line">  <span class="keyword">return</span> status_code_;  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_bgworker.cc</strong></p>
<p>这里调用 <code>ConsensusProcessLeaderLog</code> 处理 <code>Binlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PikaReplBgWorker::HandleWriteBinlog</span><span class="params">(net::RedisParser* parser, <span class="type">const</span> net::RedisCmdArgsType&amp; argv)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  slot-&gt;<span class="built_in">ConsensusProcessLeaderLog</span>(c_ptr, worker-&gt;binlog_item_);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ProposeLeaderLog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ConsensusProcessLeaderLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> BinlogItem&amp; attribute)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> coordinator_.<span class="built_in">ProcessLeaderLog</span>(cmd_ptr, attribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>InternalAppendLog</code> 先写 Binlog，然后 <code>InternalApplyFollower</code>异步消费 Binlog</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// precheck if prev_offset match &amp;&amp; drop this log if this log exist</span></span><br><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::ProcessLeaderLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> BinlogItem&amp; attribute)</span> </span>&#123;</span><br><span class="line">  LogOffset last_index = mem_logger_-&gt;<span class="built_in">last_offset</span>();</span><br><span class="line">  <span class="keyword">if</span> (attribute.<span class="built_in">logic_id</span>() &lt; last_index.l_offset.index) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="built_in">SlotInfo</span>(db_name_, slot_id_).<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;Drop log from leader logic_id &quot;</span></span><br><span class="line">                 &lt;&lt; attribute.<span class="built_in">logic_id</span>() &lt;&lt; <span class="string">&quot; cur last index &quot;</span> &lt;&lt; last_index.l_offset.index;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Status s = <span class="built_in">InternalAppendLog</span>(attribute, cmd_ptr, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InternalApplyFollower</span>(MemLog::<span class="built_in">LogItem</span>(<span class="built_in">LogOffset</span>(), cmd_ptr, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="写-Binlog"><a href="#写-Binlog" class="headerlink" title="写 Binlog"></a>写 Binlog</h3><p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>InternalAppendBinlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendLog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  LogOffset log_offset;</span><br><span class="line">  Status s = <span class="built_in">InternalAppendBinlog</span>(item, cmd_ptr, &amp;log_offset);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>这里现将命令序列化然后调用 <code>put</code> 函数将 <code>content</code> 写到 <code>Binlog</code> 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendBinlog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  LogOffset* log_offset)</span> </span>&#123;</span><br><span class="line">  std::string content = cmd_ptr-&gt;<span class="built_in">ToRedisProtocol</span>();</span><br><span class="line">  Status s = stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">Put</span>(content);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::string db_name = cmd_ptr-&gt;<span class="built_in">db_name</span>().<span class="built_in">empty</span>() ? g_pika_conf-&gt;<span class="built_in">default_db</span>() : cmd_ptr-&gt;<span class="built_in">db_name</span>();</span><br><span class="line">    std::shared_ptr&lt;DB&gt; db = g_pika_server-&gt;<span class="built_in">GetDB</span>(db_name);</span><br><span class="line">    <span class="keyword">if</span> (db) &#123;</span><br><span class="line">      db-&gt;<span class="built_in">SetBinlogIoError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> filenum;</span><br><span class="line">  <span class="type">uint64_t</span> offset;</span><br><span class="line">  stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">GetProducerStatus</span>(&amp;filenum, &amp;offset);</span><br><span class="line">  *log_offset = <span class="built_in">LogOffset</span>(<span class="built_in">BinlogOffset</span>(filenum, offset), <span class="built_in">LogicOffset</span>(item.<span class="built_in">term_id</span>(), item.<span class="built_in">logic_id</span>()));</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="消费-Binlog"><a href="#消费-Binlog" class="headerlink" title="消费 Binlog"></a>消费 Binlog</h3><p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>SchduleWriteDBTask</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsensusCoordinator::InternalApplyFollower</span><span class="params">(<span class="type">const</span> MemLog::LogItem&amp; log)</span> </span>&#123;</span><br><span class="line">  g_pika_rm-&gt;<span class="built_in">ScheduleWriteDBTask</span>(log.cmd_ptr, log.offset, db_name_, slot_id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ScheduleWriteDBTask</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplicaManager::ScheduleWriteDBTask</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> LogOffset&amp; offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> std::string&amp; db_name, <span class="type">uint32_t</span> slot_id)</span> </span>&#123;</span><br><span class="line">  pika_repl_client_-&gt;<span class="built_in">ScheduleWriteDBTask</span>(cmd_ptr, offset, db_name, slot_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_repl_client.cc</strong></p>
<p>调用 <code>Schedule</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplClient::ScheduleWriteDBTask</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, <span class="type">const</span> LogOffset&amp; offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> std::string&amp; db_name, <span class="type">uint32_t</span> slot_id)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> PikaCmdArgsType&amp; argv = cmd_ptr-&gt;<span class="built_in">argv</span>();</span><br><span class="line">  std::string dispatch_key = argv.<span class="built_in">size</span>() &gt;= <span class="number">2</span> ? argv[<span class="number">1</span>] : argv[<span class="number">0</span>];</span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">GetHashIndex</span>(dispatch_key, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">auto</span> task_arg = <span class="keyword">new</span> <span class="built_in">ReplClientWriteDBTaskArg</span>(cmd_ptr, offset, db_name, slot_id);</span><br><span class="line">  bg_workers_[index]-&gt;<span class="built_in">Schedule</span>(&amp;PikaReplBgWorker::HandleBGWorkerWriteDB, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(task_arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>pika_repl_bgworker.cc</strong></p>
<p>这里是消费 Binlog 的步骤，就是调用 <code>Do</code> 执行命令的流程了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplBgWorker::HandleBGWorkerWriteDB</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;ReplClientWriteDBTaskArg&gt; <span class="title">task_arg</span><span class="params">(<span class="keyword">static_cast</span>&lt;ReplClientWriteDBTaskArg*&gt;(arg))</span></span>;</span><br><span class="line">  <span class="type">const</span> std::shared_ptr&lt;Cmd&gt; c_ptr = task_arg-&gt;cmd_ptr;</span><br><span class="line">  <span class="type">const</span> PikaCmdArgsType&amp; argv = c_ptr-&gt;<span class="built_in">argv</span>();</span><br><span class="line">  LogOffset offset = task_arg-&gt;offset;</span><br><span class="line">  std::string db_name = task_arg-&gt;db_name;</span><br><span class="line">  <span class="type">uint32_t</span> slot_id = task_arg-&gt;slot_id;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> start_us = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    start_us = pstd::<span class="built_in">NowMicros</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;Slot&gt; slot = g_pika_server-&gt;<span class="built_in">GetDBSlotById</span>(db_name, slot_id);</span><br><span class="line">  <span class="comment">// Add read lock for no suspend command</span></span><br><span class="line">  <span class="keyword">if</span> (!c_ptr-&gt;<span class="built_in">IsSuspend</span>()) &#123;</span><br><span class="line">    slot-&gt;<span class="built_in">DbRWLockReader</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c_ptr-&gt;<span class="built_in">IsNeedCacheDo</span>()</span><br><span class="line">      &amp;&amp; PIKA_CACHE_NONE != g_pika_conf-&gt;<span class="built_in">cache_model</span>()</span><br><span class="line">      &amp;&amp; slot-&gt;<span class="built_in">cache</span>()-&gt;<span class="built_in">CacheStatus</span>() == PIKA_CACHE_STATUS_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c_ptr-&gt;<span class="built_in">is_write</span>()) &#123;</span><br><span class="line">      c_ptr-&gt;<span class="built_in">DoThroughDB</span>(slot);</span><br><span class="line">      <span class="keyword">if</span> (c_ptr-&gt;<span class="built_in">IsNeedUpdateCache</span>()) &#123;</span><br><span class="line">        c_ptr-&gt;<span class="built_in">DoUpdateCache</span>(slot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;This branch is not impossible reach&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c_ptr-&gt;<span class="built_in">Do</span>(slot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!c_ptr-&gt;<span class="built_in">IsSuspend</span>()) &#123;</span><br><span class="line">    slot-&gt;<span class="built_in">DbRWUnLock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(start_us / <span class="number">1000000</span>);</span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(pstd::<span class="built_in">NowMicros</span>() - start_us);</span><br><span class="line">    <span class="keyword">if</span> (duration &gt; g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>()) &#123;</span><br><span class="line">      g_pika_server-&gt;<span class="built_in">SlowlogPushEntry</span>(argv, start_time, duration);</span><br><span class="line">      <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_write_errorlog</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;command: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, start_time(s): &quot;</span> &lt;&lt; start_time &lt;&lt; <span class="string">&quot;, duration(us): &quot;</span> &lt;&lt; duration;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>在生产和消费完 <code>Binlog</code> 之后，从节点再次发起 <code>BinlogSync</code> 请求和之前的步骤都是一样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaReplicaManager::SendSlotBinlogSyncAckRequest</span><span class="params">(<span class="type">const</span> std::string&amp; db, <span class="type">uint32_t</span> slot_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">const</span> LogOffset&amp; ack_start, <span class="type">const</span> LogOffset&amp; ack_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">bool</span> is_first_send)</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;SyncSlaveSlot&gt; slave_slot = <span class="built_in">GetSyncSlaveSlotByName</span>(<span class="built_in">SlotInfo</span>(db, slot_id));</span><br><span class="line">  <span class="keyword">if</span> (!slave_slot) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slave Slot: &quot;</span> &lt;&lt; db &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot;, NotFound&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Slave Slot not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pika_repl_client_-&gt;<span class="built_in">SendSlotBinlogSync</span>(slave_slot-&gt;<span class="built_in">MasterIp</span>(), slave_slot-&gt;<span class="built_in">MasterPort</span>(), db,</span><br><span class="line">                                                    slot_id, ack_start, ack_end, slave_slot-&gt;<span class="built_in">LocalIp</span>(),</span><br><span class="line">                                                    is_first_send);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="Master-接收-Slave-的-kBinlogSync-请求"><a href="#Master-接收-Slave-的-kBinlogSync-请求" class="headerlink" title="Master 接收 Slave 的 kBinlogSync 请求"></a>Master 接收 Slave 的 kBinlogSync 请求</h2><p><strong>src&#x2F;pika_repl_server_conn.cc</strong></p>
<p>这里调用 <code>UpdateSyncBinlogStatus</code> 更新一下主节点这边记录的 <code>Binlog</code> 读取点位的信息，同时把新一批的 <code>binlog</code> 信息写到 <code>write_queue</code> 队列中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaReplServerConn::HandleBinlogSyncRequest</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  s = g_pika_rm-&gt;<span class="built_in">UpdateSyncBinlogStatus</span>(slave_node, range_start, range_end);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Update binlog ack failed &quot;</span> &lt;&lt; db_name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; slot_id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    conn-&gt;<span class="built_in">NotifyClose</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_pika_server-&gt;<span class="built_in">SignalAuxiliary</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ConsensusUpdateSlave</code> 更新点位信息，然后和之前一样调用 <code>SyncBinlogToWq</code> 将新的 <code>Binlog</code> 写到 <code>write_queue</code> 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaReplicaManager::UpdateSyncBinlogStatus</span><span class="params">(<span class="type">const</span> RmNode&amp; slave, <span class="type">const</span> LogOffset&amp; offset_start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> LogOffset&amp; offset_end)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_lock <span class="title">l</span><span class="params">(slots_rw_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sync_master_slots_.<span class="built_in">find</span>(slave.<span class="built_in">NodeSlotInfo</span>()) == sync_master_slots_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotFound</span>(slave.<span class="built_in">ToString</span>() + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;SyncMasterSlot&gt; slot = sync_master_slots_[slave.<span class="built_in">NodeSlotInfo</span>()];</span><br><span class="line">  Status s = slot-&gt;<span class="built_in">ConsensusUpdateSlave</span>(slave.<span class="built_in">Ip</span>(), slave.<span class="built_in">Port</span>(), offset_start, offset_end);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  s = slot-&gt;<span class="built_in">SyncBinlogToWq</span>(slave.<span class="built_in">Ip</span>(), slave.<span class="built_in">Port</span>());</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FAQ-3"><a href="#FAQ-3" class="headerlink" title="FAQ"></a>FAQ</h2><ul>
<li><p>这里的 <code>SyncBinlogToWq</code> 为什么不需要对比一下 <code>ack_offset</code> 和 <code>sent_offset</code> 吗</p>
<p>​</p>
</li>
</ul>
<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>UpdateSlave</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ConsensusUpdateSlave</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> LogOffset&amp; end)</span> </span>&#123;</span><br><span class="line">  Status s = coordinator_.<span class="built_in">UpdateSlave</span>(ip, port, start, end);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>Update</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::UpdateSlave</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> LogOffset&amp; end)</span> </span>&#123;</span><br><span class="line">  LogOffset committed_index;</span><br><span class="line">  Status s = sync_pros_.<span class="built_in">Update</span>(ip, port, start, end, &amp;committed_index);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>调用 <code>Update</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncProgress::Update</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">int</span> port, <span class="type">const</span> LogOffset&amp; start, <span class="type">const</span> LogOffset&amp; end,</span></span></span><br><span class="line"><span class="params"><span class="function">                            LogOffset* committed_index)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  LogOffset acked_offset;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// update slave_ptr</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(slave_ptr-&gt;slave_mu)</span></span>;</span><br><span class="line">    Status s = slave_ptr-&gt;<span class="built_in">Update</span>(start, end, &amp;acked_offset);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_slave_node.cc</strong></p>
<p>这里调用 <code>Update</code> 更新滑动窗口 <code>sync_win</code> 的信息，这里可以看到最终更新了 <code>acked_offset</code> 的值，<code>acked_offset</code> 更新后的值就是上次一批 <code>Binlog</code> 请求最后发送的 <code>sent_offset</code> 的值，这样能确保 <code>acked_offset</code> 和 <code>sent_offset</code>的值保持相等，确保数据不丢失</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SlaveNode::Update</span><span class="params">(<span class="type">const</span> LogOffset&amp; start, <span class="type">const</span> LogOffset&amp; end, LogOffset* updated_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (slave_state != kSlaveBinlogSync) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="built_in">ToString</span>() + <span class="string">&quot;state not BinlogSync&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *updated_offset = <span class="built_in">LogOffset</span>();</span><br><span class="line">  <span class="type">bool</span> res = sync_win.<span class="built_in">Update</span>(<span class="built_in">SyncWinItem</span>(start), <span class="built_in">SyncWinItem</span>(end), updated_offset);</span><br><span class="line">  <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;UpdateAckedInfo failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (*updated_offset == <span class="built_in">LogOffset</span>()) &#123;</span><br><span class="line">    <span class="comment">// nothing to update return current acked_offset</span></span><br><span class="line">    *updated_offset = acked_offset;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// update acked_offset</span></span><br><span class="line">  acked_offset = *updated_offset;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_slave_node.cc</strong></p>
<p>这里的 <code>win_</code> 实际上是一个双端队列，里面存的是 <code>SyncWinItem</code> 类型的信息，传入的 <code>start_item</code> 和 <code>end_itme</code> 就是已经被从消费过的 <code>Binlog</code> 偏移量，然后把这些从 <code>win_</code> 中 <code>pop_front</code> 出来，使 <code>win_</code> 中剩下下次需要传递的 <code>Binlog</code> 偏移量的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SyncWindow::Update</span><span class="params">(<span class="type">const</span> SyncWinItem&amp; start_item, <span class="type">const</span> SyncWinItem&amp; end_item, LogOffset* acked_offset)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> start_pos = win_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> end_pos = win_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; win_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (win_[i] == start_item) &#123;</span><br><span class="line">      start_pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (win_[i] == end_item) &#123;</span><br><span class="line">      end_pos = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (start_pos == win_.<span class="built_in">size</span>() || end_pos == win_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Ack offset Start: &quot;</span> &lt;&lt; start_item.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;End: &quot;</span> &lt;&lt; end_item.<span class="built_in">ToString</span>()</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; not found in binlog controller window.&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;window status &quot;</span> &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; <span class="built_in">ToStringStatus</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = start_pos; i &lt;= end_pos; ++i) &#123;</span><br><span class="line">    win_[i].acked_ = <span class="literal">true</span>;</span><br><span class="line">    total_size_ -= win_[i].binlog_size_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!win_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (win_[<span class="number">0</span>].acked_) &#123;</span><br><span class="line">      *acked_offset = win_[<span class="number">0</span>].offset_;</span><br><span class="line">      win_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在增量同步中，Master 先把自己的 Binlog 的偏移量和序列化后的 <code>record</code> 信息发送给 Slave，并记录这个偏移量为 <code>sent_offset</code> ，然后 Slave 端消费完之后回给 Master 一个 <code>ack_start</code> 和 <code>ack_end</code> 去更新 Master 这边的 <code>ack_offset</code> ，只有 <code>sent_offset</code> 和 <code>ack_offset</code> 相同时 Master 才能继续和 Slave 做增量同步</p>
<h2 id="单机-Binlog-生产"><a href="#单机-Binlog-生产" class="headerlink" title="单机 Binlog 生产"></a>单机 Binlog 生产</h2><p><strong>src&#x2F;pika.command.cc</strong></p>
<p>在执行完命令的流程后执行 <code>DoBinlog</code> 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cmd::InternalProcessCommand</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Slot&gt;&amp; slot, <span class="type">const</span> std::shared_ptr&lt;SyncMasterSlot&gt;&amp; sync_slot,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> HintKeys&amp; hint_keys)</span> </span>&#123;</span><br><span class="line">  pstd::<span class="function">lock::MultiRecordLock <span class="title">record_lock</span><span class="params">(slot-&gt;LockMgr())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_write</span>()) &#123;</span><br><span class="line">    record_lock.<span class="built_in">Lock</span>(<span class="built_in">current_key</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> start_us = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    start_us = pstd::<span class="built_in">NowMicros</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DoCommand</span>(slot, hint_keys); <span class="comment">// 执行命令流程</span></span><br><span class="line">  <span class="keyword">if</span> (g_pika_conf-&gt;<span class="built_in">slowlog_slower_than</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    do_duration_ += pstd::<span class="built_in">NowMicros</span>() - start_us;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DoBinlog</span>(sync_slot); <span class="comment">// 这里执行Binlog逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_write</span>()) &#123;</span><br><span class="line">    record_lock.<span class="built_in">Unlock</span>(<span class="built_in">current_key</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika.command.cc</strong></p>
<p>在 <code>DoBinlog</code> 函数中，首先判断当前的命令是不是写命令，只有写命令才需要记录 <code>Binlog</code> 然后获取到当前的 <code>conn</code> 和 <code>response</code>, 然后执行 <code>SyncMasterSlot</code> 的 <code>ConsensusProposeLog</code> 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cmd::DoBinlog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;SyncMasterSlot&gt;&amp; slot)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">res</span>().<span class="built_in">ok</span>() &amp;&amp; <span class="built_in">is_write</span>() &amp;&amp; g_pika_conf-&gt;<span class="built_in">write_binlog</span>()) &#123; <span class="comment">// 判断是不是写命令</span></span><br><span class="line">    std::shared_ptr&lt;net::NetConn&gt; conn_ptr = <span class="built_in">GetConn</span>();</span><br><span class="line">    std::shared_ptr&lt;std::string&gt; resp_ptr = <span class="built_in">GetResp</span>();</span><br><span class="line">    <span class="comment">// Consider that dummy cmd appended by system, both conn and resp are null.</span></span><br><span class="line">    <span class="keyword">if</span> ((!conn_ptr || !resp_ptr) &amp;&amp; (name_ != kCmdDummy)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!conn_ptr) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; slot-&gt;<span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; conn empty.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!resp_ptr) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; slot-&gt;<span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; resp empty.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">res</span>().<span class="built_in">SetRes</span>(CmdRes::kErrOther);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status s =</span><br><span class="line">        slot-&gt;<span class="built_in">ConsensusProposeLog</span>(<span class="built_in">shared_from_this</span>(), std::<span class="built_in">dynamic_pointer_cast</span>&lt;PikaClientConn&gt;(conn_ptr), resp_ptr);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; slot-&gt;<span class="built_in">SyncSlotInfo</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; Writing binlog failed, maybe no space left on device &quot;</span></span><br><span class="line">                   &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      <span class="built_in">res</span>().<span class="built_in">SetRes</span>(CmdRes::kErrOther, s.<span class="built_in">ToString</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>这里的 <code>coordinator_</code> 是 <code>ConsensusCoordinator</code> 类，是 <code>SyncSlaveSlot</code> 类的私有成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::ConsensusProposeLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> coordinator_.<span class="built_in">ProposeLog</span>(cmd_ptr, std::<span class="built_in">move</span>(conn_ptr), std::<span class="built_in">move</span>(resp_ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>在 <code>ProposeLog</code> 中，定义了一个 <code>LogOffset</code> 和 <code>BinlogItem</code> 变量，然后调用 <code>InternalAppendLog</code> 去执行写 <code>Binlog</code>, 同时调用 <code>SignalAuxiliary</code> 去唤醒辅助线程去通知主节点同步 <code>Binlog</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::ProposeLog</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr, std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; keys = cmd_ptr-&gt;<span class="built_in">current_key</span>();</span><br><span class="line">  <span class="comment">// slotkey shouldn&#x27;t add binlog</span></span><br><span class="line">  <span class="keyword">if</span> (cmd_ptr-&gt;<span class="built_in">name</span>() == kCmdNameSAdd &amp;&amp; !keys.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">      (keys[<span class="number">0</span>].<span class="built_in">compare</span>(<span class="number">0</span>, SlotKeyPrefix.<span class="built_in">length</span>(), SlotKeyPrefix) == <span class="number">0</span> || keys[<span class="number">0</span>].<span class="built_in">compare</span>(<span class="number">0</span>, SlotTagPrefix.<span class="built_in">length</span>(), SlotTagPrefix) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LogOffset log_offset;</span><br><span class="line"></span><br><span class="line">  BinlogItem item;</span><br><span class="line">  <span class="comment">// make sure stable log and mem log consistent</span></span><br><span class="line">  Status s = <span class="built_in">InternalAppendLog</span>(item, cmd_ptr, std::<span class="built_in">move</span>(conn_ptr), std::<span class="built_in">move</span>(resp_ptr));</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_pika_server-&gt;<span class="built_in">SignalAuxiliary</span>();</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaServer::SignalAuxiliary</span><span class="params">()</span> </span>&#123; pika_auxiliary_thread_-&gt;cv_.<span class="built_in">notify_one</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>其中在 <code>BinlogItem</code> 类中有 <code>exec_time</code>， <code>term_id</code> ， <code>logic_id</code>， <code>filenum</code>， <code>offset</code>， <code>content</code>， <code>extends</code> 等指标</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinlogItem</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BinlogItem</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">PikaBinlogTransverter</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">exec_time</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">term_id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">logic_id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">filenum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">content</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint32_t</span> exec_time_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> term_id_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> logic_id_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> filenum_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> offset_ = <span class="number">0</span>;</span><br><span class="line">  std::string content_;</span><br><span class="line">  std::vector&lt;std::string&gt; extends_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>这里调用 <code>InternalAppendBinlog</code> 方法写 <code>Binlog</code>, 这里传入的是 <code>cmd_ptr</code> , <code>BinlogItem</code> , <code>LogOffset</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendLog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;PikaClientConn&gt; conn_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               std::shared_ptr&lt;std::string&gt; resp_ptr)</span> </span>&#123;</span><br><span class="line">  LogOffset log_offset;</span><br><span class="line">  Status s = <span class="built_in">InternalAppendBinlog</span>(item, cmd_ptr, &amp;log_offset);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_consensus.cc</strong></p>
<p>这里先把 <code>cmd_ptr</code> 中的命令根据 Redis 协议序列化成 <code>content</code> ，这里的 <code>stable_logger_</code> 是 <code>StableLog</code> 对象，这里调用 <code>Put</code> 函数将 <code>content</code> 的内容写到文件中，然后调用 <code>GetProducerStatus</code> ，然后调用 <code>LogOffset</code>, 更新 offset</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ConsensusCoordinator::InternalAppendBinlog</span><span class="params">(<span class="type">const</span> BinlogItem&amp; item, <span class="type">const</span> std::shared_ptr&lt;Cmd&gt;&amp; cmd_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  LogOffset* log_offset)</span> </span>&#123;</span><br><span class="line">  std::string content = cmd_ptr-&gt;<span class="built_in">ToRedisProtocol</span>();</span><br><span class="line">  Status s = stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">Put</span>(content);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::string db_name = cmd_ptr-&gt;<span class="built_in">db_name</span>().<span class="built_in">empty</span>() ? g_pika_conf-&gt;<span class="built_in">default_db</span>() : cmd_ptr-&gt;<span class="built_in">db_name</span>();</span><br><span class="line">    std::shared_ptr&lt;DB&gt; db = g_pika_server-&gt;<span class="built_in">GetDB</span>(db_name);</span><br><span class="line">    <span class="keyword">if</span> (db) &#123;</span><br><span class="line">      db-&gt;<span class="built_in">SetBinlogIoError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> filenum;</span><br><span class="line">  <span class="type">uint64_t</span> offset;</span><br><span class="line">  stable_logger_-&gt;<span class="built_in">Logger</span>()-&gt;<span class="built_in">GetProducerStatus</span>(&amp;filenum, &amp;offset);</span><br><span class="line">  *log_offset = <span class="built_in">LogOffset</span>(<span class="built_in">BinlogOffset</span>(filenum, offset), <span class="built_in">LogicOffset</span>(item.<span class="built_in">term_id</span>(), item.<span class="built_in">logic_id</span>()));</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>这里 <code>Binlog</code> 重载了 <code>Put </code> 函数，第一个 <code>Put</code> 先初始化 <code>filenum</code>, <code>term_id</code> , <code>offset</code>, <code>logic_id</code> 变量，调用 <code>GetProduceStatus</code> 获取当前 Binlog 中的最新值（filenum，pro_offset，term_id，logic_id)，然后调用 <code>BinlogEncode</code> 组装 <code>Binlog</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: mutex lock should be held</span></span><br><span class="line"><span class="function">Status <span class="title">Binlog::Put</span><span class="params">(<span class="type">const</span> std::string&amp; item)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!opened_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Busy</span>(<span class="string">&quot;Binlog is not open yet&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> filenum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> term = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> logic_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Lock</span>();</span><br><span class="line">  DEFER &#123;</span><br><span class="line">    <span class="built_in">Unlock</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Status s = <span class="built_in">GetProducerStatus</span>(&amp;filenum, &amp;offset, &amp;term, &amp;logic_id);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  logic_id++;</span><br><span class="line">  std::string data = PikaBinlogTransverter::<span class="built_in">BinlogEncode</span>(BinlogType::TypeFirst,</span><br><span class="line">      <span class="built_in">time</span>(<span class="literal">nullptr</span>), term, logic_id, filenum, offset, item, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  s = <span class="built_in">Put</span>(data.<span class="built_in">c_str</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data.<span class="built_in">size</span>()));</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    binlog_io_error_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;pika_binlog_transverter.cc</strong></p>
<p>这里的 <code>BinlogEncode</code> 来组装 <code>Binlog</code> 的信息，返回一个组装好的 binlog</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">PikaBinlogTransverter::BinlogEncode</span><span class="params">(BinlogType type, <span class="type">uint32_t</span> exec_time, <span class="type">uint32_t</span> term_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">uint64_t</span> logic_id, <span class="type">uint32_t</span> filenum, <span class="type">uint64_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">const</span> std::string&amp; content, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; extends)</span> </span>&#123;</span><br><span class="line">  std::string binlog;</span><br><span class="line">  pstd::<span class="built_in">PutFixed16</span>(&amp;binlog, type);</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, exec_time);</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, term_id);</span><br><span class="line">  pstd::<span class="built_in">PutFixed64</span>(&amp;binlog, logic_id);</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, filenum);</span><br><span class="line">  pstd::<span class="built_in">PutFixed64</span>(&amp;binlog, offset);</span><br><span class="line">  <span class="type">uint32_t</span> content_length = content.<span class="built_in">size</span>();</span><br><span class="line">  pstd::<span class="built_in">PutFixed32</span>(&amp;binlog, content_length);</span><br><span class="line">  binlog.<span class="built_in">append</span>(content);</span><br><span class="line">  <span class="keyword">return</span> binlog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>

<p>这个就是 <code>Binlog</code> 这里的组装，一共 34 字节</p>
<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>我们看下第二个 Put 函数里面做了什么操作，这里如果当前文件大于预设定的文件大小，我们会调用 <code>NewWritableFile</code> 函数将新创建一个 <code>Binlog</code> 文件，并将 Binlog 中的 <code>pro_offset</code> 置为 0， <code>pro_num</code> 文件名索引加一，更新，然后调用 <code>Produce</code> 方法，处理 <code>Binlog</code>  逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: mutex lock should be held</span></span><br><span class="line"><span class="function">Status <span class="title">Binlog::Put</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* item, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check to roll log file */</span></span><br><span class="line">  <span class="type">uint64_t</span> filesize = queue_-&gt;<span class="built_in">Filesize</span>();</span><br><span class="line">  <span class="keyword">if</span> (filesize &gt; file_size_) &#123;</span><br><span class="line">    std::unique_ptr&lt;pstd::WritableFile&gt; queue;</span><br><span class="line">    std::string profile = <span class="built_in">NewFileName</span>(filename_, pro_num_ + <span class="number">1</span>);</span><br><span class="line">    s = pstd::<span class="built_in">NewWritableFile</span>(profile, queue);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Binlog: new &quot;</span> &lt;&lt; filename_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    queue_.<span class="built_in">reset</span>();</span><br><span class="line">    queue_ = std::<span class="built_in">move</span>(queue);</span><br><span class="line">    pro_num_++;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard <span class="title">l</span><span class="params">(version_-&gt;rwlock_)</span></span>;</span><br><span class="line">      version_-&gt;pro_offset_ = <span class="number">0</span>;</span><br><span class="line">      version_-&gt;pro_num_ = pro_num_;</span><br><span class="line">      version_-&gt;<span class="built_in">StableSave</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitLogFile</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pro_offset;</span><br><span class="line">  s = <span class="built_in">Produce</span>(pstd::<span class="built_in">Slice</span>(item, len), &amp;pro_offset);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(version_-&gt;rwlock_)</span></span>;</span><br><span class="line">    version_-&gt;pro_offset_ = pro_offset;</span><br><span class="line">    version_-&gt;logic_id_++;</span><br><span class="line">    version_-&gt;<span class="built_in">StableSave</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>在 <code>Produce</code> 函数中，<code>tmp_pro_offset</code> 是当前 <code>Binlog</code> 文件中的偏移量</p>
<p>我们用 <code>left</code> 记录了当前需要写入的一条 <code>Binlog</code> 的字节大小，用 <code>leftover</code> 记录当前 <code>block</code> 还剩下可填充的字节数，如果当前剩余可用的字节数都小于 <code>kHeaderSize(组成Binlog的头部)</code> 的话，则当前的 <code>Block</code> 后续用 <code>\x00</code> 填充，然后新起一个 <code>Block</code>, 然后将 <code>block_offset_</code> 置为 0，表示新的 <code>Block</code> 的偏移量，同时 <code>tmp_pro_offset</code> 也进行更新. <code>avail</code>来记录当前除了 <code>kHeadSize</code> 和 <code>block_offset_(当前block已写进的部分)</code> 之后一个 <code>block</code> 中还能记录的字节数，然后用 <code>left</code> 和 <code>avail</code> 作比较，看是否在当前的 <code>block</code> 装载下，如果 <code>left</code> &lt; <code>avail</code> 说明当前的 <code>block</code>可以装载下这一条 <code>record</code> 记录，我们把 <code>type</code> 置为 <code>kFullType</code> 其余的情况我们就置为其他的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Binlog::Produce</span><span class="params">(<span class="type">const</span> pstd::Slice&amp; item, <span class="type">int</span>* temp_pro_offset)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = item.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = item.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  *temp_pro_offset = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(version_-&gt;pro_offset_);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(kBlockSize) - block_offset_;</span><br><span class="line">    <span class="built_in">assert</span>(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(leftover) &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = queue_-&gt;<span class="built_in">Append</span>(pstd::<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        *temp_pro_offset += leftover;</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length, temp_pro_offset);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>这里就是把需要写入的东西放到 <code>queue_</code> 里面，然后下次打开 <code>Binlog</code> 文件的时候就会把新加的部分更新上去，至此一条 <code>Record</code> 记录就落盘了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Binlog::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr, <span class="type">size_t</span> n, <span class="type">int</span>* temp_pro_offset)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="built_in">assert</span>(n &lt;= <span class="number">0xffffff</span>);</span><br><span class="line">  <span class="built_in">assert</span>(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> now;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">nullptr</span>);</span><br><span class="line">  now = tv.tv_sec;</span><br><span class="line">  buf[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((n &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buf[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(now &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((now &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((now &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((now &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">  buf[<span class="number">7</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  s = queue_-&gt;<span class="built_in">Append</span>(pstd::<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = queue_-&gt;<span class="built_in">Append</span>(pstd::<span class="built_in">Slice</span>(ptr, n));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = queue_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(kHeaderSize + n);</span><br><span class="line"></span><br><span class="line">  *temp_pro_offset += <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(kHeaderSize + n);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| length | time | Type | type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|   <span class="number">3B</span>   |  <span class="number">4B</span>  |  <span class="number">1B</span>  |  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>

<p>所以最终的一条 <code>record</code> 就是以这样的形式记录的</p>
<p><strong>src&#x2F;pika_binlog.cc</strong></p>
<p>通过以上的代码，大家发现好像这个 Binlog 数据没有落盘，只是在 <code>queue_</code> (内存)中，这里的 <code>AppendWritableFile</code> 函数就是利用 <code>mmap</code> 进行落盘操作，它在 Binlog 的构造函数中调用，操作系统会定期的将内存中的数据映射到磁盘上来实现落盘</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Binlog::<span class="built_in">Binlog</span>(std::string  binlog_path, <span class="type">const</span> <span class="type">int</span> file_size)</span><br><span class="line">    : <span class="built_in">opened_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">binlog_path_</span>(std::<span class="built_in">move</span>(binlog_path)),</span><br><span class="line">      <span class="built_in">file_size_</span>(file_size),</span><br><span class="line">      <span class="built_in">binlog_io_error_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="comment">// To intergrate with old version, we don&#x27;t set mmap file size to 100M;</span></span><br><span class="line">  <span class="comment">// pstd::SetMmapBoundSize(file_size);</span></span><br><span class="line">  <span class="comment">// pstd::kMmapBoundSize = 1024 * 1024 * 100;</span></span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  pstd::<span class="built_in">CreateDir</span>(binlog_path_);</span><br><span class="line"></span><br><span class="line">  filename_ = binlog_path_ + kBinlogPrefix;</span><br><span class="line">  <span class="type">const</span> std::string manifest = binlog_path_ + kManifest;</span><br><span class="line">  std::string profile;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pstd::<span class="built_in">FileExists</span>(manifest)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: Manifest file not exist, we create a new one.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    profile = <span class="built_in">NewFileName</span>(filename_, pro_num_);</span><br><span class="line">    s = pstd::<span class="built_in">NewWritableFile</span>(profile, queue_);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: new &quot;</span> &lt;&lt; filename_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;pstd::RWFile&gt; tmp_file;</span><br><span class="line">    s = pstd::<span class="built_in">NewRWFile</span>(manifest, tmp_file);</span><br><span class="line">    versionfile_.<span class="built_in">reset</span>(tmp_file.<span class="built_in">release</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: new versionfile error &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version_ = std::<span class="built_in">make_unique</span>&lt;Version&gt;(versionfile_);</span><br><span class="line">    version_-&gt;<span class="built_in">StableSave</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: Find the exist file.&quot;</span>;</span><br><span class="line">    std::unique_ptr&lt;pstd::RWFile&gt; tmp_file;</span><br><span class="line">    s = pstd::<span class="built_in">NewRWFile</span>(manifest, tmp_file);</span><br><span class="line">    versionfile_.<span class="built_in">reset</span>(tmp_file.<span class="built_in">release</span>());</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      version_ = std::<span class="built_in">make_unique</span>&lt;Version&gt;(versionfile_);</span><br><span class="line">      version_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">      pro_num_ = version_-&gt;pro_num_;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Debug</span></span><br><span class="line">      <span class="comment">// version_-&gt;debug();</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: open versionfile error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    profile = <span class="built_in">NewFileName</span>(filename_, pro_num_);</span><br><span class="line">    <span class="built_in">DLOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: open profile &quot;</span> &lt;&lt; profile;</span><br><span class="line">    s = pstd::<span class="built_in">AppendWritableFile</span>(profile, queue_, version_-&gt;pro_offset_); <span class="comment">// 落盘</span></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Binlog: Open file &quot;</span> &lt;&lt; profile &lt;&lt; <span class="string">&quot; error &quot;</span> &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> filesize = queue_-&gt;<span class="built_in">Filesize</span>();</span><br><span class="line">    <span class="built_in">DLOG</span>(INFO) &lt;&lt; <span class="string">&quot;Binlog: filesize is &quot;</span> &lt;&lt; filesize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitLogFile</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>我们所说的 Binlog 其实就是 Pika 中存在的 <code>write2file</code> 文件，一个 <code>write2file</code> 文件由多个 <code>block</code> 组成，每个 <code>block</code> 大小固定为 <code>64KB</code>, 在 <code>block</code> 中记录的就是一条条 <code>record</code> ，一个 <code>record</code> 就是一条序列化后的 <code>redis</code> 命令(也可以是多条，当然也有一个 Binlog 用多个 record 记录)，每个 <code>write2file</code> 文件都有一定的大小，如果当前的 <code>block</code> 剩余字节量还不如填充一条 <code>record </code>的头部，则当前 <code>block</code> 当前剩余部分的字节用 <code>\x00</code>填充，然后新起一个 <code>block</code> 来装载 <code>record</code>。</p>
<h3 id="FAQ-4"><a href="#FAQ-4" class="headerlink" title="FAQ"></a>FAQ</h3><ul>
<li><p>代码中的 Binlog 头部是 kHeadseSize 是 1+ 3 + 4 也就是 8 字节，但是在 <code>pika_binlog_transverter.h</code> 中对 Binlog 头部的描述是 <code>Type(2B)</code> + <code>exec_time(4B)</code> + <code>term_id(4B)</code> + <code>logic_id(8B)</code> + <code>filenum(4B)</code> + <code>offset(8B)</code> + <code>content_len(4B)</code> 算下来是 34 字节，为什么会不一样？</p>
<p><strong>真正头部的组装是 1(Type) + 3(length) + 4(time)</strong> <strong>后面再加 34 字节</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| length | time | Type | type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|   <span class="number">3B</span>   |  <span class="number">4B</span>  |  <span class="number">1B</span>  |  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>​</p>
</li>
<li><p>如果是调用 <code>AppendWritableFile</code> 每次进行 Binlog 数据落盘的话，为什么放在 <code>Binlog</code> 的构造函数中</p>
<p><strong>操作系统会定期把内存中的值映射写到磁盘上</strong></p>
<p>​</p>
</li>
<li><p>如果存在一种情况，当前 <code>Block</code> 剩余部分能存下一条 <code>record</code> 的头部和内容的一部分，那么当前这个 <code>block</code> 应该会存完整个 <code>record</code> 而不是新起一个 <code>Block</code> 存取吗？</p>
<p><strong>会新起一个 Block 存取，如果新起前已经到了文件设置的最大的 Block 数量依然会新起，所以 write2file 文件的大小不是固定的，但是 Block 的大小一定是固定的</strong></p>
<p>​</p>
</li>
<li><p>主节点写 Binlog 的时候怎么向辅助线程发送信号的？</p>
<p><strong>使用信号量</strong>，<code>pika_auxiliary_thread_-&gt;cv_.notify_one();</code></p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>在一条 <code>Binlog</code> 记录中，有字段重复的组装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| length | time | Type | type | exec_time | term_id | logic_id | filenum | offset | content_len | content | </span><br><span class="line">|   <span class="number">3B</span>   |  <span class="number">4B</span>  |  <span class="number">1B</span>  |  <span class="number">2B</span>  |     <span class="number">4B</span>    |    <span class="number">4B</span>   |     <span class="number">8B</span>   |    <span class="number">4B</span>   |   <span class="number">8B</span>   |      <span class="number">4B</span>     |         |</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code> 字段一直都是 <code>TypeFirst</code> 这个默认值</p>
<p>​</p>
</li>
</ol>
<h2 id="辅助线程驱动-BinlogSync"><a href="#辅助线程驱动-BinlogSync" class="headerlink" title="辅助线程驱动 BinlogSync"></a>辅助线程驱动 BinlogSync</h2><p><strong>src&#x2F;pika_auxiliary_thread.cc</strong></p>
<p>由于从节点是 <code>BinlogSync</code> 的发起者，但是一段时间没有数据同步之后，从感知不到主上新的数据写入，从而不能再主动再次发起 <code>BinlogSync</code> 流程，这时候需要辅助线程来调用 <code>TriggerSendBinlogSync</code>，驱动 <code>BinlogSync</code> 流程。<code>TriggerSendBinlogSync</code> 的主要逻辑就是将新写入的增量放入 <code>write_queues</code>，再发送给从节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">PikaAuxiliaryThread::ThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">should_stop</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pika_server-&gt;<span class="built_in">ShouldMetaSync</span>()) &#123;</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">SendMetaSyncRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g_pika_server-&gt;<span class="built_in">MetaSyncDone</span>()) &#123;</span><br><span class="line">      g_pika_rm-&gt;<span class="built_in">RunSyncSlaveSlotStateMachine</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pstd::Status s = g_pika_rm-&gt;<span class="built_in">CheckSyncTimeout</span>(pstd::<span class="built_in">NowMicros</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_pika_server-&gt;<span class="built_in">CheckLeaderProtectedMode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(whoiami) timeout</span></span><br><span class="line">    s = g_pika_server-&gt;<span class="built_in">TriggerSendBinlogSync</span>(); <span class="comment">// 将Binlog写入发送队列</span></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send to peer</span></span><br><span class="line">    <span class="type">int</span> res = g_pika_server-&gt;<span class="built_in">SendToPeer</span>(); <span class="comment">// 将发送队列的Binlog发给slave</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// sleep 100 ms</span></span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu_)</span></span>;</span><br><span class="line">      cv_.<span class="built_in">wait_for</span>(lock, <span class="number">100</span>ms);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// LOG_EVERY_N(INFO, 1000) &lt;&lt; &quot;Consume binlog number &quot; &lt;&lt; res;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>src&#x2F;pika_server.cc</strong></p>
<p>调用 <code>WakeUpBinlogSync</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaServer::TriggerSendBinlogSync</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g_pika_rm-&gt;<span class="built_in">WakeUpBinlogSync</span>(); &#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>WakeUpSlaveBinlogSync</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaReplicaManager::WakeUpBinlogSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_lock <span class="title">l</span><span class="params">(slots_rw_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : sync_master_slots_) &#123;</span><br><span class="line">    std::shared_ptr&lt;SyncMasterSlot&gt; slot = iter.second;</span><br><span class="line">    Status s = slot-&gt;<span class="built_in">WakeUpSlaveBinlogSync</span>();</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_rm.cc</strong></p>
<p>调用 <code>ReadBinlogFileWq</code> , 这里的步骤和上面的类似，把 <code>Binlog</code> 写到 <code>write_queue</code>中，这里会判断 <code>sent_offset</code> 和 <code>acked_offset</code> 是否保持一致，如果相等说明之前的主动部分的增量同步的数据已经同步完毕，所以 <code>ReadBinlogFileToWq</code> 调用之前主从的增量数据肯定是已经同步了的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SyncMasterSlot::WakeUpSlaveBinlogSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unordered_map&lt;std::string, std::shared_ptr&lt;SlaveNode&gt;&gt; slaves = <span class="built_in">GetAllSlaveNodes</span>();</span><br><span class="line">  std::vector&lt;std::shared_ptr&lt;SlaveNode&gt;&gt; to_del;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; slave_iter : slaves) &#123;</span><br><span class="line">    std::shared_ptr&lt;SlaveNode&gt; slave_ptr = slave_iter.second;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">l</span><span class="params">(slave_ptr-&gt;slave_mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (slave_ptr-&gt;sent_offset == slave_ptr-&gt;acked_offset) &#123;</span><br><span class="line">      Status s = <span class="built_in">ReadBinlogFileToWq</span>(slave_ptr);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        to_del.<span class="built_in">push_back</span>(slave_ptr);</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;WakeUpSlaveBinlogSync falied, Delete from RM, slave: &quot;</span> &lt;&lt; slave_ptr-&gt;<span class="built_in">ToStringStatus</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt; s.<span class="built_in">ToString</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; to_del_slave : to_del) &#123;</span><br><span class="line">    <span class="built_in">RemoveSlaveNode</span>(to_del_slave-&gt;<span class="built_in">Ip</span>(), to_del_slave-&gt;<span class="built_in">Port</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Binlog-的过期策略"><a href="#Binlog-的过期策略" class="headerlink" title="Binlog 的过期策略"></a>Binlog 的过期策略</h2><p><strong>src&#x2F;pika_server.cc</strong></p>
<p>在 Pika 的定时器任务中，有个 <code>AutoPurge</code> 会对 <code>Binlog</code> 做定期的清理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaServer::DoTimingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Maybe schedule compactrange</span></span><br><span class="line">  <span class="built_in">AutoCompactRange</span>();</span><br><span class="line">  <span class="comment">// Purge log</span></span><br><span class="line">  <span class="built_in">AutoPurge</span>();</span><br><span class="line">  <span class="comment">// Delete expired dump</span></span><br><span class="line">  <span class="built_in">AutoDeleteExpiredDump</span>();</span><br><span class="line">  <span class="comment">// Cheek Rsync Status</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> temporarily disable rsync</span></span><br><span class="line">  <span class="comment">// AutoKeepAliveRSync();</span></span><br><span class="line">  <span class="comment">// Reset server qps</span></span><br><span class="line">  <span class="built_in">ResetLastSecQuerynum</span>();</span><br><span class="line">  <span class="comment">// Auto update network instantaneous metric</span></span><br><span class="line">  <span class="built_in">AutoUpdateNetworkMetric</span>();</span><br><span class="line">  <span class="built_in">ProcessCronTask</span>();</span><br><span class="line">  <span class="built_in">UpdateCacheInfo</span>();</span><br><span class="line">  <span class="comment">// Print the queue status periodically</span></span><br><span class="line">  <span class="built_in">PrintThreadPoolQueueStatus</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PikaServer::AutoPurge</span><span class="params">()</span> </span>&#123; <span class="built_in">DoSameThingEverySlot</span>(TaskType::kPurgeLog); &#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_server.cc</strong></p>
<p>我们会调用 <code>PurgeStableLogs</code> 做 <code>Binlog</code> 删除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PikaServer::DoSameThingEverySlot</span><span class="params">(<span class="type">const</span> TaskType&amp; type)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_lock <span class="title">rwl</span><span class="params">(dbs_rw_)</span></span>;</span><br><span class="line">  std::shared_ptr&lt;SyncSlaveSlot&gt; slave_slot = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; db_item : dbs_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; slot_item : db_item.second-&gt;slots_) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TaskType::kResetReplState: &#123;</span><br><span class="line">          slave_slot =</span><br><span class="line">              g_pika_rm-&gt;<span class="built_in">GetSyncSlaveSlotByName</span>(<span class="built_in">SlotInfo</span>(db_item.second-&gt;<span class="built_in">GetDBName</span>(), slot_item.second-&gt;<span class="built_in">GetSlotID</span>()));</span><br><span class="line">          <span class="keyword">if</span> (!slave_slot) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slave Slot: &quot;</span> &lt;&lt; db_item.second-&gt;<span class="built_in">GetDBName</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; slot_item.second-&gt;<span class="built_in">GetSlotID</span>()</span><br><span class="line">                         &lt;&lt; <span class="string">&quot; Not Found&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          slave_slot-&gt;<span class="built_in">SetReplState</span>(ReplState::kNoConnect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TaskType::kPurgeLog: &#123;</span><br><span class="line">          std::shared_ptr&lt;SyncMasterSlot&gt; slot =</span><br><span class="line">              g_pika_rm-&gt;<span class="built_in">GetSyncMasterSlotByName</span>(<span class="built_in">SlotInfo</span>(db_item.second-&gt;<span class="built_in">GetDBName</span>(), slot_item.second-&gt;<span class="built_in">GetSlotID</span>()));</span><br><span class="line">          <span class="keyword">if</span> (!slot) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Slot: &quot;</span> &lt;&lt; db_item.second-&gt;<span class="built_in">GetDBName</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; slot_item.second-&gt;<span class="built_in">GetSlotID</span>()</span><br><span class="line">                         &lt;&lt; <span class="string">&quot; Not Found.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          slot-&gt;<span class="built_in">StableLogger</span>()-&gt;<span class="built_in">PurgeStableLogs</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TaskType::kCompactAll:</span><br><span class="line">          slot_item.second-&gt;<span class="built_in">Compact</span>(storage::kAll);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_stable_log.cc</strong></p>
<p>这里可以看到清理 <code>DoPurgeStableLogs</code> 是异步线程做处理，执行的时候调用 <code>DoPurgeStableLogs</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StableLog::PurgeStableLogs</span><span class="params">(<span class="type">uint32_t</span> to, <span class="type">bool</span> manual)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Only one thread can go through</span></span><br><span class="line">  <span class="type">bool</span> expect = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!purging_.<span class="built_in">compare_exchange_strong</span>(expect, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;purge process already exist&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> arg = <span class="keyword">new</span> <span class="built_in">PurgeStableLogArg</span>();</span><br><span class="line">  arg-&gt;to = to;</span><br><span class="line">  arg-&gt;manual = manual;</span><br><span class="line">  arg-&gt;logger = <span class="built_in">shared_from_this</span>();</span><br><span class="line">  g_pika_server-&gt;<span class="built_in">PurgelogsTaskSchedule</span>(&amp;DoPurgeStableLogs, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(arg));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_stable_log.cc</strong></p>
<p>调用 <code>PurgeFiles</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StableLog::DoPurgeStableLogs</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;PurgeStableLogArg&gt; <span class="title">purge_arg</span><span class="params">(<span class="keyword">static_cast</span>&lt;PurgeStableLogArg*&gt;(arg))</span></span>;</span><br><span class="line">  purge_arg-&gt;logger-&gt;<span class="built_in">PurgeFiles</span>(purge_arg-&gt;to, purge_arg-&gt;manual);</span><br><span class="line">  purge_arg-&gt;logger-&gt;<span class="built_in">ClearPurge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>src&#x2F;pika_stable_log.cc</strong></p>
<p>这里我们先用一个 <code>map</code> 的 <code>binlogs</code> 去获取当前目录下所有的 <code>Binlog</code> 文件名，然后与配置文件中规定的最大 <code>Binlog</code> 数量进行比对（最大是10），然后从最老（就是 <code>filenum</code> 最小的）的 <code>Binlog</code> 文件开始删除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StableLog::PurgeFiles</span><span class="params">(<span class="type">uint32_t</span> to, <span class="type">bool</span> manual)</span> </span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">uint32_t</span>, std::string&gt; binlogs;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">GetBinlogFiles</span>(&amp;binlogs)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; log_path_ &lt;&lt; <span class="string">&quot; Could not get binlog files!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> delete_num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> file_stat;</span><br><span class="line">  <span class="keyword">auto</span> remain_expire_num = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(binlogs.<span class="built_in">size</span>() - g_pika_conf-&gt;<span class="built_in">expire_logs_nums</span>());</span><br><span class="line">  std::shared_ptr&lt;SyncMasterSlot&gt; master_slot = <span class="literal">nullptr</span>;</span><br><span class="line">  std::map&lt;<span class="type">uint32_t</span>, std::string&gt;::iterator it;</span><br><span class="line">  <span class="keyword">for</span> (it = binlogs.<span class="built_in">begin</span>(); it != binlogs.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((manual &amp;&amp; it-&gt;first &lt;= to)           <span class="comment">// Manual purgelogsto</span></span><br><span class="line">        || (remain_expire_num &gt; <span class="number">0</span>)            <span class="comment">// Expire num trigger</span></span><br><span class="line">        || (binlogs.<span class="built_in">size</span>() - delete_num &gt; <span class="number">10</span>  <span class="comment">// At lease remain 10 files</span></span><br><span class="line">            &amp;&amp; <span class="built_in">stat</span>(((log_path_ + it-&gt;second)).<span class="built_in">c_str</span>(), &amp;file_stat) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            file_stat.st_mtime &lt; <span class="built_in">time</span>(<span class="literal">nullptr</span>) - g_pika_conf-&gt;<span class="built_in">expire_logs_days</span>() * <span class="number">24</span> * <span class="number">3600</span>)) &#123;  <span class="comment">// Expire time trigger</span></span><br><span class="line">      <span class="comment">// We check this every time to avoid lock when we do file deletion</span></span><br><span class="line">      master_slot = g_pika_rm-&gt;<span class="built_in">GetSyncMasterSlotByName</span>(<span class="built_in">SlotInfo</span>(db_name_, slot_id_));</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (!master_slot-&gt;<span class="built_in">BinlogCloudPurge</span>(it-&gt;first)) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; log_path_ &lt;&lt; <span class="string">&quot; Could not purge &quot;</span> &lt;&lt; (it-&gt;first) &lt;&lt; <span class="string">&quot;, since it is already be used&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Do delete</span></span><br><span class="line">      <span class="keyword">if</span> (pstd::<span class="built_in">DeleteFile</span>(log_path_ + it-&gt;second)) &#123;</span><br><span class="line">        ++delete_num;</span><br><span class="line">        --remain_expire_num;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; log_path_ &lt;&lt; <span class="string">&quot; Purge log file : &quot;</span> &lt;&lt; (it-&gt;second) &lt;&lt; <span class="string">&quot; failed! error: delete file failed&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Break when face the first one not satisfied</span></span><br><span class="line">      <span class="comment">// Since the binlogs is order by the file index</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/" data-id="clrsl0ixd0019h9rf7usl8l5d" data-title="Pika的增量同步源码剖析" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Blog/" rel="tag">Blog</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/01/09/Pika%E7%9A%84%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Pika的全量同步源码剖析
        
      </div>
    </a>
  
  
    <a href="/2023/12/05/Floyd%E6%97%A0%E6%95%88%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%96%B9%E6%A1%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Floyd无效数据清理方案</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blog/" rel="tag">Blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Blog/" style="font-size: 10px;">Blog</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/15/C++%E9%94%81%E6%9C%BA%E5%88%B6/">C++锁机制</a>
          </li>
        
          <li>
            <a href="/2024/01/09/Pika%E7%9A%84%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5/">Pika的全量同步源码剖析</a>
          </li>
        
          <li>
            <a href="/2024/01/04/Pika%E7%9A%84%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5/">Pika的增量同步源码剖析</a>
          </li>
        
          <li>
            <a href="/2023/12/05/Floyd%E6%97%A0%E6%95%88%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%96%B9%E6%A1%88/">Floyd无效数据清理方案</a>
          </li>
        
          <li>
            <a href="/2023/12/04/Pika%E5%BF%AB%E6%85%A2%E5%91%BD%E4%BB%A4%E5%88%86%E7%A6%BB%E6%96%B9%E6%A1%88/">Pika快慢命令分离方案</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>