<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Redis命令 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="STRING命令 APPEND">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis命令">
<meta property="og:url" content="http://example.com/2023/07/12/Redis%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="STRING命令 APPEND">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-12T08:13:08.064Z">
<meta property="article:modified_time" content="2023-07-12T13:03:38.329Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Redis命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/12/Redis%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2023-07-12T08:13:08.064Z" itemprop="datePublished">2023-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Redis命令
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="STRING命令"><a href="#STRING命令" class="headerlink" title="STRING命令"></a>STRING命令</h2><ul>
<li><p>APPEND<span id="more"></span></p>
<p>命令介绍：如果 <code>key</code> 已经存在，并且值为字符串，那么这个命令会把 <code>value</code> 追加到原来值（value）的结尾。 如果 <code>key</code> 不存在，那么它将首先创建一个空字符串的<code>key</code>，再执行追加操作，这种情况 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/ommands/append.html">APPEND</a> 将类似于 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/ommands/set.html">SET</a> 操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS mykey</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; APPEND mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">redis&gt; APPEND mykey <span class="string">&quot; World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello World&quot;</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>BITCOUNT</p>
<p>命令介绍：统计字符串被设置为1的bit数.</p>
<p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</p>
<p>start 和 end 参数的设置和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/getrange.html">GETRANGE</a> 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。</p>
<p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;foobar&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITCOUNT mykey</span><br><span class="line">(<span class="built_in">integer</span>) 26</span><br><span class="line">redis&gt; BITCOUNT mykey 0 0</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis&gt; BITCOUNT mykey 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BITFIELD</p>
<p>命令介绍：本命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。</p>
<p><code>BITFIELD</code>命令能操作多字节位域，它会执行一系列操作，并返回一个响应数组，在参数列表中每个响应数组匹配相应的操作。</p>
<p>例如，下面的命令是对一个8位有符号整数偏移100位自增1，并获取4位无符号整数的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>BITOP</p>
<p>命令介绍：对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p>
<p><code>BITOP</code> 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数：</p>
<ul>
<li><code>BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN</code> ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li>
<li><code>BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN</code>，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li>
<li><code>BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN</code>，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li>
<li><code>BITOP NOT destkey srckey</code>，对给定 key 求逻辑非，并将结果保存到 destkey 。</li>
</ul>
<p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p>
<p>执行结果将始终保持到<code>destkey</code>里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;foobar&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SET key2 <span class="string">&quot;abcdef&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITOP AND dest key1 key2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">redis&gt; GET dest</span><br><span class="line"><span class="string">&quot;`bc`ab&quot;</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BITOPS</p>
<p>命令介绍：返回字符串里面第一个被设置为1或者0的bit位。</p>
<p>返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。</p>
<p><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/getbit.html">GETBIT</a> 和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/setbit.html">SETBIT</a> 相似的也是操作字节位的命令。</p>
<p>默认情况下整个字符串都会被检索一次，只有在指定start和end参数(指定start和end位是可行的)，该范围被解释为一个字节的范围，而不是一系列的位。所以<code>start=0</code> 并且 <code>end=2</code>是指前三个字节范围内查找。</p>
<p>注意，返回的位的位置始终是从0开始的，即使使用了start来指定了一个开始字节也是这样。</p>
<p>和<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/getrange.html">GETRANGE</a>命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个字节，-2是倒数第二个，等等。</p>
<p>不存在的key将会被当做空字符串来处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;\xff\xf0\x00&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITPOS mykey 0 <span class="comment"># 查找字符串里面bit值为0的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">redis&gt; SET mykey <span class="string">&quot;\x00\xff\xf0&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITPOS mykey 1 0 <span class="comment"># 查找字符串里面bit值为1从第0个字节开始的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">redis&gt; BITPOS mykey 1 2 <span class="comment"># 查找字符串里面bit值为1从第2个字节(12)开始的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br><span class="line">redis&gt; <span class="built_in">set</span> mykey <span class="string">&quot;\x00\x00\x00&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITPOS mykey 1 <span class="comment"># 查找字符串里面bit值为1的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DECR</p>
<p>命令介绍：对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;10&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; DECR mykey</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">redis&gt; SET mykey <span class="string">&quot;234293482390480948029348230948&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; DECR mykey</span><br><span class="line">ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>


</li>
<li><p>DECRBY</p>
<p>命令介绍：将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;10&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; DECRBY mykey 5</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>

</li>
<li><p>GET</p>
<p>命令介绍：返回<code>key</code>的<code>value</code>。如果key不存在，返回特殊值<code>nil</code>。如果<code>key</code>的<code>value</code>不是string，就返回错误，因为<code>GET</code>只处理string类型的<code>values</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET nonexisting</span><br><span class="line">(nil)</span><br><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>

</li>
<li><p>GETBIT</p>
<p>命令介绍：返回key对应的string在offset处的bit值 当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间。当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。到内存分配</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT mykey 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GETBIT mykey 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GETBIT mykey 7</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; GETBIT mykey 100</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GETRANGE</p>
<p>命令介绍：<strong>警告</strong>：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。</p>
<p>这个函数处理超出范围的请求时，都把结果限制在string内。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;This is a string&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GETRANGE mykey 0 3</span><br><span class="line"><span class="string">&quot;This&quot;</span></span><br><span class="line">redis&gt; GETRANGE mykey -3 -1</span><br><span class="line"><span class="string">&quot;ing&quot;</span></span><br><span class="line">redis&gt; GETRANGE mykey 0 -1</span><br><span class="line"><span class="string">&quot;This is a string&quot;</span></span><br><span class="line">redis&gt; GETRANGE mykey 10 100</span><br><span class="line"><span class="string">&quot;string&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GETSET</p>
<p>命令介绍：自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INCR mycounter</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; GETSET mycounter <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">redis&gt; GET mycounter</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>INCR</p>
<p>命令介绍：存储在指定<code>key</code>的数值执行原子的加1操作。</p>
<p>如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为<code>0</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;10&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; INCR mykey</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>INCRBY</p>
<p>命令介绍：将key对应的数字加decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;10&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; INCRBY mykey 5</span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>INCRBYFLOAT</p>
<p>命令介绍：通过指定浮点数<code>key</code>来增长浮点数(存放于string中)的值. 当键不存在时,先将其值设为0再操作.下面任一情况都会返回错误:</p>
<ul>
<li>key 包含非法值(不是一个string).</li>
<li>当前的key或者相加后的值不能解析为一个双精度的浮点值.(超出精度范围了)</li>
</ul>
<p>如果操作命令成功, 相加后的值将替换原值存储在对应的键值上, 并以string的类型返回. string中已存的值或者相加参数可以任意选用指数符号,但相加计算的结果会以科学计数法的格式存储. 无论各计算的内部精度如何, 输出精度都固定为小数点后17位.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey 10.50</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCRBYFLOAT mykey 0.1</span><br><span class="line"><span class="string">&quot;10.6&quot;</span></span><br><span class="line">redis&gt; SET mykey 5.0e3</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCRBYFLOAT mykey 2.0e2</span><br><span class="line"><span class="string">&quot;5200&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>MGET</p>
<p>命令介绍：返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值<code>nil</code>。正因为此，这个操作从来不会失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SET key2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; MGET key1 key2 nonexisting</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line">3) (nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>MSET</p>
<p>命令介绍：对应给定的keys到他们相应的values上。<code>MSET</code>会用新的value替换已经存在的value，就像普通的<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/set.html">SET</a>命令一样。如果你不想覆盖已经存在的values，请参看命令<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/msetnx.html">MSETNX</a>。</p>
<p><code>MSET</code>是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET key1 <span class="string">&quot;Hello&quot;</span> key2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET key1</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; GET key2</span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>MSETNX</p>
<p>命令介绍：对应给定的keys到他们相应的values上。只要有一个key已经存在，<code>MSETNX</code>一个操作都不会执行。 由于这种特性，<code>MSETNX</code>可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。</p>
<p><code>MSETNX</code>是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX key1 <span class="string">&quot;Hello&quot;</span> key2 <span class="string">&quot;there&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; MSETNX key2 <span class="string">&quot;there&quot;</span> key3 <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; MGET key1 key2 key3</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;there&quot;</span></span><br><span class="line">3) (nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>PSETEX</p>
<p>命令介绍：<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/psetex.html">PSETEX</a>和<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/setex.html">SETEX</a>一样，唯一的区别是到期时间以毫秒为单位,而不是秒</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PSETEX mykey 1000 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; PTTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 999</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SET</p>
<p>命令介绍：将键<code>key</code>设定为指定的“字符串”值。</p>
<p>如果 key 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。</p>
<p>当<code>set</code>命令执行成功之后，之前设置的过期时间都将失效</p>
<p>从2.6.12版本开始，redis为<code>SET</code>命令增加了一系列选项:</p>
<ul>
<li><code>EX</code> <strong>seconds</strong> – Set the specified expire time, in seconds.</li>
<li><code>PX</code> <strong>milliseconds</strong> – Set the specified expire time, in milliseconds.</li>
<li><code>NX</code> – Only set the key if it does not already exist.</li>
<li><code>XX</code> – Only set the key if it already exist.</li>
<li><code>EX</code> <strong>seconds</strong> – 设置键key的过期时间，单位时秒</li>
<li><code>PX</code> <strong>milliseconds</strong> – 设置键key的过期时间，单位时毫秒</li>
<li><code>NX</code> – 只有键key不存在的时候才会设置key的值</li>
<li><code>XX</code> – 只有键key存在的时候才会设置key的值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SETBIT</p>
<p>命令介绍：设置或者清空key的value(字符串)在offset处的bit值。</p>
<p>那个位置的bit要么被设置，要么被清空，这个由value（只能是0或者1）来决定。当key不存在的时候，就创建一个新的字符串value。要确保这个字符串大到在offset处有bit值。参数offset需要大于等于0，并且小于232(限制bitmap大小为512)。当key对应的字符串增大的时候，新增的部分bit值都是设置为0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT mykey 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; SETBIT mykey 7 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;\x00&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SETEX</p>
<p>命令介绍：设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETEX mykey 10 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SETNX</p>
<p>命令介绍：将<code>key</code>设置值为<code>value</code>，如果<code>key</code>不存在，这种情况下等同<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/set.html">SET</a>命令。 当<code>key</code>存在时，什么也不做。<code>SETNX</code>是”<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists”的简写</p>
<p><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/protocol.html#integer-reply">Integer reply</a>, 特定值:</p>
<ul>
<li><code>1</code> 如果key被设置了</li>
<li><code>0</code> 如果key没有被设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETNX mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SETNX mykey <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SETRANGE</p>
<p>命令介绍：这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SETRANGE key1 6 <span class="string">&quot;Redis&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">redis&gt; GET key1</span><br><span class="line"><span class="string">&quot;Hello Redis&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>STRLEN</p>
<p>命令介绍：返回key的string类型value的长度。如果key对应的非string类型，就返回错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; STRLEN mykey</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">redis&gt; STRLEN nonexisting</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HASH命令"><a href="#HASH命令" class="headerlink" title="HASH命令"></a>HASH命令</h2><ul>
<li><p>HDEL</p>
<p>命令介绍：从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。</p>
<p>如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HDEL myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HDEL myhash field2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HEXISTS</p>
<p>命令介绍：返回hash里面field是否存在</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HEXISTS myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HEXISTS myhash field2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HGET</p>
<p>命令介绍：返回 key 指定的哈希集中该字段所关联的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;foo&quot;</span></span><br><span class="line">redis&gt; HGET myhash field2</span><br><span class="line">(nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HGETALL</p>
<p>命令介绍：返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HSET myhash field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HGETALL myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HINCRBY</p>
<p>命令介绍：增加 <code>key</code> 指定的哈希集中指定字段的数值。如果 <code>key</code> 不存在，会创建一个新的哈希集并与 <code>key</code>关联。如果字段不存在，则字段的值在该操作执行前被设置为 0</p>
<p><code>HINCRBY</code> 支持的值的范围限定在 64位 有符号整数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field 5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HINCRBY myhash field 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">redis&gt; HINCRBY myhash field -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">redis&gt; HINCRBY myhash field -10</span><br><span class="line">(<span class="built_in">integer</span>) -5</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HINCRBYFLOAT</p>
<p>命令介绍：为指定<code>key</code>的hash的<code>field</code>字段值执行float类型的<code>increment</code>加。如果<code>field</code>不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误：</p>
<ul>
<li><code>field</code>的值包含的类型错误(不是字符串)。</li>
<li>当前<code>field</code>或者<code>increment</code>不能解析为一个float类型。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET mykey field 10.50</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 0.1</span><br><span class="line"><span class="string">&quot;10.6&quot;</span></span><br><span class="line">redis&gt; HSET mykey field 5.0e3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 2.0e2</span><br><span class="line"><span class="string">&quot;5200&quot;</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HKEYS</p>
<p>命令介绍：返回 key 指定的哈希集中所有字段的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HSET myhash field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HKEYS myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;field2&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HLEN</p>
<p>命令介绍：返回 <code>key</code> 指定的哈希集包含的字段的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HSET myhash field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HLEN myhash</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HMGET</p>
<p>命令介绍：返回 <code>key</code> 指定的哈希集中指定字段的值。</p>
<p>对于哈希集中不存在的每个字段，返回 <code>nil</code> 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 <code>key</code> 执行 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/hmget.html">HMGET</a> 将返回一个只含有 <code>nil</code> 值的列表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HSET myhash field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HMGET myhash field1 field2 nofield</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line">3) (nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HMSET</p>
<p>命令介绍：设置 <code>key</code> 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 <code>key</code> 指定的哈希集不存在，会创建一个新的哈希集并与 <code>key</code> 关联</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET myhash field1 <span class="string">&quot;Hello&quot;</span> field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; HGET myhash field2</span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HSET</p>
<p>命令介绍：设置 key 指定的哈希集中指定字段的值。</p>
<p>如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。</p>
<p>如果字段在哈希集中存在，它将被重写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HSETNX</p>
<p>命令介绍：只在 <code>key</code> 指定的哈希集中不存在指定的字段时，设置字段的值。如果 <code>key</code> 指定的哈希集不存在，会创建一个新的哈希集并与 <code>key</code> 关联。如果字段已存在，该操作无效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX myhash field <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HSETNX myhash field <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HGET myhash field</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HSTRLEN</p>
<p>命令介绍：返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET myhash f1 HelloWorld f2 99 f3 -256</span><br><span class="line">OK</span><br><span class="line">redis&gt; HSTRLEN myhash f1</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">redis&gt; HSTRLEN myhash f2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; HSTRLEN myhash f3</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HVALS</p>
<p>命令介绍：返回 key 指定的哈希集中所有字段的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HSET myhash field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HVALS myhash</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>HSCAN</p>
<p>命令介绍：请参考 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/scan.html">SCAN</a>命令， <code>HSCAN</code>与之类似 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LIST命令"><a href="#LIST命令" class="headerlink" title="LIST命令"></a>LIST命令</h2><ul>
<li><p>BLPOP</p>
<p>命令介绍：<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/blpop.html">BLPOP</a> 是阻塞式列表的弹出原语。 它是命令 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/lpop.html">LPOP</a> 的阻塞版本，这是因为当给定列表内没有任何元素可供弹出的时候， 连接将被 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/blpop.html">BLPOP</a> 命令阻塞。 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL list1 list2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; RPUSH list1 a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; BLPOP list1 list2 0</span><br><span class="line">1) <span class="string">&quot;list1&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BRPOP</p>
<p>命令介绍：<code>BRPOP</code> 是一个阻塞的列表弹出原语。 它是 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/commands/rpop.html">RPOP</a> 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL list1 list2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; RPUSH list1 a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; BRPOP list1 list2 0</span><br><span class="line">1) <span class="string">&quot;list1&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BRPOPLPUSH</p>
<p>命令介绍：<code>BRPOPLPUSH</code> 是 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/rpoplpush.html">RPOPLPUSH</a> 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/rpoplpush.html">RPOPLPUSH</a> 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 timeout 为 0 能用于无限期阻塞客户端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>LINDEX</p>
<p>命令介绍：返回列表里的元素的索引 index 存储在 key 里面。 下标是从0开始索引的，所以 0 是表示第一个元素， 1 表示第二个元素，并以此类推。 负数索引用于指定从列表尾部开始索引的元素。在这种方法下，-1 表示最后一个元素，-2 表示倒数第二个元素，并以此往前推。</p>
<p>当 key 位置的值不是一个列表的时候，会返回一个error。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; LPUSH mylist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; LINDEX mylist -1</span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; LINDEX mylist 3</span><br><span class="line">(nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LINSERT</p>
<p>命令介绍：把 value 插入存于 key 的列表中在基准值 pivot 的前面或后面。</p>
<p>当 key 不存在时，这个list会被看作是空list，任何操作都不会发生。</p>
<p>当 key 存在，但保存的不是一个list的时候，会返回error。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">&quot;World&quot;</span> <span class="string">&quot;There&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;There&quot;</span></span><br><span class="line">3) <span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LLEN</p>
<p>命令介绍：返回存储在 key 里的list的长度。 如果 key 不存在，那么就被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; LPUSH mylist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LLEN mylist</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LPOP</p>
<p>命令介绍：移除并且返回 key 对应的 list 的第一个元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LPOP mylist</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LPUSH</p>
<p>命令介绍：将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。</p>
<p>可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数。元素是从最左端的到最右端的、一个接一个被插入到 list 的头部。 所以对于这个命令例子 <code>LPUSH mylist a b c</code>，返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; LPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LPUSHX</p>
<p>命令介绍：只有当 key 已经存在并且存着一个 list 的时候，在这个 key 下面的 list 的头部插入 value。 与 LPUSH 相反，当 key 不存在的时候不会进行任何操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; LPUSHX mylist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LPUSHX myotherlist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; LRANGE myotherlist 0 -1</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LRANGE</p>
<p>命令介绍：返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推。</p>
<p>偏移量也可以是负数，表示偏移量是从list尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LRANGE mylist 0 0</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; LRANGE mylist -3 2</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; LRANGE mylist -100 100</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; LRANGE mylist 5 10</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LREM</p>
<p>命令介绍：从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：</p>
<ul>
<li>count &gt; 0: 从头往尾移除值为 value 的元素。</li>
<li>count &lt; 0: 从尾往头移除值为 value 的元素。</li>
<li>count &#x3D; 0: 移除所有值为 value 的元素。</li>
</ul>
<p>比如， LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。</p>
<p>需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis&gt; LREM mylist -2 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;foo&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LSET</p>
<p>命令介绍：设置 index 位置的list元素的值为 value。 更多关于 index 参数的信息，详见 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/lindex.html">LINDEX</a>。</p>
<p>当index超出范围时会返回一个error。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LSET mylist 0 <span class="string">&quot;four&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; LSET mylist -2 <span class="string">&quot;five&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;four&quot;</span></span><br><span class="line">2) <span class="string">&quot;five&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LTRIM</p>
<p>命令介绍：修剪(trim)一个已存在的 list，这样 list 就会只包含指定范围的指定元素。start 和 stop 都是由0开始计数的， 这里的 0 是列表里的第一个元素（表头），1 是第二个元素，以此类推。</p>
<p>例如： <code>LTRIM foobar 0 2</code> 将会对存储在 foobar 的列表进行修剪，只保留列表里的前3个元素。</p>
<p>start 和 end 也可以用负数来表示与表尾的偏移量，比如 -1 表示列表里的最后一个元素， -2 表示倒数第二个，等等。</p>
<p>超过范围的下标并不会产生错误：如果 start 超过列表尾部，或者 start &gt; end，结果会是列表变成空表（即该 key 会被移除）。 如果 end 超过列表尾部，Redis 会将其当作列表的最后一个元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LTRIM mylist 1 -1</span><br><span class="line">OK</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>RPOP</p>
<p>命令介绍：移除并返回存于 key 的 list 的最后一个元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; RPOP mylist</span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>RPOPLPUSH</p>
<p>命令介绍：原子性地返回并移除存储在 source 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 destination 的列表的第一个元素位置（列表头部）。</p>
<p>例如：假设 source 存储着列表 a,b,c， destination存储着列表 x,y,z。 执行 RPOPLPUSH 得到的结果是 source 保存着列表 a,b ，而 destination 保存着列表 c,x,y,z。</p>
<p>如果 source 不存在，那么会返回 nil 值，并且不会执行任何操作。 如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; RPOPLPUSH mylist myotherlist</span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; LRANGE myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>RPUSH</p>
<p>命令介绍：向存于 key 的列表的尾部插入所有指定的值。如果 key 不存在，那么会创建一个空的列表然后再进行 push 操作。 当 key 保存的不是一个列表，那么会返回一个错误。</p>
<p>可以使用一个命令把多个元素打入队列，只需要在命令后面指定多个参数。元素是从左到右一个接一个从列表尾部插入。 比如命令 RPUSH mylist a b c 会返回一个列表，其第一个元素是 a ，第二个元素是 b ，第三个元素是 c。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>RPUSHX</p>
<p>命令介绍：将值 value 插入到列表 key 的表尾, 当且仅当 key 存在并且是一个列表。 和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/rpush.html">RPUSH</a> 命令相反, 当 key 不存在时，RPUSHX 命令什么也不做。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSHX mylist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; RPUSHX myotherlist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; LRANGE myotherlist 0 -1</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SET命令"><a href="#SET命令" class="headerlink" title="SET命令"></a>SET命令</h2><ul>
<li><p>SADD</p>
<p>命令介绍：添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中.</p>
<p>如果key 的类型不是集合则返回错误.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD myset <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myset <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myset <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;World&quot;</span></span><br><span class="line">2) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SCARD</p>
<p>命令介绍：返回集合存储的key的基数 (集合元素的数量).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD myset <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myset <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SCARD myset</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SDIFF</p>
<p>命令介绍：返回一个集合与给定集合的差集的元素.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SDIFF key1 key2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SDIFFSTORE</p>
<p>命令介绍：该命令类似于 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sdiff.html">SDIFF</a>, 不同之处在于该命令不返回结果集，而是将结果存放在<code>destination</code>集合中.</p>
<p>如果<code>destination</code>已经存在, 则将其覆盖重写.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SDIFFSTORE key key1 key2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; SMEMBERS key</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SINTER</p>
<p>命令介绍：返回指定所有的集合的成员的交集.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SINTER key1 key2</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SINTERSTORE</p>
<p>命令介绍：这个命令与<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sinter.html">SINTER</a>命令类似, 但是它并不是直接返回结果集,而是将结果保存在 destination集合中.</p>
<p>如果destination 集合存在, 则会被重写.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SINTERSTORE key key1 key2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SMEMBERS key</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SISMEMBER</p>
<p>命令介绍：返回成员 member 是否是存储的集合 key的成员.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD myset <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SISMEMBER myset <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SISMEMBER myset <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SMEMBERS</p>
<p>命令介绍：返回key集合所有的元素.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD myset <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myset <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;World&quot;</span></span><br><span class="line">2) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SMOVE</p>
<p>命令介绍：将member从source集合移动到destination集合中. 对于其他的客户端,在特定的时间元素将会作为source或者destination集合的成员出现.</p>
<p>如果source 集合不存在或者不包含指定的元素,这smove命令不执行任何操作并且返回0.否则对象将会从source集合中移除，并添加到destination集合中去，如果destination集合已经存在该元素，则smove命令仅将该元素充source集合中移除. 如果source 和destination不是集合类型,则返回错误.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD myset <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myset <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myotherset <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SMOVE myset myotherset <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; SMEMBERS myotherset</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SPOP</p>
<p>命令介绍：从存储在<code>key</code>的集合中移除并返回一个或多个随机元素。</p>
<p>此操作与<code>SRANDMEMBER</code>类似，它从一个集合中返回一个或多个随机元素，但不删除元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SADD myset <span class="string">&quot;one&quot;</span></span><br><span class="line">SADD myset <span class="string">&quot;two&quot;</span></span><br><span class="line">SADD myset <span class="string">&quot;three&quot;</span></span><br><span class="line">SPOP myset</span><br><span class="line">SMEMBERS myset</span><br><span class="line">SADD myset <span class="string">&quot;four&quot;</span></span><br><span class="line">SADD myset <span class="string">&quot;five&quot;</span></span><br><span class="line">SPOP myset 3</span><br><span class="line">SMEMBERS myset</span><br></pre></td></tr></table></figure>
</li>
<li><p>SRANDMEMBER</p>
<p>命令介绍：仅提供key参数，那么随机返回key集合中的一个元素.</p>
<p>Redis 2.6开始，可以接受 count 参数，如果count是整数且小于元素的个数，返回含有 count 个不同的元素的数组，如果count是个整数且大于集合中元素的个数时，仅返回整个集合的所有元素，当count是负数，则会返回一个包含count的绝对值的个数元素的数组，如果count的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况.</p>
<p>仅提供key参数时，该命令作用类似于SPOP命令，不同的是SPOP命令会将被选择的随机元素从集合中移除，而SRANDMEMBER仅仅是返回该随记元素，而不做任何操作.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD myset one two three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; SRANDMEMBER myset 2</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; SRANDMEMBER myset -5</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">5) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SREM</p>
<p>命令介绍：在key集合中移除指定的元素. 如果指定的元素不是key集合中的元素则忽略 如果key集合不存在则被视为一个空的集合，该命令返回0.</p>
<p>如果key的类型不是一个集合,则返回错误.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD myset <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myset <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD myset <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SREM myset <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SREM myset <span class="string">&quot;four&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SUNION</p>
<p>命令介绍：返回给定的多个集合的并集中的所有成员.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SUNION key1 key2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">5) <span class="string">&quot;e&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>SUNIONSTORE</p>
<p>命令介绍：该命令作用类似于<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sunion.html">SUNION</a>命令,不同的是它并不返回结果集,而是将结果存储在destination集合中.</p>
<p>如果destination 已经存在,则将其覆盖.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SUNIONSTORE key key1 key2</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">redis&gt; SMEMBERS key</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;e&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;a&quot;</span></span><br><span class="line">5) <span class="string">&quot;d&quot;</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SSCAN</p>
<p>命令介绍：请参考<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/scan.html">SCAN</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SORTED-SET命令"><a href="#SORTED-SET命令" class="headerlink" title="SORTED_SET命令"></a>SORTED_SET命令</h2><ul>
<li><p>ZADD</p>
<p>命令介绍：将所有指定成员添加到键为<code>key</code>有序集合（sorted set）里面。 添加时可以指定多个分数&#x2F;成员（score&#x2F;member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。</p>
<p>如果<code>key</code>不存在，将会创建一个新的有序集合（sorted set）并将分数&#x2F;成员（score&#x2F;member）对添加到有序集合，就像原来存在一个空的有序集合一样。如果<code>key</code>存在，但是类型不是有序集合，将会返回一个错误应答。</p>
<p>分数值是一个双精度的浮点型数字字符串。<code>+inf</code>和<code>-inf</code>都是有效值</p>
<p>ZADD 命令在<code>key</code>后面分数&#x2F;成员（score&#x2F;member）对前面支持一些参数，他们是：</p>
<ul>
<li><strong>XX</strong>: 仅仅更新存在的成员，不添加新成员。</li>
<li><strong>NX</strong>: 不更新存在的成员。只添加新成员。</li>
<li><strong>CH</strong>: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 <strong>changed</strong> 的意思)。更改的元素是<strong>新添加的成员</strong>，已经存在的成员<strong>更新分数</strong>。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，<code>ZADD</code>返回值只计算新添加成员的数量。</li>
<li><strong>INCR</strong>: 当<code>ZADD</code>指定这个选项时，成员的操作就等同<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zincrby.html">ZINCRBY</a>命令，对成员的分数进行递增操作。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;uno&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span> 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; ZRANGE myzset 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;uno&quot;</span></span><br><span class="line">4) <span class="string">&quot;1&quot;</span></span><br><span class="line">5) <span class="string">&quot;two&quot;</span></span><br><span class="line">6) <span class="string">&quot;2&quot;</span></span><br><span class="line">7) <span class="string">&quot;three&quot;</span></span><br><span class="line">8) <span class="string">&quot;3&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZCARD</p>
<p>命令介绍：返回key的有序集元素个数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZCARD myzset</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZCOUNT</p>
<p>命令介绍：返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。 关于参数min和max的详细使用方法，请参考<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zrangebyscore.html">ZRANGEBYSCORE</a>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZCOUNT myzset -inf +inf</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; ZCOUNT myzset (1 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZINCRBY</p>
<p>命令介绍：为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合。</p>
<p>当key不是有序集类型时，返回一个错误。</p>
<p>score值必须是字符串表示的整数值或双精度浮点数，并且能接受double精度的浮点数。也有可能给一个负数来减少score的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZINCRBY myzset 2 <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">redis&gt; ZRANGE myzset 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZINTERSTORE</p>
<p>命令介绍：计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。</p>
<p>默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。</p>
<p>对于WEIGHTS和AGGREGATE参数的描述，参见命令<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zunionstore.html">ZUNIONSTORE</a>。</p>
<p>如果destination存在，就把它覆盖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD zset1 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset1 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset2 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset2 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset2 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; ZRANGE out 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;5&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;10&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZLEXCOUNT</p>
<p>命令介绍：<code>ZLEXCOUNT</code> 命令用于计算有序集合中指定成员之间的成员数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">redis&gt; ZADD myzset 0 f 0 g</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; ZLEXCOUNT myzset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">redis&gt; ZLEXCOUNT myzset [b [f</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZPOPMAX</p>
<p>命令介绍：删除并返回有序集合<code>key</code>中的最多<code>count</code>个具有最高得分的成员。</p>
<p>如未指定，<code>count</code>的默认值为1。指定一个大于有序集合的基数的<code>count</code>不会产生错误。 当返回多个元素时候，得分最高的元素将是第一个元素，然后是分数较低的元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZPOPMAX myzset</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ZPOPMIN</p>
<p>命令介绍：删除并返回有序集合<code>key</code>中的最多<code>count</code>个具有最低得分的成员。</p>
<p>如未指定，<code>count</code>的默认值为1。指定一个大于有序集合的基数的<code>count</code>不会产生错误。 当返回多个元素时候，得分最低的元素将是第一个元素，然后是分数较高的元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZPOPMIN myzset</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZRANGE</p>
<p>命令介绍：返回存储在有序集合<code>key</code>中的指定范围的元素。 返回的元素可以认为是按得分从最低到最高排列。 如果得分相同，将按字典排序。</p>
<p>当你需要元素从最高分到最低分排列时，请参阅<code>ZREVRANGE</code>（相同的得分将使用字典倒序排序）。</p>
<p>参数<code>start</code>和<code>stop</code>都是基于零的索引，即<code>0</code>是第一个元素，<code>1</code>是第二个元素，以此类推。 它们也可以是负数，表示从有序集合的末尾的偏移量，其中<code>-1</code>是有序集合的最后一个元素，<code>-2</code>是倒数第二个元素，等等。</p>
<p><code>start</code>和<code>stop</code>都是<strong>全包含的区间</strong>，因此例如<code>ZRANGE myzset 0 1</code>将会返回有序集合的第一个和第二个元素。</p>
<p>超出范围的索引不会产生错误。 如果<code>start</code>参数的值大于有序集合中的最大索引，或者<code>start &gt; stop</code>，将会返回一个空列表。 如果<code>stop</code>的值大于有序集合的末尾，Redis会将其视为有序集合的最后一个元素。</p>
<p>可以传递<code>WITHSCORES</code>选项，以便将元素的分数与元素一起返回。这样，返回的列表将包含<code>value1,score1,...,valueN,scoreN</code>，而不是<code>value1,...,valueN</code>。 客户端类库可以自由地返回更合适的数据类型（建议：具有值和得分的数组或记录）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">ZRANGE myzset 0 -1</span><br><span class="line">ZRANGE myzset 2 3</span><br><span class="line">ZRANGE myzset -2 -1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZRANGEBYLEX</p>
<p>命令介绍：ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 <span class="built_in">dd</span> 0 dobble 0 z 0 z1</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">redis&gt; ZRANGEBYLEX zset - +</span><br><span class="line"> 1) <span class="string">&quot;a&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;aa&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;abc&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;apple&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;b&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;c&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;d&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;d1&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;dd&quot;</span></span><br><span class="line">10) <span class="string">&quot;dobble&quot;</span></span><br><span class="line">11) <span class="string">&quot;z&quot;</span></span><br><span class="line">12) <span class="string">&quot;z1&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREVRANGEBYLEX</p>
<p>命令介绍：ZREVRANGEBYLEX 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。<br>在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 <span class="built_in">dd</span> 0 dobble 0 z 0 z1</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">redis&gt; ZREVRANGEBYLEX zset + -</span><br><span class="line"> 1) <span class="string">&quot;z1&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;z&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;dobble&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;dd&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;d1&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;d&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;c&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;b&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;apple&quot;</span></span><br><span class="line">10) <span class="string">&quot;abc&quot;</span></span><br><span class="line">11) <span class="string">&quot;aa&quot;</span></span><br><span class="line">12) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZRANGEBYSCORE</p>
<p>命令介绍：如果M是常量（比如，用limit总是请求前10个元素），你可以认为是O(log(N))。</p>
<p>返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。</p>
<p>具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。</p>
<p>可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。</p>
<p>可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZRANGEBYSCORE myzset -inf +inf</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis&gt; ZRANGEBYSCORE myzset 1 2</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; ZRANGEBYSCORE myzset (1 2</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; ZRANGEBYSCORE myzset (1 (2</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZRANK</p>
<p>命令介绍：返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。</p>
<p>使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZRANK myzset <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; ZRANK myzset <span class="string">&quot;four&quot;</span></span><br><span class="line">(nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREM</p>
<p>命令介绍：当key存在，但是其不是有序集合类型，就返回一个错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZREM myzset <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZRANGE myzset 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREMRANGEBYLEX</p>
<p>命令介绍：ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。<br>不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。<br>待删除的有序集合中,分数最好相同,否则删除结果会不正常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 <span class="built_in">dd</span> 0 dobble 0 z 0 z1</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">redis&gt; ZRANGEBYLEX zset + -</span><br><span class="line"> 1) <span class="string">&quot;a&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;aa&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;abc&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;apple&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;b&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;c&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;d&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;d1&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;dd&quot;</span></span><br><span class="line">10) <span class="string">&quot;dobble&quot;</span></span><br><span class="line">11) <span class="string">&quot;z&quot;</span></span><br><span class="line">12) <span class="string">&quot;z1&quot;</span></span><br><span class="line">redis&gt; ZREMRANGEBYLEX zset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">redis&gt; ZRANGEBYLEX zset - +</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREMRANGEBYRANK</p>
<p>命令介绍：移除有序集key中，指定排名(rank)区间内的所有成员。下标参数start和stop都以0为底，0处是分数最小的那个元素。这些索引也可是负数，表示位移从最高分处开始数。例如，-1是分数最高的元素，-2是分数第二高的，依次类推。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZREMRANGEBYRANK myzset 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; ZRANGE myzset 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREMRANGEBYSCORE</p>
<p>命令介绍：移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。 自版本2.1.6开始，score值等于min或max的成员也可以不包括在内，语法请参见<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zrangebyscore.html">ZRANGEBYSCORE</a>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZREMRANGEBYSCORE myzset -inf (2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZRANGE myzset 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREVRANGE</p>
<p>命令介绍：返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zrevrange.html">ZREVRANGE</a>命令的其他方面和<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zrange.html">ZRANGE</a>命令一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZREVRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; ZREVRANGE myzset 2 3</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; ZREVRANGE myzset -2 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREVRANGEBYSCORE</p>
<p>命令介绍：<code>ZREVRANGEBYSCORE</code> 返回有序集合中指定分数区间内的成员，分数由高到低排序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZREVRANGEBYSCORE myzset +inf -inf</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; ZREVRANGEBYSCORE myzset 2 1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">redis&gt; ZREVRANGEBYSCORE myzset 2 (1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; ZREVRANGEBYSCORE myzset (2 (1</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREVRANK</p>
<p>命令介绍：返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。</p>
<p>使用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zrank.html">ZRANK</a>命令可以获得成员按score值递增(从小到大)排列的排名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD myzset 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZREVRANK myzset <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; ZREVRANK myzset <span class="string">&quot;four&quot;</span></span><br><span class="line">(nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZSCORE</p>
<p>命令介绍：返回有序集key中，成员member的score值。</p>
<p>如果member元素不是有序集key的成员，或key不存在，返回nil。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZSCORE myzset <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZUNIONSTORE</p>
<p>命令介绍：计算给定的numkeys个有序集合的并集，并且把结果放到destination中。在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 默认情况下，结果集中某个成员的score值是所有给定集下该成员score值之和。</p>
<p>使用WEIGHTS选项，你可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认就是1。</p>
<p>使用AGGREGATE选项，你可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中元素最小或最大的元素。</p>
<p>如果key destination存在，就被覆盖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD zset1 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset1 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset2 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset2 2 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD zset2 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; ZRANGE out 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;5&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;9&quot;</span></span><br><span class="line">5) <span class="string">&quot;two&quot;</span></span><br><span class="line">6) <span class="string">&quot;10&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>ZSCAN</p>
<p>命令介绍：请参考<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/scan.html">SCAN</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CONNECTION命令"><a href="#CONNECTION命令" class="headerlink" title="CONNECTION命令"></a>CONNECTION命令</h2><ul>
<li><p>AUTH</p>
<p>命令介绍：为redis服务请求设置一个密码。redis可以设置在客户端执行commands请求前需要通过密码验证。通过修改配置文件的requirepass就可以设置密码。 如果密码与配置文件里面设置的密码一致，服务端就会发会一个OK的状态码，接受客户端发送其他的请求命令，否则服务端会返回一个错误码，客户端需要尝试使用新的密码来进行连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>ECHO</p>
<p>命令介绍：返回消息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ECHO HelloWorld!</span><br><span class="line">HelloWorld!</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>PING</p>
<p>命令介绍：如果后面没有参数时返回<code>PONG</code>，否则会返回后面带的参数。</p>
<p>这个命令经常用来测试一个连接是否还是可用的，或者用来测试一个连接的延时。</p>
<p>如果客户端处于频道订阅模式下，它将是一个multi-bulk返回，第一次时返回”pong”，之后返回空（empty bulk），除非命令后面更随了参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PING</span><br><span class="line">PONG</span><br><span class="line">redis&gt; PING <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line">redis&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>QUIT</p>
<p>命令介绍：请求服务器关闭连接。连接将会尽可能快的将未完成的客户端请求完成处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SELECT</p>
<p>命令介绍：选择一个数据库，下标值从0开始，一个新连接默认连接的数据库是DB0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SWAPDB</p>
<p>命令介绍：该命令可以交换同一Redis服务器上的两个DATABASE，可以实现连接某一数据库的连接立即访问到其他DATABASE的数据。访问交换前其他database的连接也可以访问到该DATABASE的数据。 如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWPAP 0 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SERVER命令"><a href="#SERVER命令" class="headerlink" title="SERVER命令"></a>SERVER命令</h2><ul>
<li><p>BGREWRITEAOF</p>
<p>命令介绍：Redis <code>BGREWRITEAOF</code> 命令用于异步执行一个 AOF（AppendOnly File）文件重写操作。重写会创建一个当前AOF文件的体积优化版本。</p>
<p>即使 <code>BGREWRITEAOF</code> 执行失败，也不会有任何数据丢失，因为旧的AOF文件在<code>BGREWRITEAOF</code> 成功之前不会被修改。</p>
<p>AOF 重写由 Redis 自行触发， <code>BGREWRITEAOF</code>仅仅用于手动触发重写操作。</p>
<p>具体内容:</p>
<ul>
<li>如果一个子Redis是通过磁盘快照创建的，AOF重写将会在RDB终止后才开始保存。这种情况下<code>BGREWRITEAOF</code>任然会返回OK状态码。从Redis 2.6起你可以通过<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/info.html">INFO</a>命令查看AOF重写执行情况。</li>
<li>如果只在执行的AOF重写返回一个错误，AOF重写将会在稍后一点的时间重新调用。</li>
</ul>
<p>从 Redis 2.4 开始，AOF重写由 Redis 自行触发，<code>BGREWRITEAOF</code>仅仅用于手动触发重写操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>BGSAVE</p>
<p>命令介绍：后台保存DB。会立即返回 OK 状态码。 Redis forks, 父进程继续提供服务以供客户端调用，子进程将DB数据保存到磁盘然后退出。如果操作成功，可以通过客户端命令LASTSAVE来检查操作结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT KILL</p>
<p>命令介绍：<code>CLIENT KILL</code>关闭一个指定的连接。在Redis2.8.11时可以根据客户端地址关闭指定连接，关闭方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLIENT KILL addr:port</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT LIST</p>
<p>命令介绍：Redis <code>CLIENT LIST</code>命令用于返回所有连接到服务器的客户端信息和统计数据。</p>
<p><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/protocol.html#bulk-string-reply">bulk-string-reply</a>: 一个独特的字符串，格式如下：</p>
<ul>
<li>每个已连接客户端对应一行（以 LF 分割）</li>
<li>每行字符串由一系列 属性&#x3D;值（<code>property=value</code>） 形式的域组成，每个域之间以空格分开。</li>
</ul>
<p>下面是各字段的含义：:</p>
<ul>
<li><code>id</code>: 唯一的64位的客户端ID(Redis 2.8.12加入)。</li>
<li><code>addr</code>: 客户端的地址和端口</li>
<li><code>fd</code>: 套接字所使用的文件描述符</li>
<li><code>age</code>: 以秒计算的已连接时长</li>
<li><code>idle</code>: 以秒计算的空闲时长</li>
<li><code>flags</code>: 客户端 flag</li>
<li><code>db</code>: 该客户端正在使用的数据库 ID</li>
<li><code>sub</code>: 已订阅频道的数量</li>
<li><code>psub</code>: 已订阅模式的数量</li>
<li><code>multi</code>: 在事务中被执行的命令数量</li>
<li><code>qbuf</code>: 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</li>
<li><code>qbuf-free</code>: 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</li>
<li><code>obl</code>: 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</li>
<li><code>oll</code>: 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li>
<li><code>omem</code>: 输出缓冲区和输出列表占用的内存总量</li>
<li><code>events</code>: 文件描述符事件</li>
<li><code>cmd</code>: 最近一次执行的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT GETNAME</p>
<p>命令介绍：<code>CLIENT GETNAME</code> 返回当前连接由<code>CLIENT SETNAME</code>设置的名字。如果没有用<code>CLIENT SETNAME</code>设置名字，将返回一个空的回复。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT ID</p>
<p>命令介绍：该命令返回当前连接的ID，每个ID符合如下约束：</p>
<ol>
<li>永不重复。当调用命令<code>CLIENT ID</code>返回相同的值时，调用者可以确认原连接未被断开，只是被重用 ，因此仍可以认为是同一连接</li>
<li>ID值单调递增。若某一连接的ID值比其他连接的ID值大，可以确认该连接是较新创建的</li>
</ol>
<p>该命令和同为Redis 5 新增的命令 <code>CLIENT UNBLOCK</code>一起使用，会有更好的效果。两条命令的使用格式参照<code>CLIENT UNBLOCK</code>说明页。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CLIENT ID</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT PAUSE</p>
<p>命令介绍：<code>CLIENT PAUSE</code> 是连接控制命令，它可以将所有客户端的访问暂停给定的毫秒数</p>
<p>该命令执行如下：</p>
<ul>
<li>它会停止处理所有来自一般客户端或者pub&#x2F;sub客户端的命令。但是和slaves的交互命令不受影响。</li>
<li>因为它会尽快返回OK给调用者，所以<code>CLIENT PAUSE</code> 不会被自己暂停。</li>
<li>当给定的时间结束，所有的客户端都被解除阻塞:查询缓存里积累的所有命令都会被处理。</li>
</ul>
<p>当该命令可以可控的将客户端从一个Redis实例切换至另一个实例。比如，当需要升级一个实例时，管理员可以作如下操作：</p>
<ul>
<li>使用<code>CLIENT PAUSE</code> 暂停所有客户端</li>
<li>等待数秒，让slaves节点处理完所有来自master的复制命令</li>
<li>将一个salve节点切换为master</li>
<li>重配客户端以来接新的master 节点</li>
</ul>
<p>可以在MULTI&#x2F;EXEC中一起使用<code>CLIENT PAUSE</code> 和<code>INFO replication</code>以在阻塞的同时获取当前master的偏移量。用这种方法，可以让slaves处理至给定的复制偏移节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT REPLY</p>
<p>命令介绍：当需要完全禁用redis服务器对当前客户端的回复时可使用该命令。</p>
<p>在如下几种场景：执行fire和forget类型的命令；正在进行大量数据加载；正在建缓存，数据在不断传输过程中，客户端会忽略收到的回复，此时消耗服务器时间和带宽回复客户端，是一种资源浪费。</p>
<p>注：fire 和 forget 就是发送命令，然后完全不关心最终什么时候完成命令操作。</p>
<p><code>CLIENT REPLY</code>可设置服务器是否对客户端的命令进行回复。有如下选项：</p>
<ul>
<li><code>ON</code>. 默认选项，回复客户端每条命令</li>
<li><code>OFF</code>. 不回复客户端命令</li>
<li><code>SKIP</code>. 跳过该命令的回复</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT SETNAME</p>
<p>命令介绍：命令<code>CLIENT SETNAME</code> 为当前连接分配一个名字。</p>
<p>这个名字会显示在<code>CLIENT LIST</code>命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</p>
<p>举个例子， 在使用 Redis 构建队列（queue）时， 可以根据连接负责的任务（role）， 为信息生产者（producer）和信息消费者（consumer）分别设置不同的名字。</p>
<p>名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。 另外， 为了避免和<code>CLIENT LIST</code>命令的输出格式发生冲突， 名字里不允许使用空格。</p>
<p>要移除一个连接的名字， 可以将连接的名字设为空字符串 “” 。</p>
<p>使用 <code>CLIENT GETNAME</code> 命令可以取出连接的名字。</p>
<p>新创建的连接默认是没有名字的。</p>
<p>提示：在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Connection A (blocking connection):</span><br><span class="line">&gt; CLIENT ID</span><br><span class="line">2934</span><br><span class="line">&gt; BRPOP key1 key2 key3 0</span><br><span class="line">(client is blocked)</span><br><span class="line"></span><br><span class="line">... Now we want to add a new key ...</span><br><span class="line"></span><br><span class="line">Connection B (control connection):</span><br><span class="line">&gt; CLIENT UNBLOCK 2934</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Connection A (blocking connection):</span><br><span class="line">... BRPOP reply with <span class="built_in">timeout</span> ...</span><br><span class="line">NULL</span><br><span class="line">&gt; BRPOP key1 key2 key3 key4 0</span><br><span class="line">(client is blocked again)</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLIENT UNBLOCK</p>
<p>命令介绍：当客户端因为执行具有阻塞功能的命令如<code>BRPOP</code>、<code>XREAD</code>或者<code>WAIT</code>被阻塞时，该命令可以通过其他连接解除客户端的阻塞</p>
<p>默认情况下，当命令timeout设置超时时，客户端会被解除阻塞。当提供了额外(可选)的设置，可以确定解除阻塞的类型，可以是<strong>TIMEOUT</strong>或者<strong>ERROR</strong>类型。当时<strong>ERROR</strong>类型时，客户端阻塞被强制解除同时收到如下明确报错信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>COMMAND</p>
<p>命令介绍：以数组的形式返回有关所有Redis命令的详细信息。</p>
<p>集群客户端必须知道命令中key的位置，以便命令可以转到匹配的实例， 但是Redis命令在接收一个key，多个key甚至由其他数据分隔开的多个key之间会有所不同。</p>
<p>你可以使用<code>COMMAND</code>来为每一个命令缓存命令和key位置之间的映射关系，以实现命令到集群的精确路由。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>COMMAND COUNT</p>
<p>命令介绍：返回Redis服务器命令的总数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; COMMAND COUNT</span><br><span class="line">(<span class="built_in">integer</span>) 197</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GETKEYS</p>
<p>命令介绍：以<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/protocol.html#array-reply">array-reply</a>的形式从完整的Redis命令返回key。</p>
<p><code>COMMAND GETKEYS</code>是一个辅助命令，让你可以从完整的Redis命令中找到key。</p>
<p><code>COMMAND</code>显示了某些命令拥有可变位置的key，这意味着必须分析完整的命令才能找到要存储或者检索的key。 你可以使用<code>COMMAND GETKEYS</code>直接从Redis解析命令的方式来发现key的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COMMAND GETKEYS MSET a b c d e f</span><br><span class="line">COMMAND GETKEYS EVAL <span class="string">&quot;not consulted&quot;</span> 3 key1 key2 key3 arg1 arg2 arg3 argN</span><br><span class="line">COMMAND GETKEYS SORT mylist ALPHA STORE outlist</span><br></pre></td></tr></table></figure>
</li>
<li><p>COMMAND INFO</p>
<p>命令介绍：以<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/protocol.html#array-reply">array-reply</a>的形式返回多个Redis命令的详细信息。</p>
<p>此命令返回的结果与<code>COMMAND</code>相同，但是你可以指定返回哪些命令。</p>
<p>如果你指定了一些不存在的命令，那么在它们的返回位置将会是nil。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; COMMAND INFO get <span class="built_in">set</span> foo <span class="built_in">eval</span></span><br><span class="line">    1) 1) <span class="string">&quot;get&quot;</span></span><br><span class="line">       2) (<span class="built_in">integer</span>) 2</span><br><span class="line">       3) 1) <span class="string">&quot;readonly&quot;</span></span><br><span class="line">          2) <span class="string">&quot;fast&quot;</span></span><br><span class="line">       4) (<span class="built_in">integer</span>) 1</span><br><span class="line">       5) (<span class="built_in">integer</span>) 1</span><br><span class="line">       6) (<span class="built_in">integer</span>) 1</span><br><span class="line">    2) 1) <span class="string">&quot;set&quot;</span></span><br><span class="line">       2) (<span class="built_in">integer</span>) -3</span><br><span class="line">       3) 1) <span class="string">&quot;write&quot;</span></span><br><span class="line">          2) <span class="string">&quot;denyoom&quot;</span></span><br><span class="line">       4) (<span class="built_in">integer</span>) 1</span><br><span class="line">       5) (<span class="built_in">integer</span>) 1</span><br><span class="line">       6) (<span class="built_in">integer</span>) 1</span><br><span class="line">    3) (nil)</span><br><span class="line">    4) 1) <span class="string">&quot;eval&quot;</span></span><br><span class="line">       2) (<span class="built_in">integer</span>) -3</span><br><span class="line">       3) 1) <span class="string">&quot;noscript&quot;</span></span><br><span class="line">          2) <span class="string">&quot;movablekeys&quot;</span></span><br><span class="line">       4) (<span class="built_in">integer</span>) 0</span><br><span class="line">       5) (<span class="built_in">integer</span>) 0</span><br><span class="line">       6) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>CONFIG GET</p>
<p>命令介绍：CONFIG GET命令用来读取redis服务器的配置文件参数，但并不是所有参数都支持。 与之对应的命令是CONFIG SET用来设置服务器的配置参数。</p>
<p>CONFIG GET 命令只接受一个参数，所有配置参数都采用key-value的形式。 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; config get *max-*-entries*</span><br><span class="line">1) <span class="string">&quot;hash-max-zipmap-entries&quot;</span></span><br><span class="line">2) <span class="string">&quot;512&quot;</span></span><br><span class="line">3) <span class="string">&quot;list-max-ziplist-entries&quot;</span></span><br><span class="line">4) <span class="string">&quot;512&quot;</span></span><br><span class="line">5) <span class="string">&quot;set-max-intset-entries&quot;</span></span><br><span class="line">6) <span class="string">&quot;512&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CONFIG REWRITE</p>
<p>命令介绍：<code>CONFIG REWRITE</code>命令重写服务器启动时指定的<code>redis.conf</code>文件，应用所需的最小更改来反应服务器当前使用的配置，由于使用了<code>CONFIG SET</code>，因此与原始配置相比可能有所不同。</p>
<p>重写以非常保守的方式执行：</p>
<ul>
<li>注释和原始redis.conf文件的整体结构会尽可能的保留下来。</li>
<li>如果一个选项在旧的redis.conf文件中已经存在，那么它会在相同的位置（行号）被重写。</li>
<li>如果某个选项在配置文件中尚不存在，但被设置为了该选项的默认值，那么他将不会被重写进程写入配置文件。</li>
<li>如果某个选项在配置文件中尚不存在，但被设置了一个非默认值，那么它会被追加到文件的末尾。</li>
<li>未使用的行将会留空。例如，如果你之前在配置文件中有多个<code>save</code>配置项，但由于你禁用了RDB持久化，当前的<code>save</code>配置变少了或者变为空，那么所有的那些行将会是空行。</li>
</ul>
<p>如果原始文件由于某些原因不再存在，CONFIG REWRITE也能够从头开始重写配置文件。但是，如果服务器启动的时候没有指定任何配置文件，则CONFIG REWRITE将只会返回一个错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CONFIG SET</p>
<p>命令介绍：<code>CONFIG SET</code>命令用于在服务器运行期间重写某些配置，而不用重启Redis。你可以使用此命令更改不重要的参数或从一个参数切换到另一个持久性选项。</p>
<p>可以通过<code>CONFIG GET *</code>获得<code>CONFIG SET</code>命令支持的配置参数列表，该命令是用于获取有关正在运行的Redis实例的配置信息的对称命令。</p>
<p>所有使用<code>CONFIG SET</code>设置的配置参数将会立即被Redis加载，并从下一个执行的命令开始生效。</p>
<p>所有支持的参数与<a target="_blank" rel="noopener" href="http://github.com/antirez/redis/raw/2.8/redis.conf">redis.conf</a>文件中使用的等效配置参数具有相同含义，但有以下重要区别：</p>
<ul>
<li>在指定字节或其他数量的选项中，不能使用在<code>redis.conf</code>中使用的简写形式（如<code>10k</code>，<code>2gb</code>等），所有内容都应该指定为格式良好的64位整数，以配置指令的基本单位表示。但从Redis3.0以及更高版本开始，可以将<code>CONFIG SET</code>与内存单元一起用于<code>maxmemory</code>、客户端输出缓冲以及复制积压大小（repl-backlog-size）指定内存单位。</li>
<li>save参数是一个以空格分隔的整数字符串。每对整数代表一个秒&#x2F;修改阈值。</li>
</ul>
<p>例如在<code>redis.conf</code>中看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>CONFIG RESERSTAT</p>
<p>命令介绍：重置INFO命令统计里面的一些计算器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Keyspace hits</span><br><span class="line">Keyspace misses</span><br><span class="line">Number of commands processed</span><br><span class="line">Number of connections received</span><br><span class="line">Number of expired keys</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>DBSIZE</p>
<p>命令介绍：返回当前数据里面keys的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>DEBUG OBJECT</p>
<p>命令介绍：<code>DEBUG OBJECT</code> 是一个不应该被客户端使用的调试命令。 请参考 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/command/object.html">OBJECT</a> 命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>DEBUG SEGFAULT</p>
<p>命令介绍：<code>DEBUG SEGFAULT</code>执行在崩溃的Redis一个无效的内存访问，它是用来模拟在开发过程中的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>FLUSHALL</p>
<p>命令介绍：删除所有数据库里面的所有数据，注意不是当前数据库，而是所有数据库。</p>
<p>这个命令永远不会出现失败。</p>
<p>这个操作的时间复杂度是<code>O(N)</code>,N是数据库的数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>FLUSHDB</p>
<p>命令介绍：删除当前数据库里面的所有数据。</p>
<p>这个命令永远不会出现失败。</p>
<p>这个操作的时间复杂度是<code>O(N)</code>,N是当前数据库的keys数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>INFO</p>
<p>命令介绍：<code>INFO</code>命令以一种易于理解和阅读的格式，返回关于Redis服务器的各种信息和统计数值。</p>
<p>通过给定可选的参数 section ，可以让命令只返回某一部分的信息:</p>
<ul>
<li><code>server</code>: Redis服务器的一般信息</li>
<li><code>clients</code>: 客户端的连接部分</li>
<li><code>memory</code>: 内存消耗相关信息</li>
<li><code>persistence</code>: RDB和AOF相关信息</li>
<li><code>stats</code>: 一般统计</li>
<li><code>replication</code>: 主&#x2F;从复制信息</li>
<li><code>cpu</code>: 统计CPU的消耗</li>
<li><code>commandstats</code>: Redis命令统计</li>
<li><code>cluster</code>: Redis集群信息</li>
<li><code>keyspace</code>: 数据库的相关统计</li>
</ul>
<p>它也可以采取以下值:</p>
<ul>
<li><code>all</code>: 返回所有信息</li>
<li><code>default</code>: 值返回默认设置的信息</li>
</ul>
<p>如果没有使用任何参数时，默认为<code>default</code></p>
</li>
<li><p>下面是所有 <strong>server</strong> 相关的信息:</p>
<ul>
<li><code>redis_version</code>: Redis 服务器版本</li>
<li><code>redis_git_sha1</code>: Git SHA1</li>
<li><code>redis_git_dirty</code>: Git dirty flag</li>
<li><code>redis_build_id</code>: 构建ID</li>
<li><code>redis_mode</code>: 服务器模式（standalone，sentinel或者cluster）</li>
<li><code>os</code>: Redis 服务器的宿主操作系统</li>
<li><code>arch_bits</code>: 架构（32 或 64 位）</li>
<li><code>multiplexing_api</code>: Redis 所使用的事件处理机制</li>
<li><code>atomicvar_api</code>: Redis使用的Atomicvar API</li>
<li><code>gcc_version</code>: 编译 Redis 时所使用的 GCC 版本</li>
<li><code>process_id</code>: 服务器进程的 PID</li>
<li><code>run_id</code>: Redis 服务器的随机标识符（用于 Sentinel 和集群）</li>
<li><code>tcp_port</code>: TCP&#x2F;IP 监听端口</li>
<li><code>uptime_in_seconds</code>: 自 Redis 服务器启动以来，经过的秒数</li>
<li><code>uptime_in_days</code>: 自 Redis 服务器启动以来，经过的天数</li>
<li><code>hz</code>: 服务器的频率设置</li>
<li><code>lru_clock</code>: 以分钟为单位进行自增的时钟，用于 LRU 管理</li>
<li><code>executable</code>: 服务器的可执行文件路径</li>
<li><code>config_file</code>: 配置文件路径</li>
</ul>
<p>下面是所有 <strong>clients</strong> 相关的信息:</p>
<ul>
<li><code>connected_clients</code>: 已连接客户端的数量（不包括通过从属服务器连接的客户端）</li>
<li><code>client_longest_output_list</code>: 当前连接的客户端当中，最长的输出列表</li>
<li><code>client_biggest_input_buf</code>: 当前连接的客户端当中，最大输入缓存</li>
<li><code>blocked_clients</code>: 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</li>
</ul>
<p>下面是所有 <strong>memory</strong> 相关的信息:</p>
<ul>
<li><code>used_memory</code>: 由 Redis 分配器分配的内存总量，以字节（byte）为单位</li>
<li><code>used_memory_human</code>: 以人类可读的格式返回 Redis 分配的内存总量</li>
<li><code>used_memory_rss</code>: 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</li>
<li><code>used_memory_peak</code>: Redis 的内存消耗峰值（以字节为单位）</li>
<li><code>used_memory_peak_human</code>: 以人类可读的格式返回 Redis 的内存消耗峰值</li>
<li><code>used_memory_peak_perc</code>: 使用内存占峰值内存的百分比</li>
<li><code>used_memory_overhead</code>: 服务器为管理其内部数据结构而分配的所有开销的总和（以字节为单位）</li>
<li><code>used_memory_startup</code>: Redis在启动时消耗的初始内存大小（以字节为单位）</li>
<li><code>used_memory_dataset</code>: 以字节为单位的数据集大小（used_memory减去used_memory_overhead）</li>
<li><code>used_memory_dataset_perc</code>: used_memory_dataset占净内存使用量的百分比（used_memory减去used_memory_startup）</li>
<li><code>total_system_memory</code>: Redis主机具有的内存总量</li>
<li><code>total_system_memory_human</code>: 以人类可读的格式返回 Redis主机具有的内存总量</li>
<li><code>used_memory_lua</code>: Lua 引擎所使用的内存大小（以字节为单位）</li>
<li><code>used_memory_lua_human</code>: 以人类可读的格式返回 Lua 引擎所使用的内存大小</li>
<li><code>maxmemory</code>: maxmemory配置指令的值</li>
<li><code>maxmemory_human</code>: 以人类可读的格式返回 maxmemory配置指令的值</li>
<li><code>maxmemory_policy</code>: maxmemory-policy配置指令的值</li>
<li><code>mem_fragmentation_ratio</code>: <code>used_memory_rss</code> 和 <code>used_memory</code> 之间的比率</li>
<li><code>mem_allocator</code>: 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</li>
<li><code>active_defrag_running</code>: 指示活动碎片整理是否处于活动状态的标志</li>
<li><code>lazyfree_pending_objects</code>: 等待释放的对象数（由于使用ASYNC选项调用UNLINK或FLUSHDB和FLUSHALL）</li>
</ul>
<p>在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。</p>
<p>当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。</p>
<p>内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。</p>
<p>当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</p>
<p>由于Redis无法控制其分配的内存如何映射到内存页，因此常住内存（used_memory_rss）很高通常是内存使用量激增的结果。</p>
<p>当 Redis 释放内存时，内存将返回给分配器，分配器可能会，也可能不会，将内存返还给操作系统。</p>
<p>如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。</p>
<p>查看 used_memory_peak 的值可以验证这种情况是否发生。</p>
<p>要获得有关服务器内存的其他内省信息，可以参考<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/memory-stats"><code>MEMORY STATS</code></a>和<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/memory-doctor"><code>MEMORY DOCTOR</code></a>。</p>
<p>下面是所有 <strong>persistence</strong> 相关的信息:</p>
<ul>
<li><code>loading</code>: 指示转储文件（dump）的加载是否正在进行的标志</li>
<li><code>rdb_changes_since_last_save</code>: 自上次转储以来的更改次数</li>
<li><code>rdb_bgsave_in_progress</code>: 指示RDB文件是否正在保存的标志</li>
<li><code>rdb_last_save_time</code>: 上次成功保存RDB的基于纪年的时间戳</li>
<li><code>rdb_last_bgsave_status</code>: 上次RDB保存操作的状态</li>
<li><code>rdb_last_bgsave_time_sec</code>: 上次RDB保存操作的持续时间（以秒为单位）</li>
<li><code>rdb_current_bgsave_time_sec</code>: 正在进行的RDB保存操作的持续时间（如果有）</li>
<li><code>rdb_last_cow_size</code>: 上次RDB保存操作期间copy-on-write分配的字节大小</li>
<li><code>aof_enabled</code>: 表示AOF记录已激活的标志</li>
<li><code>aof_rewrite_in_progress</code>: 表示AOF重写操作正在进行的标志</li>
<li><code>aof_rewrite_scheduled</code>: 表示一旦进行中的RDB保存操作完成，就会安排进行AOF重写操作的标志</li>
<li><code>aof_last_rewrite_time_sec</code>: 上次AOF重写操作的持续时间，以秒为单位</li>
<li><code>aof_current_rewrite_time_sec</code>: 正在进行的AOF重写操作的持续时间（如果有）</li>
<li><code>aof_last_bgrewrite_status</code>: 上次AOF重写操作的状态</li>
<li><code>aof_last_write_status</code>: 上一次AOF写入操作的状态</li>
<li><code>aof_last_cow_size</code>: 上次AOF重写操作期间copy-on-write分配的字节大小</li>
</ul>
<p><code>changes_since_last_save</code>指的是从上次调用<code>SAVE</code>或者<code>BGSAVE</code>以来，在数据集中产生某种变化的操作的数量。</p>
<p>如果启用了AOF，则会添加以下这些额外的字段：</p>
<ul>
<li><code>aof_current_size</code>: 当前的AOF文件大小</li>
<li><code>aof_base_size</code>: 上次启动或重写时的AOF文件大小</li>
<li><code>aof_pending_rewrite</code>: 指示AOF重写操作是否会在当前RDB保存操作完成后立即执行的标志。</li>
<li><code>aof_buffer_length</code>: AOF缓冲区大小</li>
<li><code>aof_rewrite_buffer_length</code>: AOF重写缓冲区大小</li>
<li><code>aof_pending_bio_fsync</code>: 在后台IO队列中等待fsync处理的任务数</li>
<li><code>aof_delayed_fsync</code>: 延迟fsync计数器</li>
</ul>
<p>如果正在执行加载操作，将会添加这些额外的字段：</p>
<ul>
<li><code>loading_start_time</code>: 加载操作的开始时间（基于纪元的时间戳）</li>
<li><code>loading_total_bytes</code>: 文件总大小</li>
<li><code>loading_loaded_bytes</code>: 已经加载的字节数</li>
<li><code>loading_loaded_perc</code>: 已经加载的百分比</li>
<li><code>loading_eta_seconds</code>: 预计加载完成所需的剩余秒数</li>
</ul>
<p>下面是所有 <strong>stats</strong> 相关的信息:</p>
<ul>
<li><code>total_connections_received</code>: 服务器接受的连接总数</li>
<li><code>total_commands_processed</code>: 服务器处理的命令总数</li>
<li><code>instantaneous_ops_per_sec</code>: 每秒处理的命令数</li>
<li><code>rejected_connections</code>: 由于<code>maxclients</code>限制而拒绝的连接数</li>
<li><code>expired_keys</code>: key到期事件的总数</li>
<li><code>evicted_keys</code>: 由于<code>maxmemory</code>限制而导致被驱逐的key的数量</li>
<li><code>keyspace_hits</code>: 在主字典中成功查找到key的次数</li>
<li><code>keyspace_misses</code>: 在主字典中查找key失败的次数</li>
<li><code>pubsub_channels</code>: 拥有客户端订阅的全局pub&#x2F;sub通道数</li>
<li><code>pubsub_patterns</code>: 拥有客户端订阅的全局pub&#x2F;sub模式数</li>
<li><code>latest_fork_usec</code>: 最新fork操作的持续时间，以微秒为单位</li>
</ul>
<p>下面是所有 <strong>replication</strong> 相关的信息:</p>
<p>-<code>role</code>: 如果实例不是任何节点的从节点，则值是”master”，如果实例从某个节点同步数据，则是”slave”。 请注意，一个从节点可以是另一个从节点的主节点（菊花链）。</p>
<p>如果实例是从节点，则会提供以下这些额外字段：</p>
<ul>
<li><code>master_host</code>: 主节点的Host名称或IP地址</li>
<li><code>master_port</code>: 主节点监听的TCP端口</li>
<li><code>master_link_status</code>: 连接状态（up或者down）</li>
<li><code>master_last_io_seconds_ago</code>: 自上次与主节点交互以来，经过的秒数</li>
<li><code>master_sync_in_progress</code>: 指示主节点正在与从节点同步</li>
</ul>
<p>如果SYNC操作正在进行，则会提供以下这些字段：</p>
<ul>
<li><code>master_sync_left_bytes</code>: 同步完成前剩余的字节数</li>
<li><code>master_sync_last_io_seconds_ago</code>: 在SYNC操作期间自上次传输IO以来的秒数</li>
</ul>
<p>如果主从节点之间的连接断开了，则会提供一个额外的字段：</p>
<ul>
<li><code>master_link_down_since_seconds</code>: 自连接断开以来，经过的秒数</li>
</ul>
<p>以下字段将始终提供：</p>
<ul>
<li><code>connected_slaves</code>: 已连接的从节点数</li>
</ul>
<p>对每个从节点，将会添加以下行：</p>
<ul>
<li><code>slaveXXX</code>: id，地址，端口号，状态</li>
</ul>
<p>下面是所有 <strong>cpu</strong> 相关的信息:</p>
<ul>
<li><code>used_cpu_sys</code>: 由Redis服务器消耗的系统CPU</li>
<li><code>used_cpu_user</code>: 由Redis服务器消耗的用户CPU</li>
<li><code>used_cpu_sys_children</code>: 由后台进程消耗的系统CPU</li>
<li><code>used_cpu_user_children</code>: 由后台进程消耗的用户CPU</li>
</ul>
<p><strong>commandstats</strong>部分提供基于命令类型的统计，包含调用次数，这些命令消耗的总CPU时间，以及每个命令执行所消耗的平均CPU。</p>
<p>对于每一个命令类型，添加以下行：</p>
<ul>
<li><code>cmdstat_XXX</code>: <code>calls=XXX,usec=XXX,usec_per_call=XXX</code></li>
</ul>
<p><strong>cluster</strong>部分当前只包含一个唯一的字段：</p>
<ul>
<li><code>cluster_enabled</code>: 表示已启用Redis集群</li>
</ul>
<p><strong>keyspace</strong>部分提供有关每个数据库的主字典的统计，统计信息是key的总数和过期的key的总数。</p>
<p>对于每个数据库，提供以下行：</p>
<ul>
<li><code>dbXXX</code>: <code>keys=XXX,expires=XXX</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:999.999.999</span><br><span class="line">redis_git_sha1:ceaf58df</span><br><span class="line">redis_git_dirty:1</span><br><span class="line">redis_build_id:a5eeeb464ee54856</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 4.1.5-x86_64-linode61 x86_64</span><br><span class="line">arch_bits:32</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.4.1</span><br><span class="line">process_id:21798</span><br><span class="line">run_id:2569bb7433bfe013c2627edf62d9bf21eaf8a010</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:3348607</span><br><span class="line">uptime_in_days:38</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:491100</span><br><span class="line">config_file:/etc/redis/6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:8</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:7556576</span><br><span class="line">used_memory_human:7.21M</span><br><span class="line">used_memory_rss:10555392</span><br><span class="line">used_memory_rss_human:10.07M</span><br><span class="line">used_memory_peak:8370272</span><br><span class="line">used_memory_peak_human:7.98M</span><br><span class="line">total_system_memory:4142215168</span><br><span class="line">total_system_memory_human:3.86G</span><br><span class="line">used_memory_lua:24576</span><br><span class="line">used_memory_lua_human:24.00K</span><br><span class="line">maxmemory:3221225472</span><br><span class="line">maxmemory_human:3.00G</span><br><span class="line">maxmemory_policy:unknown</span><br><span class="line">mem_fragmentation_ratio:1.40</span><br><span class="line">mem_allocator:jemalloc-3.6.0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:521</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1460108780</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:0</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:1058</span><br><span class="line">total_commands_processed:20227305</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">total_net_input_bytes:1528543656</span><br><span class="line">total_net_output_bytes:2155353808</span><br><span class="line">instantaneous_input_kbps:0.00</span><br><span class="line">instantaneous_output_kbps:0.00</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:22616</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:5059386</span><br><span class="line">keyspace_misses:1405484</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:645</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:2776.27</span><br><span class="line">used_cpu_user:2449.24</span><br><span class="line">used_cpu_sys_children:59.10</span><br><span class="line">used_cpu_user_children:1237.45</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line">cluster_enabled:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=3790,expires=2,avg_ttl=95446662632</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LASTSAVE</p>
<p>命令介绍：执行成功时返回UNIX时间戳。客户端执行 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/bgsave.html">BGSAVE</a> 命令时，可以通过每N秒发送一个 <code>LASTSAVE</code> 命令来查看<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/bgsave.html">BGSAVE</a> 命令执行的结果，由 <code>LASTSAVE</code> 返回结果的变化可以判断执行结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MEMORY DOCTOR</p>
<p>命令介绍：命令<code>MEMORY DOCTOR</code> 会列出 Redis 服务器遇到的不同类型的内存相关问题，并提供相应的解决建议</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MEMORY HELP</p>
<p>命令介绍：命令<code>MEMORY HELP</code>返回不同子命令的说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MEMORY MALLOC STATS</p>
<p>命令介绍：命令<code>MEMORY MALLOC-STATS</code> 提供内存分配情况的内部统计报表</p>
<p>该命令目前仅实现了<strong>jemalloc</strong>作为内存分配器的内存统计</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MEMORY PUGRE</p>
<p>命令介绍：命令<code>MEMORY PURGE</code> 尝试清除脏页以便内存分配器回收使用</p>
<p>该命令目前仅实现了<strong>jemalloc</strong>作为内存分配器的内存统计</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MEMORY STATS</p>
<p>命令介绍：命令<code>MEMORY STATS</code> 将服务器的内存使用情况以数组情况返回</p>
<p>内存使用信息以指标和相对应值的格式返回，如下指标会被返回</p>
<ul>
<li><p><code>peak.allocated</code>:redis启动以来，allocator分配的内存峰值，单位字节；同<code>INFO</code>的<code>used_memory_peak</code></p>
</li>
<li><p><code>total.allocated</code>: allocator 当前分配的内存总字节数；同 <code>INFO</code>命令<code>used_memeory</code></p>
</li>
<li><p><code>startup.allocated</code>: Redis启动完成消耗的内存字节数；同<code>INFO</code>的<code>used_memory_startup</code></p>
</li>
<li><p><code>replication.backlog</code>: Redis复制积压缓存区内存字节数；同<code>INFO</code>的<code>repl_backlog_size</code></p>
</li>
<li><p><code>clients.slaves</code>: 所有副本节点内存消耗总字节数(查询输出缓冲区，连接内存消耗)</p>
</li>
<li><p><code>clients.normal</code>：Redis所有常规客户端内存消耗总字节数(查询输出缓冲区，连接内存消耗)</p>
</li>
<li><p><code>aof.buffer</code>：当前和重写AOF缓冲区内存消耗总字节数；同 <code>INFO</code>命令<code>aof_buffer_length</code>和<code>aof_rewrite_buffer_length</code>之和</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MEMPRY USAGE</p>
<p>命令介绍：命令<code>MEMORY USAGE</code> 给出一个key和它值在RAM中占用的字节数</p>
<p>返回的结果是key的值以及为管理该key分配的内存总字节数</p>
<p>对于嵌套数据类型，可以使用选项<code>SAMPLES</code>，其中COUNT表示抽样的元素个数，默认值为5。当需要抽样所有元素时，使用<code>SAMPLES 0</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET <span class="string">&quot;&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; MEMORY USAGE <span class="string">&quot;&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 51</span><br></pre></td></tr></table></figure>
</li>
<li><p>MONITOR</p>
<p>命令介绍：<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/monitor.html">MONITOR</a> 是一个调试命令，返回服务器处理的每一个命令，它能帮助我们了解在数据库上发生了什么操作，可以通过redis-cli和telnet命令使用.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli monitor</span><br><span class="line">1339518083.107412 [0 127.0.0.1:60866] <span class="string">&quot;keys&quot;</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">1339518087.877697 [0 127.0.0.1:60866] <span class="string">&quot;dbsize&quot;</span></span><br><span class="line">1339518090.420270 [0 127.0.0.1:60866] <span class="string">&quot;set&quot;</span> <span class="string">&quot;x&quot;</span> <span class="string">&quot;6&quot;</span></span><br><span class="line">1339518096.506257 [0 127.0.0.1:60866] <span class="string">&quot;get&quot;</span> <span class="string">&quot;x&quot;</span></span><br><span class="line">1339518099.363765 [0 127.0.0.1:60866] <span class="string">&quot;del&quot;</span> <span class="string">&quot;x&quot;</span></span><br><span class="line">1339518100.544926 [0 127.0.0.1:60866] <span class="string">&quot;get&quot;</span> <span class="string">&quot;x&quot;</span></span><br></pre></td></tr></table></figure>


<p>$ telnet localhost 6379<br>Trying 127.0.0.1…<br>Connected to localhost.<br>Escape character is ‘^]’.<br>MONITOR<br>+OK<br>+1339518083.107412 [0 127.0.0.1:60866] “keys” “*”<br>+1339518087.877697 [0 127.0.0.1:60866] “dbsize”<br>+1339518090.420270 [0 127.0.0.1:60866] “set” “x” “6”<br>+1339518096.506257 [0 127.0.0.1:60866] “get” “x”<br>+1339518099.363765 [0 127.0.0.1:60866] “del” “x”<br>+1339518100.544926 [0 127.0.0.1:60866] “get” “x”<br>QUIT<br>+OK<br>Connection closed by foreign host.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* REPLICAOF</span><br><span class="line"></span><br><span class="line">  命令介绍：命令`REPLICAOF` 可以在线修改当前服务器的复制设置</span><br><span class="line"></span><br><span class="line">  如果当前服务器已经是副本服务器，命令`REPLIACOF` NO ONE 会关闭当前服务器的复制并转变为主服务器。执行 `REPLIACOF` hostname port 会将当前服务器转变为某一服务器的副本服务器</span><br><span class="line"></span><br><span class="line">  如果当前服务器已经是某个主服务器(master server)的副本服务器，那么执行 REPLICAOF hostname port 将使当前服务器停止对原主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步</span><br><span class="line"></span><br><span class="line">  对一个副本服务器执行命令 REPLICAOF NO ONE 将使得这个副本服务器关闭复制，并从副本服务器转变回主服务器，原来同步所得的数据集不会被丢弃。因此，当原主服务器停止服务，可以将该副本服务器切换为主服务器，应用可以使用新主服务器进行读写。原主服务器修复后，可将其设置为新主服务器的副本服务器。</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>ROLE</p>
<p>命令介绍：通过返回实例当前是<code>master</code>，<code>slave</code>还是<code>sentinel</code>来提供有关Redis实例在复制环境中的角色的信息。此命令还返回有关复制状态（如果角色是master或者slave）或者监听的master名称列表（如果角色是sentinel）的额外信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">&quot;master&quot;</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 3129659</span><br><span class="line">3) 1) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;9001&quot;</span></span><br><span class="line">      3) <span class="string">&quot;3129242&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;9002&quot;</span></span><br><span class="line">      3) <span class="string">&quot;3129543&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SAVE</p>
<p>命令介绍：SAVE 命令执行一个同步操作，以RDB文件的方式保存所有数据的快照 很少在生产环境直接使用SAVE 命令，因为它会阻塞所有的客户端的请求，可以使用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/bgsave.html">BGSAVE</a> 命令代替. 如果在<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/bgsave.html">BGSAVE</a>命令的保存数据的子进程发生错误的时,用 SAVE命令保存最新的数据是最后的手段,详细的说明请参考持久化文档</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SHUTDOWN</p>
<p>命令介绍：这个命令执行如下操作:</p>
<ul>
<li>停止所有客户端.</li>
<li>如果配置了<strong>save 策略</strong> 则执行一个阻塞的save命令.</li>
<li>如果开启了<strong>AOF</strong>,则刷新aof文件..</li>
<li>关闭redis服务进程（redis-server）.</li>
</ul>
<p>如果配置了持久化策略，那么这个命令将能够保证在关闭redis服务进程的时候数据不会丢失. 如果仅仅在客户端执行SAVE 命令,然后 执行<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/quit.html">QUIT</a> 命令，那么数据的完整性将不会被保证，因为其他客户端可能在执行这两个命令的期间修改数据库的数据.</p>
<p>注意: 一个没有配置持久化策略的redis实例 (没有aof配置, 没有 “save” 命令) 将不会 在执行<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/shutdown.html">SHUTDOWN</a>命令的时候转存一个rdb文件, 通常情况下你不想让一个仅用于缓存的rendis实例宕掉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SLAVEOF</p>
<p>命令介绍：Redis <code>SLAVEOF</code> 命令可以将当前服务器转变为指定服务器的从属服务器(slave server)。</p>
<p>如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。</p>
<p>另外，对一个从属服务器执行命令 <code>SLAVEOF NO ONE</code> 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p>
<p>利用『 SLAVEOF NO ONE 不会丢弃同步所得数据集』这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; slowlog get 2</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 14</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1309448221</span><br><span class="line">   3) (<span class="built_in">integer</span>) 15</span><br><span class="line">   4) 1) <span class="string">&quot;ping&quot;</span></span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 13</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1309448128</span><br><span class="line">   3) (<span class="built_in">integer</span>) 30</span><br><span class="line">   4) 1) <span class="string">&quot;slowlog&quot;</span></span><br><span class="line">      2) <span class="string">&quot;get&quot;</span></span><br><span class="line">      3) <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SLOWLOG</p>
<p>命令介绍：此命令用于读取和重置Redis慢查询日志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SYNC</p>
<p>命令介绍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>TIME</p>
<p>命令介绍：TIME 命令返回当前Unix时间戳和这一秒已经过去的微秒数。基本上，该接口非常相似gettimeofday.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">&quot;1349834472&quot;</span></span><br><span class="line">2) <span class="string">&quot;465608&quot;</span></span><br><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">&quot;1349834472&quot;</span></span><br><span class="line">2) <span class="string">&quot;466541&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SORTEDSETS命令"><a href="#SORTEDSETS命令" class="headerlink" title="SORTEDSETS命令"></a>SORTEDSETS命令</h2><ul>
<li><p>BZPOPMAX</p>
<p>命令介绍：<code>BZPOPMAX</code> 是有序集合命令 <code>ZPOPMAX</code>带有阻塞功能的版本。</p>
<p>在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最大的成员和对应的分数</p>
<p>参数 <code>timeout</code> 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。</p>
<p>详细说明请参照<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/bzpopmin.html">BZPOPMIN 说明文档</a>，<code>BZPOPMAX</code>返回非空有序集合 key中分数最大的成员，而<code>BZPOPMIN</code>返回该key中分数最小的成员，除此之外，两条命令无其他差别。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL zset1 zset2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD zset1 0 a 1 b 2 c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; BZPOPMAX zset1 zset2 0</span><br><span class="line">1) <span class="string">&quot;zet1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BZPOPMIN</p>
<p>命令介绍：<code>BZPOPMIN</code> 是有序集合命令 <code>ZPOPMIN</code>带有阻塞功能的版本。</p>
<p>在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最小的成员和对应的分数</p>
<p>参数 <code>timeout</code> 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。</p>
<p>详细说明请参照<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/blpop.html">BLPOP 说明文档</a>，<code>BZPOPMIN</code>适用有序集合类型的key，BLPOP适用列表类型的key，除此之外，两条命令无其他差别。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL zset1 zset2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD zset1 0 a 1 b 2 c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; BZPOPMIN zset1 zset2 0</span><br><span class="line">1) <span class="string">&quot;zet1&quot;</span></span><br><span class="line">2) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CLUSTER命令"><a href="#CLUSTER命令" class="headerlink" title="CLUSTER命令"></a>CLUSTER命令</h2><ul>
<li><p>CLUSTER ADDSLOTS</p>
<p>命令介绍：这个命令是用于修改某个节点上的集群配置。具体的说它把一组hash slots分配给接收命令的节点。 如果命令执行成功，节点将指定的hash slots映射到自身，节点将获得指定的hash slots，同时开始向集群广播新的配置。</p>
<p>需要注意：</p>
<ul>
<li>该命令只有当所有指定的slots在接收命令的节点上还没有分配得的情况下生效。节点将 拒绝接纳已经分配到其他节点的slots（包括它自己的）。<ol>
<li>同一个slot被指定多次的情况下命令会失败。</li>
<li>执行这个命令有一个副作用，如果slot作为其中一个参数设置为<code>importing</code>，一旦节点向自己分配该slot（以前未绑定）这个状态将会被清除。</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER ADDSLOTS 1 2 3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER COUNT FAILURE REPORTS</p>
<p>命令介绍：这个命令返回指定节点的<strong>故障报告</strong>个数，故障报告是Redis Cluster用来使节点的<code>PFAIL</code>状态（这意味着节点不可达）晋升到<code>FAIL</code>状态而的方式，这意味着集群中大多数的主节点在一个事件窗口内同意节点不</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER COUNTKEYSINSLOT</p>
<p>命令介绍：返回连接节点负责的指定hash slot的key的数量。该命令只查询连接节点的数据集，所以如果连接节点指派到该hash slot会返回0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER COUNTKEYSINSLOT 7000</span><br><span class="line">(<span class="built_in">integer</span>) 50341</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER DELSLOTS</p>
<p>命令介绍：在Redis Cluster中，每个节点都会知道哪些主节点正在负责哪些特定的哈希槽</p>
<p><code>DELSLOTS</code>命令使一个特定的Redis Cluster节点去忘记一个主节点正在负责的哈希槽，这些哈希槽通过参数指定。</p>
<p>在已经接收到<code>DELSLOTS</code>命令的节点环境中，并且因此已经去除了指定哈希槽的关联，我们认为这些哈希槽是<strong>未绑定的</strong> 。请注意，当一个节点还没有被配置去负责他们（可以通过<code>ADDSLOTS</code>完成槽的分配）并且如果该节点没有收到关于谁拥有这些哈希槽的消息时（节点通过心跳包或者更新包获取消息），这些未绑定的哈希槽是自然而然本来就存在的。</p>
<p>如果一个节点认为一些哈希槽是未绑定的，但是从其他节点接收到一个心跳包，得知这些哈希槽已经被其他节点负责，那么会立即确立其关联关系。而且，如果接收到一个心跳包或更新包的配置纪元比当前节点的大，那么会重新建立关联。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER DELSLOTS 5000 5001</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER FAILOVER</p>
<p>命令介绍：该命令只能在群集slave节点执行，让slave节点进行一次人工故障切换。</p>
<p>人工故障切换是预期的操作，而非发生了真正的故障，目的是以一种安全的方式(数据无丢失)将当前master节点和其中一个slave节点(执行cluster-failover的节点)交换角色。 流程如下：</p>
<p>- 当前slave节点告知其master节点停止处理来自客户端的请求</p>
<p>- master 节点将当前<strong>replication offset</strong> 回复给该slave节点</p>
<p>- 该slave节点在未应用至replication offset之前不做任何操作，以保证master传来的数据均被处理。</p>
<p>- 该slave 节点进行故障转移，从群集中大多数的master节点获取epoch，然后广播自己的最新配置</p>
<p>- 原master节点收到配置更新:解除客户端的访问阻塞，回复重定向信息，以便客户端可以和新master通信。</p>
<p>当该slave节点(将切换为新master节点)处理完来自master的所有复制，客户端的访问将会自动由原master节点切换至新master节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER FORGET</p>
<p>命令介绍：该命令可以从收到命令的Redis群集节点的节点信息列表中移除指定ID的节点。 换句话说，从收到命令的Redis群集节点的<strong>nodes table</strong>中删除指定节点。</p>
<p>该命令不是将待删除节点的信息简单从内部配置中简单删除，它同时实现了禁止列表功能：不允许已删除 的节点再次被添加进来，否则已删除节点会因为处理其他节点心跳包中的<strong>gossip section</strong>时被再次添加。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER GETKEYSINSLOT</p>
<p>命令介绍：本命令返回存储在连接节点的指定hash slot里面的key的列表。key的最大数量通过<code>count</code>参数指定，所以这个API可以用作keys的批处理。</p>
<p>这个命令的主要是用于rehash期间slot从一个节点移动到另外一个节点。集群rehash的具体做法在Redis集群规范文档，或者你可以查询<code>CLUSTER SETSLOT</code>命令文档的附录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER GETKEYSINSLOT 7000 3</span><br><span class="line"><span class="string">&quot;47344|273766|70329104160040|key_39015&quot;</span></span><br><span class="line"><span class="string">&quot;47344|273766|70329104160040|key_89793&quot;</span></span><br><span class="line"><span class="string">&quot;47344|273766|70329104160040|key_92937&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER INFO</p>
<p>命令介绍：<code>CLUSTER INFO</code> 命令使用 <code>INFO</code> 风格的形式展现了关于Redis集群的重要参数。下面是该命令的典型输出，后面是对每个输出项的说明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:2</span><br><span class="line">cluster_stats_messages_sent:1483972</span><br><span class="line">cluster_stats_messages_received:1483968</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER KEYSLOT</p>
<p>命令介绍：返回一个整数，用于标识指定键所散列到的哈希槽。该命令主要用来调试和测试，因为它通过一个API来暴露Redis底层哈希算法的实现。该命令的使用示例：</p>
<p>- 客户端库可能会使用Redis来测试他们自己的哈希算法，生成随机的键并且使用他们自己实现的算法和Redis的<code>CLUSTER KEYSLOT</code>命令来散列这些键，然后检查结果是否相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER KEYSLOT somekey</span><br><span class="line">11058</span><br><span class="line">&gt; CLUSTER KEYSLOT foo&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br><span class="line">&gt; CLUSTER KEYSLOT bar&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER MEET</p>
<p>命令介绍：<code>CLUSTER MEET</code>命令被用来连接不同的开启集群支持的 Redis 节点，以进入工作集群。</p>
<p>基本的思想是每个节点默认都是相互不信任的，并且被认为是未知的节点，以便万一因为系统管理错误或地址被修改，而不太可能将多个不同的集群节点混成一个集群。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER NODES</p>
<p>命令介绍：集群中的每个节点都有当前集群配置的一个视图（快照），视图的信息由该节点所有已知节点提供，包括与每个节点的连接状态，每个节点的标记位（flags)，属性和已经分配的哈希槽等等。</p>
<p><code>CLUSTER NODES</code>提供了当前连接节点所属集群的配置信息，信息格式和Redis集群在磁盘上存储使用的序列化格式完全一样（在磁盘存储信息的结尾还存储了一些额外信息）.</p>
<p>通常，如果你想知道哈希槽与节点的关联关系，你应该使用<code>CLUSTER SLOTS</code> 命令。<code>CLUSTER NODES</code>主要是用于管理任务，调试和配置监控。<code>redis-trib</code>也会使用该命令管理集群.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER REPLICAS</p>
<p>命令介绍：该命令会列出指定主节点的辅助副本节点，输出格式同命令<code>CLUSTER NODES</code>(格式说明请参阅说明文档)</p>
<p>若特定节点状态未知，或在接收命令节点的节点信息表中，该节点不是主节点，则命令失败</p>
<p>请注意，当已经添加，迁移或者删除一个副本时，在群集中未及时更新配置信息的节点上执行<code>CLUSTER REPLICAS</code>命令，仍返回原有配置信息。 当然，所有节点最终将会同步群集中其他节点的信息(网络正常情况下，需要几秒钟时间)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER REPLICATE</p>
<p>命令介绍：该命令重新配置一个节点成为指定master的salve节点。 如果收到命令的节点是一个<strong>empty master</strong>，那么该节点的角色将由master切换为slave。</p>
<p>一旦一个节点变成另一个master节点的slave，无需通知群集内其他节点这一变化：节点间交换 信息的心跳包会自动将新的配置信息分发至所有节点。</p>
<p>基于如下假设，一个slave节点会接受该命令</p>
<p>- 指定节点在它的节点信息表中存在</p>
<p>- 指定节点无法识别接收我们命令的节点实例</p>
<p>- 指定节点是一个master</p>
<p>如果收到命令的节点不是slave而是master，只要在如下情况下，命令才会执行成功，该节点才会切换为slave：</p>
<p>- 该节点不保存任何hash槽</p>
<p>- 该节点是空的，key空间中不存储任何键</p>
<p>如果命令执行成功，新的slave会立即尝试连接它的master以便进行数据复制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER RESET</p>
<p>命令介绍：根据reset的类型配置<strong>hard</strong>或者<strong>soft</strong> ，Reset 一个Redis群集节点可以选择十分极端或极端的方式。 注意该命令在<strong>主节点hold住一个或多个keys的时候无效</strong>，在这种情况下，如果要彻底reset一个master， 需要将它的所有key先移除，如先使用<code>FLUSHALL</code>，在使用<code>CLUSTER RESET</code></p>
<p>节点上的效果如下：</p>
<p>- 群集中的节点都被忽略</p>
<p>- 所有已分派&#x2F;打开的槽会被reset，以便slots-to-nodes对应关系被完全清除</p>
<p>- 如果节点是slave，它会被切换为(空)master。它的数据集已被清空，因此最后也会变成一个空master。</p>
<ul>
<li><p>*<strong>*Hard reset only</strong>：生成新的节点ID</p>
</li>
<li><p><strong>Hard reset only</strong>：变量<code>currentEpoch</code> 和<code>configEpoch</code>被设置为0</p>
</li>
</ul>
<p>- 新配置被持久化到节点磁盘上的群集配置信息文件中</p>
<p>当需要为一个新的或不同的群集提供一个新的群集节点是可使用该命令，同时它也在Redis群集测试框架中被广泛使用，它用于 在每个新的测试单元启动是初始化群集状态。</p>
<p>如果reset类型没有指定，使用默认值<strong>soft</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER SAVECONFIG</p>
<p>命令介绍：强制保存配置<code>nodes.conf</code>至磁盘。</p>
<p>该命令主要用于<code>nodes.conf</code>节点状态文件丢失或被删除的情况下重新生成文件。当使用<code>CLUSTER</code>命令 对群集做日常维护时，该命令可以用于保证新生成的配置信息会被持久化到磁盘。当然，这类命令应该没定时调用 将配置信息持久化到磁盘，保证系统重启之后状态信息还是正确的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER SET CONFIG EPOCH</p>
<p>命令介绍：该命令为一个全新的节点设置指定的<strong>config epoch</strong>,仅在如下情况下有效：</p>
<p>- 节点的节点信息表为空</p>
<p>- 节点的当前<strong>config epoch</strong>为0</p>
<p>这些先决条件是需要的，因为通常情况下，人工修改一个节点的配置epoch是不安全的，我们想保证一点：在 获取哈希槽的所有权时，拥有更高配置epoch值的节点获胜。</p>
<p>但是该规则也有一个例外，在群集创建的时候，Redis群集<strong>配置epoch冲突解决</strong>算法会解决 群集启动时新的节点配置成相同配置epoch的问题，但是这个处理过程很慢,为了保证不管发生任何情况，都不会有两个节点拥有相同的配置epoch。</p>
<p>因此，当一个新群集创建的时候，使用命令<code>CONFIG SET-CONFIG-EPOCH</code>为每个一个节点分派渐进的配置epoch，然后再加入群集。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER SETSLOT</p>
<p>命令介绍：<code>CLUSTER SETSLOT</code> 根据如下子命令选项，修改接受节点中哈希槽的状态：</p>
<ol>
<li><code>MIGRATING</code> 子命令：将一个哈希槽设置为<strong>migrating</strong> 状态</li>
</ol>
<p>. <code>IMPORTING</code> 子命令：将一个哈希槽设置为<strong>importing</strong> 状态</p>
<ul>
<li><p><code>STABLE</code> 子命令：从哈希槽中清除导入和迁移状态</p>
</li>
<li><p><code>NODE</code> 子命令：将一个哈希槽绑定到另一个不同的节点</p>
</li>
</ul>
<p>该命令和子命令选项可以用来启动和结束一个群集重新哈希槽的操作，操作期间备操作哈希槽会在源节点被设置为迁移中状态，目标节点设置为导入中状态 每个子命令详细如下，文章末尾会有使用该命令以及其他相关命令实现实时重新哈希操作的说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER SLAVES</p>
<p>命令介绍：该命令会列出指定master节点所有slave节点，格式同<code>CLUSTER NODES</code>(详见指定格式说明文档)</p>
<p>当指定节点未知或者根据接收命令的节点的节点信息表指定节点不是主节点，命令执行错误。</p>
<p>注意：当一个slave被添加，移动或者删除时，我们在一个配置信息没有更新的群集节点上执行命令<code>CLUSTER SLAVES</code>获取将是脏信息。 不过最终(无网络分区的情况下大概几秒钟)所有节点都会同步指定master节点的salve节点信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CLUSTER SLOTS</p>
<p>命令介绍：<code>CLUSTER SLOTS</code>命令返回哈希槽和Redis实例映射关系。这个命令对客户端实现集群功能非常有用，使用这个命令可以获得<strong>哈希槽</strong>与节点（由IP和端口组成）的映射关系，这样，当客户端收到（用户的）调用命令时，可以根据（这个命令）返回的信息将命令发送到正确的Redis实例.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7001&gt; cluster slots</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 0</span><br><span class="line">   2) (<span class="built_in">integer</span>) 4095</span><br><span class="line">   3) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7000</span><br><span class="line">   4) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7004</span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 12288</span><br><span class="line">   2) (<span class="built_in">integer</span>) 16383</span><br><span class="line">   3) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7003</span><br><span class="line">   4) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7007</span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 4096</span><br><span class="line">   2) (<span class="built_in">integer</span>) 8191</span><br><span class="line">   3) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7001</span><br><span class="line">   4) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7005</span><br><span class="line">4) 1) (<span class="built_in">integer</span>) 8192</span><br><span class="line">   2) (<span class="built_in">integer</span>) 12287</span><br><span class="line">   3) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7002</span><br><span class="line">   4) 1) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      2) (<span class="built_in">integer</span>) 7006</span><br></pre></td></tr></table></figure>
</li>
<li><p>READONLY</p>
<p>命令介绍：开启与 Redis Cluster 从节点连接的读请求</p>
<p>通常，从节点将重定向客户端到认证过的主节点，以获取在指定命令中所涉及的哈希槽，然而客户端能通过<code>READONLY</code>命令将从节点设置为只读模式。</p>
<p><code>READONLY</code>告诉 Redis Cluster 从节点客户端愿意读取可能过时的数据并且对写请求不感兴趣。</p>
<p>当连接处于只读模式，只有操作涉及到该从节点的主节点不服务的键时，集群将会发送一个重定向给客户端。这可能是因为：</p>
<p>- 客户端发送一个有关这个从节点的主节点不服务哈希槽的命令。</p>
<p>- 集群被重新配置（例如重新分片）并且从节点不在服务给定哈希槽的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>READWRITE</p>
<p>命令介绍：禁止与Redis Cluster从节点连接的读请求。</p>
<p>默认情况下禁止Redis Cluster从节点的读请求，但是可以使用<code>READONLY</code>去在每个连接的基础上改变这个行为，<code>READWRITE</code>命令将连接的只读模式重置为读写模式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GENERIC命令"><a href="#GENERIC命令" class="headerlink" title="GENERIC命令"></a>GENERIC命令</h2><ul>
<li><p>DEL</p>
<p>命令介绍：删除指定的一批keys，如果删除中的某些key不存在，则直接忽略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SET key2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; DEL key1 key2 key3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>DUMP</p>
<p>命令介绍：序列化给定 key ，并返回被序列化的值，使用 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/restore">RESTORE</a> 命令可以将这个值反序列化为 Redis 键。</p>
<p>序列化生成的值有以下几个特点：</p>
<ul>
<li>它带有 64 位的校验和，用于检测错误，<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/restore">RESTORE</a> 在进行反序列化之前会先检查校验和。</li>
<li>值的编码格式和 RDB 文件保持一致。</li>
<li>RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</li>
</ul>
<p>序列化的值不包括任何生存时间信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey 10</span><br><span class="line">OK</span><br><span class="line">redis&gt; DUMP mykey</span><br><span class="line"><span class="string">&quot;\u0000\xC0\n\u0006\u0000\xF8r?\xC5\xFB\xFB_(&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>EXISTS</p>
<p>命令介绍：返回key是否存在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXISTS key1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; EXISTS key2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>EXPIRE</p>
<p>命令介绍：设置<code>key</code>的过期时间，超过时间后，将会自动删除该<code>key</code>。在Redis的术语中一个<code>key</code>的相关超时是不确定的。</p>
<p>超时后只有对<code>key</code>执行<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/del.html">DEL</a>命令或者<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/set.html">SET</a>命令或者<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/getset.html">GETSET</a>时才会清除。 这意味着，从概念上讲所有改变<code>key</code>的值的操作都会使他清除。 例如，<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/incr.html">INCR</a>递增key的值，执行<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/lpush.html">LPUSH</a>操作，或者用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/hset.html">HSET</a>改变hash的<code>field</code>所有这些操作都会触发删除动作。</p>
<p>使用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/persist.html">PERSIST</a>命令可以清除超时，使其变成一个永久的<code>key</code>。</p>
<p>如果<code>key</code>被<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/rename.html">RENAME</a>命令修改，相关的超时时间会转移到新<code>key</code>上面。</p>
<p>如果<code>key</code>被<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/rename.html">RENAME</a>命令修改，比如原来就存在<code>Key_A</code>,然后调用<code>RENAME Key_B Key_A</code>命令，这时不管原来<code>Key_A</code>是永久的还是设置为超时的，都会由<code>Key_B</code>的有效期状态覆盖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE mykey 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>EXPIREAT</p>
<p>命令介绍：<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/expireat.html">EXPIREAT</a> 的作用和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/expire.html">EXPIRE</a>类似，都用于为 key 设置生存时间。不同在于 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/expireat.html">EXPIREAT</a> 命令接受的时间参数是 UNIX 时间戳 Unix timestamp </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXISTS mykey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; EXPIREAT mykey 1293840000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; EXISTS mykey</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>KEYS</p>
<p>命令介绍：查找所有符合给定模式pattern（正则表达式）的 key 。</p>
<p>时间复杂度为O(N)，N为数据库里面key的数量。</p>
<p>例如，Redis在一个有1百万个key的数据库里面执行一次查询需要的时间是40毫秒 。</p>
<p><strong>警告</strong>: <code>KEYS</code> 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 <code>KEYS</code>， 你最好还是用 Redis 的集合结构 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sets.html">SETS</a> 来代替。</p>
<p>支持的正则表达模式：</p>
<ul>
<li><code>h?llo</code> 匹配 <code>hello</code>, <code>hallo</code> 和 <code>hxllo</code></li>
<li><code>h*llo</code> 匹配 <code>hllo</code> 和 <code>heeeello</code></li>
<li><code>h[ae]llo</code> 匹配 <code>hello</code> 和 <code>hallo,</code> 但是不匹配 <code>hillo</code></li>
<li><code>h[^e]llo</code> 匹配 <code>hallo</code>, <code>hbllo</code>, … 但是不匹配 <code>hello</code></li>
<li><code>h[a-b]llo</code> 匹配 <code>hallo</code> 和 <code>hbllo</code></li>
</ul>
<p>如果你想取消字符的特殊匹配（正则表达式，可以在它的前面加<code>\</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET one 1 two 2 three 3 four 4</span><br><span class="line">OK</span><br><span class="line">redis&gt; KEYS *o*</span><br><span class="line">1) <span class="string">&quot;four&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; KEYS t??</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt; KEYS *</span><br><span class="line">1) <span class="string">&quot;four&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;two&quot;</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MIGRATE</p>
<p>命令介绍：将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</p>
<p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</p>
<p>命令的内部实现是这样的：它在当前实例对给定 key 执行 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/dump.html">DUMP</a> 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/restore.html">RESTORE</a> 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/restore.html">RESTORE</a> 命令返回 OK ，它就会调用 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/del.html">DEL</a> 删除自己数据库上的 <code>key</code> 。</p>
<p>timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</p>
<p><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/migrate.html">MIGRATE</a> 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： <code>IOERR</code> 。</p>
<p>当 <code>IOERR</code> 出现时，有以下两种可能：</p>
<ul>
<li><code>key</code> 可能存在于两个实例。</li>
<li><code>key</code> 可能只存在于当前实例。</li>
</ul>
<p>唯一不可能发生的情况就是丢失 <code>key</code> ，因此，如果一个客户端执行 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/migrate.html">MIGRATE</a>, 命令，并且不幸遇上 <code>IOERR</code> 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</p>
<p>如果有其他错误发生，那么 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/migrate.html">MIGRATE</a> 保证 <code>key</code> 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 <code>key</code> 同名的键，不过这和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/migrate.html">MIGRATE</a> 命令没有关系）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MOVE</p>
<p>命令介绍：将当前数据库的 key 移动到给定的数据库 db 当中。</p>
<p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</p>
<p>因此，也可以利用这一特性，将 <code>MOVE</code> 当作锁(locking)原语(primitive)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>OBJECT</p>
<p>命令介绍：<code>OBJECT</code> 命令可以在内部调试(debugging)给出keys的内部对象，它用于检查或者了解你的keys是否用到了特殊编码 的数据类型来存储空间z。 当redis作为缓存使用的时候，你的应用也可能用到这些由<code>OBJECT</code>命令提供的信息来决定应用层的key的驱逐策略(eviction policies)</p>
<p><code>OBJECT</code> 支持多个子命令:</p>
<ul>
<li>OBJECT REFCOUNT 该命令主要用于调试(debugging)，它能够返回指定key所对应value被引用的次数.</li>
<li>OBJECT ENCODING 该命令返回指定key对应value所使用的内部表示(representation)(译者注：也可以理解为数据的压缩方式).</li>
<li>OBJECT IDLETIME 该命令返回指定key对应的value自被存储之后空闲的时间，以秒为单位(没有读写操作的请求) ，这个值返回以10秒为单位的秒级别时间，这一点可能在以后的实现中改善</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; lpush mylist <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis&gt; object refcount mylist</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; object encoding mylist</span><br><span class="line"><span class="string">&quot;ziplist&quot;</span></span><br><span class="line">redis&gt; object idletime mylist</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>PERSIST</p>
<p>命令介绍：移除给定key的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE mykey 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">redis&gt; PERSIST mykey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>PEXPIRE</p>
<p>命令介绍：这个命令和<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/expire.html">EXPIRE</a>命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/expire.html">EXPIRE</a>命令那样，以秒为单位。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; PEXPIRE mykey 1500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; PTTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 1499</span><br><span class="line">redis&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>PEXPIREAT</p>
<p>命令介绍：<code>PEXPIREAT</code> 这个命令和<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/expireat.html">EXPIREAT</a>命令类似，但它以毫秒为单位设置 key 的过期 <code>unix</code> 时间戳，而不是像<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/expireat.html">EXPIREAT</a>那样，以秒为单位。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; PEXPIREAT mykey 1555555555005</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 192569170</span><br><span class="line">redis&gt; PTTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 192569169649</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>PTTL</p>
<p>命令介绍：这个命令类似于<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/ttl.html">TTL</a>命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/ttl.html">TTL</a>命令那样，以秒为单位。</p>
<p>在Redis 2.6和之前版本，如果key不存在或者key存在且无过期时间将返回<code>-1</code>。</p>
<p>从 Redis 2.8开始，错误返回值发送了如下变化：</p>
<ul>
<li>如果key不存在返回<code>-2</code></li>
<li>如果key存在且无过期时间返回<code>-1</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE mykey 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; PTTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 999</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>RANDOMKEY</p>
<p>命令介绍：从当前数据库返回一个随机的key。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>RENAME</p>
<p>命令介绍：将key重命名为newkey，如果key与newkey相同，将返回一个错误。如果newkey已经存在，则值将被覆盖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; RENAME mykey myotherkey</span><br><span class="line">OK</span><br><span class="line">redis&gt; GET myotherkey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>RENAMENX</p>
<p>命令介绍：当且仅当 newkey 不存在时，将 key 改名为 newkey 。</p>
<p>当 key 不存在时，返回一个错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SET myotherkey <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; RENAMENX mykey myotherkey</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GET myotherkey</span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>RESTORE</p>
<p>命令介绍：反序列化给定的序列化值，并将它和给定的 key 关联。</p>
<p>参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</p>
<p><code>RESTORE</code> 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">edis&gt; DEL mykey</span><br><span class="line">0</span><br><span class="line">redis&gt; RESTORE mykey 0 <span class="string">&quot;\n\x17\x17\x00\x00\x00\x12\x00\x00\x00\x03\x00\</span></span><br><span class="line"><span class="string">                        x00\xc0\x01\x00\x04\xc0\x02\x00\x04\xc0\x03\x00\</span></span><br><span class="line"><span class="string">                        xff\x04\x00u#&lt;\xc0;.\xe9\xdd&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; TYPE mykey</span><br><span class="line">list</span><br><span class="line">redis&gt; LRANGE mykey 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SORT</p>
<p>命令介绍：返回或存储<code>key</code>的<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/data-types#lists">list</a>、 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/data-types#set">set</a> 或<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/data-types#sorted-sets">sorted set</a> 中的元素。默认是按照数值类型排序的，并且按照两个元素的双精度浮点数类型值进行比较。下面是<code>SORT</code>的最简形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT mylist</span><br></pre></td></tr></table></figure>
</li>
<li><p>TTL</p>
<p>命令介绍：返回key剩余的过期时间。 这种反射能力允许Redis客户端检查指定key在数据集里面剩余的有效期。</p>
<p>在Redis 2.6和之前版本，如果key不存在或者已过期时返回<code>-1</code>。</p>
<p>从Redis2.8开始，错误返回值的结果有如下改变：</p>
<ul>
<li>如果key不存在或者已过期，返回 <code>-2</code></li>
<li>如果key存在并且没有设置过期时间（永久有效），返回 <code>-1</code> 。</li>
</ul>
<p>另见<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/pttl.html">PTTL</a>命令返回相同的信息，只不过他的时间单位是毫秒（仅适用于Redis 2.6及更高版本）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE mykey 10 <span class="comment"># 设置mykey 10秒后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TTL mykey <span class="comment"># 查看mykey剩余的过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>TYPE</p>
<p>命令介绍：返回<code>key</code>所存储的<code>value</code>的数据结构类型，它可以返回<code>string</code>, <code>list</code>, <code>set</code>, <code>zset</code> 和 <code>hash</code>等不同的类型。</p>
<p>返回值</p>
<p><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/protocol#simple-string-reply">simple-string-reply</a>: 返回当前<code>key</code>的数据类型，如果<code>key</code>不存在时返回<code>none</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;value&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; LPUSH key2 <span class="string">&quot;value&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SADD key3 <span class="string">&quot;value&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TYPE key1</span><br><span class="line">string</span><br><span class="line">redis&gt; TYPE key2</span><br><span class="line">list</span><br><span class="line">redis&gt; TYPE key3</span><br><span class="line"><span class="built_in">set</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>WAIT</p>
<p>命令介绍：此命令阻塞当前客户端，直到所有以前的写命令都成功的传输和指定的slaves确认。如果超时，指定以毫秒为单位，即使指定的slaves还没有到达，命令任然返回。</p>
<p>命令<strong>始终返回</strong>之前写命令发送的slaves的数量，无论是在指定slaves的情况还是达到超时。</p>
<p>注意点:</p>
<ol>
<li>当’WAIT’返回时，所有之前的写命令保证接收由<code>WAIT</code>返回的slaves的数量。</li>
<li>如果命令呗当做事务的一部分发送，该命令不阻塞，而是只尽快返回先前写命令的slaves的数量。</li>
<li>如果timeout是0那意味着永远阻塞。</li>
<li>由于<code>WAIT</code>返回的是在失败和成功的情况下的slaves的数量。客户端应该检查返回的slaves的数量是等于或更大的复制水平。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET foo bar</span><br><span class="line">OK</span><br><span class="line">&gt; WAIT 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; WAIT 2 1000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>SCAN</p>
<p>命令介绍：<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/scan.html">SCAN</a> 命令及其相关的 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sscan.html">SSCAN</a>, <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/hscan.html">HSCAN</a> 和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zscan.html">ZSCAN</a> 命令都用于增量迭代一个集合元素。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/scan.html">SCAN</a> 命令用于迭代当前数据库中的key集合。</li>
<li><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sscan.html">SSCAN</a> 命令用于迭代SET集合中的元素。</li>
<li><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/hscan.html">HSCAN</a> 命令用于迭代Hash类型中的键值对。</li>
<li><a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zscan.html">ZSCAN</a> 命令用于迭代SortSet集合中的元素和元素对应的分值</li>
</ul>
<p>以上列出的四个命令都支持增量式迭代，它们每次执行都只会返回少量元素，所以这些命令可以用于生产环境，而不会出现像 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/keys.html">KEYS</a> 或者 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/smembers.html">SMEMBERS</a> 命令带来的可能会阻塞服务器的问题。</p>
<p>不过，<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/smembers.html">SMEMBERS</a> 命令可以返回集合键当前包含的所有元素， 但是对于SCAN这类增量式迭代命令来说，有可能在增量迭代过程中，集合元素被修改，对返回值无法提供完全准确的保证。</p>
<p>因为 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/scan.html">SCAN</a>, <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sscan.html">SSCAN</a>, <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/hscan.html">HSCAN</a> 和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zscan.html">ZSCAN</a> 四个命令的工作方式都非常相似， 所以这个文档会一并介绍这四个命令，需要注意的是<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/sscan.html">SSCAN</a>, <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/hscan.html">HSCAN</a> ,<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/zscan.html">ZSCAN</a>命令的第一个参数总是一个key； <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/scan.html">SCAN</a> 命令则不需要在第一个参数提供任何key，因为它迭代的是当前数据库中的所有key。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) <span class="string">&quot;17&quot;</span></span><br><span class="line">2)  1) <span class="string">&quot;key:12&quot;</span></span><br><span class="line">    2) <span class="string">&quot;key:8&quot;</span></span><br><span class="line">    3) <span class="string">&quot;key:4&quot;</span></span><br><span class="line">    4) <span class="string">&quot;key:14&quot;</span></span><br><span class="line">    5) <span class="string">&quot;key:16&quot;</span></span><br><span class="line">    6) <span class="string">&quot;key:17&quot;</span></span><br><span class="line">    7) <span class="string">&quot;key:15&quot;</span></span><br><span class="line">    8) <span class="string">&quot;key:10&quot;</span></span><br><span class="line">    9) <span class="string">&quot;key:3&quot;</span></span><br><span class="line">   10) <span class="string">&quot;key:7&quot;</span></span><br><span class="line">   11) <span class="string">&quot;key:1&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;key:5&quot;</span></span><br><span class="line">   2) <span class="string">&quot;key:18&quot;</span></span><br><span class="line">   3) <span class="string">&quot;key:0&quot;</span></span><br><span class="line">   4) <span class="string">&quot;key:2&quot;</span></span><br><span class="line">   5) <span class="string">&quot;key:19&quot;</span></span><br><span class="line">   6) <span class="string">&quot;key:13&quot;</span></span><br><span class="line">   7) <span class="string">&quot;key:6&quot;</span></span><br><span class="line">   8) <span class="string">&quot;key:9&quot;</span></span><br><span class="line">   9) <span class="string">&quot;key:11&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TRANSACTIONS命令"><a href="#TRANSACTIONS命令" class="headerlink" title="TRANSACTIONS命令"></a>TRANSACTIONS命令</h2><ul>
<li><p>DISCARD</p>
<p>命令介绍：刷新一个事务中所有在排队等待的指令，并且将连接状态恢复到正常。</p>
<p>如果已使用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/watch.html">WATCH</a>，<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/discard.html">DISCARD</a>将释放所有被<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/watch.html">WATCH</a>的key。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>EXEC</p>
<p>命令介绍：执行事务中所有在排队等待的指令并将链接状态恢复到正常 当使用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/watch.html">WATCH</a> 时，只有当被监视的键没有被修改，且允许检查设定机制时，EXEC会被执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MULTI</p>
<p>命令介绍：标记一个事务块的开始。 随后的指令将在执行<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/exec.html">EXEC</a>时作为一个原子执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>UNWATCH</p>
<p>命令介绍：刷新一个事务中已被监视的所有key。</p>
<p>如果执行<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/exec.html">EXEC</a> 或者<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/discard.html">DISCARD</a>， 则不需要手动执行<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/unwatch.html">UNWATCH</a> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>WATCH</p>
<p>命令介绍：标记所有指定的key 被监视起来，在事务中有条件的执行（乐观锁）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SCRIPTING命令"><a href="#SCRIPTING命令" class="headerlink" title="SCRIPTING命令"></a>SCRIPTING命令</h2><ul>
<li><p>EVAL</p>
<p>命令介绍：EVAL 和 EVALSHA 命令是从 Redis 2.6.0 版本开始的，使用内置的 Lua 解释器，可以对 Lua 脚本进行求值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> 2 key1 key2 first second</span><br><span class="line">1) <span class="string">&quot;key1&quot;</span></span><br><span class="line">2) <span class="string">&quot;key2&quot;</span></span><br><span class="line">3) <span class="string">&quot;first&quot;</span></span><br><span class="line">4) <span class="string">&quot;second&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>EVALSHA</p>
<p>命令介绍：根据给定的 SHA1 校验码，对缓存在服务器中的脚本进行求值。 将脚本缓存到服务器的操作可以通过 SCRIPT LOAD 命令进行。 这个命令的其他地方，比如参数的传入方式，都和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/eval.html">EVAL</a>命令一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SCRIPT DEBUG</p>
<p>命令介绍：使用<code>EVAL</code>可以开启对脚本的调试。Redis包含完整Lua Debugger和codename LDB，这大大降低了复杂脚本编写的难度。 在调试模式下，Redis 既做调试服务器又做客户端，像<code>redis-cli</code> 可以单步执行，设置断点，观察变量等等，更多 LDB信息参见<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/ldb.html">Redis Lua debugger</a></p>
<p><strong>注意</strong>：使用开发环境Redis服务器调试Lua脚本，避免在生产环境Redis服务器调试。</p>
<p>LDB可以设置成两种模式：同步和异步。异步模式下，服务器会创建新的调试连接，不阻塞其他连接，同时在调试连接结束后会回滚所有的数据修改， 这可以保证再次调试时初始状态不变。同步模式下，调试过程中，服务器其他连接会被阻塞，当调试结束后，所有的数据修改会被保存。</p>
<ul>
<li><code>YES</code>. 打开非阻塞异步调试模式，调试Lua脚本(回退数据修改)</li>
<li><code>SYNC</code>. 打开阻塞同步调试模式，调试Lua脚本(保留数据修改稿) -<code>NO</code>. 关闭脚本调试模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SCRIPT EXISTS</p>
<p>命令介绍：检查脚本是否存在脚本缓存里面。</p>
<p>这个命令可以接受一个或者多个脚本SHA1信息，返回一个1或者0的列表，如果脚本存在或不存在。</p>
<p>还可以使用管道技术（pipelining operation）确保脚本加载（也可以使用<code>SCRIPT LOAD</code>）， 管道技术可以单独使用<code>EVALSHA</code>来代替<code>EVAL</code>，从而节省带宽（bandwidth）。</p>
<p>更多细节信息请参考<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/eval.html">EVAL</a>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SCRIPT FLUSH</p>
<p>命令介绍：清空Lua脚本缓存 Flush the Lua scripts cache.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SCRIPT KILL</p>
<p>命令介绍：杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。</p>
<p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p>
<p><code>SCRIPT KILL</code> 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/eval.html">EVAL</a> 命令的阻塞当中退出，并收到一个错误作为返回值。</p>
<p>另一方面，假如当前正在运行的脚本已经执行过写操作，那么即使执行 <code>SCRIPT KILL</code> ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 <code>SHUTDOWN NOSAVE</code> 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SCRIPT LOAD</p>
<p>命令介绍：将脚本 script 添加到脚本缓存中，但并不立即执行该脚本。在脚本被加入到缓存之后，通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。 EVAL 命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。</p>
<p>脚本可以在缓存中保留无限长的时间(直到执行 SCRIPT FLUSH 为止) 如果给定的脚本已经在缓存里面了，那么不做动作。</p>
<p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL 命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GEO命令"><a href="#GEO命令" class="headerlink" title="GEO命令"></a>GEO命令</h2><ul>
<li><p>GEOADD</p>
<p>命令介绍：将指定的地理空间位置（纬度、经度、名称）添加到指定的<code>key</code>中。这些数据将会存储到<code>sorted set</code>这样的目的是为了方便使用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/georadius.html">GEORADIUS</a>或者<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/georadiusbymember.html">GEORADIUSBYMEMBER</a>命令对数据进行半径查询等操作。</p>
<p>该命令以采用标准格式的参数x,y,所以经度必须在纬度之前。这些坐标的限制是可以被编入索引的，区域面积可以很接近极点但是不能索引。具体的限制，由EPSG:900913 &#x2F; EPSG:3785 &#x2F; OSGEO:41001 规定如下：</p>
<ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
<p>当坐标位置超出上述指定范围时，该命令将会返回一个错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">&quot;166274.15156960039&quot;</span></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 100 km</span><br><span class="line">1) <span class="string">&quot;Catania&quot;</span></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km</span><br><span class="line">1) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">2) <span class="string">&quot;Catania&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GEOHASH</p>
<p>命令介绍：该命令将返回11个字符的Geohash字符串，所以没有精度Geohash，损失相比，使用内部52位表示。返回的geohashes具有以下特性：</p>
<ol>
<li>他们可以缩短从右边的字符。它将失去精度，但仍将指向同一地区。</li>
<li>它可以在 <code>geohash.org</code> 网站使用，网址 <code>http://geohash.org/&lt;geohash-string&gt;</code>。查询例子：<a target="_blank" rel="noopener" href="http://geohash.org/sqdtr74hyu0">http://geohash.org/sqdtr74hyu0</a>.</li>
<li>与类似的前缀字符串是附近，但相反的是不正确的，这是可能的，用不同的前缀字符串附近。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line">1) <span class="string">&quot;sqc8b49rny0&quot;</span></span><br><span class="line">2) <span class="string">&quot;sqdtr74hyu0&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GEOPOS</p>
<p>命令介绍：从<code>key</code>里返回所有给定位置元素的位置（经度和纬度）。</p>
<p>给定一个sorted set表示的空间索引，密集使用 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/geoadd.html">geoadd</a> 命令，它以获得指定成员的坐标往往是有益的。当空间索引填充通过 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/geoadd.html">geoadd</a> 的坐标转换成一个52位Geohash，所以返回的坐标可能不完全以添加元素的，但小的错误可能会出台。</p>
<p>因为 <code>GEOPOS</code> 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; GEOPOS Sicily Palermo Catania NonExisting</span><br><span class="line">1) 1) <span class="string">&quot;13.361389338970184&quot;</span></span><br><span class="line">   2) <span class="string">&quot;38.115556395496299&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;15.087267458438873&quot;</span></span><br><span class="line">   2) <span class="string">&quot;37.50266842333162&quot;</span></span><br><span class="line">3) (nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GEODIST</p>
<p>命令介绍：返回两个给定位置之间的距离。</p>
<p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p>
<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用米作为单位。</p>
<p><code>GEODIST</code> 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">&quot;166274.15156960039&quot;</span></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania km</span><br><span class="line"><span class="string">&quot;166.27415156960038&quot;</span></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania mi</span><br><span class="line"><span class="string">&quot;103.31822459492736&quot;</span></span><br><span class="line">redis&gt; GEODIST Sicily Foo Bar</span><br><span class="line">(nil)</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GEORADIUS</p>
<p>命令介绍：以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST</span><br><span class="line">1) 1) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">   2) <span class="string">&quot;190.4424&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;Catania&quot;</span></span><br><span class="line">   2) <span class="string">&quot;56.4413&quot;</span></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD</span><br><span class="line">1) 1) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;13.361389338970184&quot;</span></span><br><span class="line">      2) <span class="string">&quot;38.115556395496299&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;Catania&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;15.087267458438873&quot;</span></span><br><span class="line">      2) <span class="string">&quot;37.50266842333162&quot;</span></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD</span><br><span class="line">1) 1) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">   2) <span class="string">&quot;190.4424&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;13.361389338970184&quot;</span></span><br><span class="line">      2) <span class="string">&quot;38.115556395496299&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;Catania&quot;</span></span><br><span class="line">   2) <span class="string">&quot;56.4413&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;15.087267458438873&quot;</span></span><br><span class="line">      2) <span class="string">&quot;37.50266842333162&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>GEORADIUSBYMEMBER</p>
<p>命令介绍：这个命令和 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/georadius.html">GEORADIUS</a> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/georadius.html">GEORADIUS</a> 那样， 使用输入的经度和纬度来决定中心点</p>
<p>指定成员的位置被用作查询的中心。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.583333 37.316667 <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km</span><br><span class="line">1) <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line">2) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HYPERLOGLOG命令"><a href="#HYPERLOGLOG命令" class="headerlink" title="HYPERLOGLOG命令"></a>HYPERLOGLOG命令</h2><ul>
<li><p>PFADD</p>
<p>命令介绍：将除了第一个参数以外的参数存储到以第一个参数为变量名的HyperLogLog结构中.</p>
<p>这个命令的一个副作用是它可能会更改这个HyperLogLog的内部来反映在每添加一个唯一的对象时估计的基数(集合的基数).</p>
<p>如果一个HyperLogLog的估计的近似基数在执行命令过程中发了变化， <a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/pfadd.html">PFADD</a> 返回1，否则返回0，如果指定的key不存在，这个命令会自动创建一个空的HyperLogLog结构（指定长度和编码的字符串）.</p>
<p>如果在调用该命令时仅提供变量名而不指定元素也是可以的，如果这个变量名存在，则不会有任何操作，如果不存在，则会创建一个数据结构（返回1）.</p>
<p>了解更多HyperLogLog数据结构，请查阅<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/pfcount.html">PFCOUNT</a>命令页面.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD hll a b c d e f g</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; PFCOUNT hll</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>PFCOUNT</p>
<p>命令介绍：当参数为一个key时,返回存储在HyperLogLog结构体的该变量的近似基数，如果该变量不存在,则返回0.</p>
<p>当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的.</p>
<p>HyperLogLog可以使用固定且很少的内存（每个HyperLogLog结构需要12K字节再加上key本身的几个字节）来存储集合的唯一元素.</p>
<p>返回的可见集合基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值.</p>
<p>例如为了记录一天会执行多少次各不相同的搜索查询， 一个程序可以在每次执行搜索查询时调用一次<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/pfadd.html">PFADD</a>， 并通过调用<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/pfcount.html">PFCOUNT</a>命令来获取这个记录的近似结果.</p>
<p>注意: 这个命令的一个副作用是可能会导致HyperLogLog内部被更改，出于缓存的目的,它会用8字节的来记录最近一次计算得到基数,所以<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/pfcount.html">PFCOUNT</a>命令在技术上是个写命令.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD hll foo bar zap</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; PFADD hll zap zap zap</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; PFADD hll foo bar</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; PFCOUNT hll</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; PFADD some-other-hll 1 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; PFCOUNT hll some-other-hll</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>PFMERGE</p>
<p>命令介绍：将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集.</p>
<p>合并得出的 HyperLogLog 会被储存在目标变量（第一个参数）里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD hll1 foo bar zap a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; PFADD hll2 a b c foo</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; PFMERGE hll3 hll1 hll2</span><br><span class="line">OK</span><br><span class="line">redis&gt; PFCOUNT hll3</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PUBSUB命令"><a href="#PUBSUB命令" class="headerlink" title="PUBSUB命令"></a>PUBSUB命令</h2><ul>
<li><p>PSUBSCRIBE</p>
<p>命令介绍：订阅给定的模式(patterns)。</p>
<p>支持的模式(patterns)有:</p>
<ul>
<li><code>h?llo</code> subscribes to <code>hello</code>, <code>hallo</code> and <code>hxllo</code></li>
<li><code>h*llo</code> subscribes to <code>hllo</code> and <code>heeeello</code></li>
<li><code>h[ae]llo</code> subscribes to <code>hello</code> and <code>hallo,</code> but not <code>hillo</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>PUBSUB</p>
<p>命令介绍：<code>PUBSUB</code> 是自省命令，能够检测PUB&#x2F;SUB子系统的状态。它由分别详细描述的子命令组成。通用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBSUB &lt;subcommand&gt; ... args ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>PUBLISH</p>
<p>命令介绍：将信息 message 发送到指定的频道 channel</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>PUNSUBSCRIBE</p>
<p>命令介绍：指示客户端退订指定模式，若果没有提供模式则退出所有模式。</p>
<p>如果没有模式被指定，即一个无参数的 PUNSUBSCRIBE 调用被执行，那么客户端使用 PSUBSCRIBE 命令订阅的所有模式都会被退订。 在这种情况下，命令会返回一个信息，告知客户端所有被退订的模式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>SUBSCRIBE</p>
<p>命令介绍：订阅给指定频道的信息。</p>
<p>一旦客户端进入订阅状态，客户端就只可接受订阅相关的命令<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/subscribe.html">SUBSCRIBE</a>、<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/psubscribe.html">PSUBSCRIBE</a>、<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/unsubscribe.html">UNSUBSCRIBE</a>和<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/commands/punsubscribe.html">PUNSUBSCRIBE</a>除了这些命令，其他命令一律失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>UNSUBSCRIBE</p>
<p>命令介绍：指示客户端退订给定的频道，若没有指定频道，则退订所有频道.</p>
<p>如果没有频道被指定，即，一个无参数的 UNSUBSCRIBE 调用被执行，那么客户端使用 SUBSCRIBE 命令订阅的所有频道都会被退订。 在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="KEYS命令"><a href="#KEYS命令" class="headerlink" title="KEYS命令"></a>KEYS命令</h2><ul>
<li><p>TOUCH</p>
<p>命令介绍：修改指定key(s) 最后访问时间 若key不存在，不做操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">redis&gt; SET key2 <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">redis&gt; TOUCH key1 key2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>UNLINK</p>
<p>命令介绍：该命令和<code>DEL</code>十分相似：删除指定的key(s),若key不存在则该key被跳过。但是，相比<code>DEL</code>会产生阻塞，该命令会在另一个线程中回收内存，因此它是非阻塞的。 这也是该命令名字的由来：仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">redis&gt; SET key2 <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">redis&gt; UNLINK key1 key2 key3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="STREAMS命令"><a href="#STREAMS命令" class="headerlink" title="STREAMS命令"></a>STREAMS命令</h2><ul>
<li><p>XACK</p>
<p>命令介绍：<code>XACK</code>命令用于从流的消费者组的<strong>待处理条目列表</strong>（简称PEL）中删除一条或多条消息。 当一条消息交付到某个消费者时，它将被存储在PEL中等待处理， 这通常出现在作为调用<code>XREADGROUP</code>命令的副作用，或者一个消费者通过调用<code>XCLAIM</code>命令接管消息的时候。 待处理消息被交付到某些消费者，但是服务器尚不确定它是否至少被处理了一次。 因此对新调用<code>XREADGROUP</code>来获取消费者的消息历史记录（比如用0作为ID）将返回此类消息。 类似地，待处理的消息将由检查PEL的<code>XPENDING</code>命令列出。</p>
<p>一旦消费者<strong>成功地</strong>处理完一条消息，它应该调用<code>XACK</code>，这样这个消息就不会被再次处理， 且作为一个副作用，关于此消息的PEL条目也会被清除，从Redis服务器释放内存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; XACK mystream mygroup 1526569495631-0</span><br><span class="line">ERR Unknown or disabled <span class="built_in">command</span> <span class="string">&#x27;XACK&#x27;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>XADD</p>
<p>命令介绍：将指定的流条目追加到指定key的流中。 如果key不存在，作为运行这个命令的副作用，将使用流的条目自动创建key。</p>
<p>一个条目是由一组键值对组成的，它基本上是一个小的字典。 键值对以用户给定的顺序存储，并且读取流的命令（如<code>XRANGE</code> 或者 <code>XREAD</code>） 可以保证按照通过<code>XADD</code>添加的顺序返回。</p>
<p><code>XADD</code>是<strong>唯一可以向流添加数据的Redis命令</strong>，但是还有其他命令， 例如<code>XDEL</code>和<code>XTRIM</code>，他们能够从流中删除数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; XADD mystream * name Sara surname OConnor</span><br><span class="line"><span class="string">&quot;1539863454486-0&quot;</span></span><br><span class="line">redis&gt; XADD mystream * field1 value1 field2 value2 field3 value3</span><br><span class="line"><span class="string">&quot;1539863454486-1&quot;</span></span><br><span class="line">redis&gt; XLEN mystream</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; XRANGE mystream - +</span><br><span class="line">1) 1) <span class="string">&quot;1539863454486-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;Sara&quot;</span></span><br><span class="line">      3) <span class="string">&quot;surname&quot;</span></span><br><span class="line">      4) <span class="string">&quot;OConnor&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1539863454486-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;value1&quot;</span></span><br><span class="line">      3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">      4) <span class="string">&quot;value2&quot;</span></span><br><span class="line">      5) <span class="string">&quot;field3&quot;</span></span><br><span class="line">      6) <span class="string">&quot;value3&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>XCLAIM</p>
<p>命令介绍：在流的消费者组上下文中，此命令改变待处理消息的所有权， 因此新的所有者是在命令参数中指定的消费者。通常是这样的：</p>
<ol>
<li>假设有一个具有关联消费者组的流。</li>
<li>某个消费者A在消费者组的上下文中通过<code>XREADGROUP</code>从流中读取一条消息。</li>
<li>作为读取消息的副作用，消费者组的待处理条目列表（PEL）中创建了一个待处理消息条目：这意味着这条消息已传递给给定的消费者，但是尚未通过<code>XACK</code>确认。</li>
<li>突然这个消费者出现故障，且永远无法恢复。</li>
<li>其他消费者可以使用<code>XPENDING</code>检查已经过时很长时间的待处理消息列表，为了继续处理这些消息，他们使用<code>XCLAIM</code>来获得消息的所有权，并继续处理。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; XCLAIM mystream mygroup Alice 3600000 1526569498055-0</span><br><span class="line">1) 1) 1526569498055-0</span><br><span class="line">   2) 1) <span class="string">&quot;message&quot;</span></span><br><span class="line">      2) <span class="string">&quot;orange&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XDEL</p>
<p>命令介绍：从指定流中移除指定的条目，并返回成功删除的条目的数量，在传递的ID不存在的情况下， 返回的数量可能与传递的ID数量不同。</p>
<p>通常，你可能将Redis流想象为一个仅附加的数据结构，但是Redis流是存在于内存中的， 所以我们也可以删除条目。这也许会有用，例如，为了遵守特定的隐私策略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; XADD mystream * a 1</span><br><span class="line">1538561698944-0</span><br><span class="line">&gt; XADD mystream * b 2</span><br><span class="line">1538561700640-0</span><br><span class="line">&gt; XADD mystream * c 3</span><br><span class="line">1538561701744-0</span><br><span class="line">&gt; XDEL mystream 1538561700640-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) 1538561698944-0</span><br><span class="line">   2) 1) <span class="string">&quot;a&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) 1) 1538561701744-0</span><br><span class="line">   2) 1) <span class="string">&quot;c&quot;</span></span><br><span class="line">      2) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XGROUP</p>
<p>命令介绍：该命令用于管理流数据结构关联的消费者组。使用<code>XGROUP</code>你可以：</p>
<ul>
<li>创建与流关联的新消费者组。</li>
<li>销毁一个消费者组。</li>
<li>从消费者组中移除指定的消费者。</li>
<li>将消费者组的<strong>最后交付ID</strong>设置为其他内容。</li>
</ul>
<p>要创建一个新的消费者组，请使用以下格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>XINFO</p>
<p>命令介绍：这是一个内省命令，用于检索关于流和关联的消费者组的不同的信息。有三种可能的形式：</p>
<ul>
<li><code>XINFO STREAM &lt;key&gt;</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; XINFO STREAM mystream</span><br><span class="line"> 1) length</span><br><span class="line"> 2) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 3) radix-tree-keys</span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 5) radix-tree-nodes</span><br><span class="line"> 6) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 7) <span class="built_in">groups</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 9) last-generated-id</span><br><span class="line">10) 1538385846314-0</span><br><span class="line">11) first-entry</span><br><span class="line">12) 1) 1538385820729-0</span><br><span class="line">    2) 1) <span class="string">&quot;foo&quot;</span></span><br><span class="line">       2) <span class="string">&quot;bar&quot;</span></span><br><span class="line">13) last-entry</span><br><span class="line">14) 1) 1538385846314-0</span><br><span class="line">    2) 1) <span class="string">&quot;field&quot;</span></span><br><span class="line">       2) <span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XLEN</p>
<p>命令介绍：返回流中的条目数。如果指定的key不存在，则此命令返回0，就好像该流为空。 但是请注意，与其他的Redis类型不同，零长度流是可能的，所以你应该调用<code>TYPE</code> 或者 <code>EXISTS</code> 来检查一个key是否存在。</p>
<p>一旦内部没有任何的条目（例如调用<code>XDEL</code>后），流不会被自动删除，因为可能还存在与其相关联的消费者组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; XADD mystream * item 1</span><br><span class="line"><span class="string">&quot;1539863829481-0&quot;</span></span><br><span class="line">redis&gt; XADD mystream * item 2</span><br><span class="line"><span class="string">&quot;1539863829482-0&quot;</span></span><br><span class="line">redis&gt; XADD mystream * item 3</span><br><span class="line"><span class="string">&quot;1539863829482-1&quot;</span></span><br><span class="line">redis&gt; XLEN mystream</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>XPENDING</p>
<p>命令介绍：通过消费者组从流中获取数据，而不是确认这些数据，具有创建<strong>待处理条目</strong>的效果。这在<code>XREADGROUP</code>命令中已有详尽的说明，在我们的<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/streams-intro.html">Redis Streams介绍</a>中更好。<code>XACK</code>命令会立即从待处理条目列表（PEL）中移除待处理条目，因为一旦消息被成功处理，消费者组就不再需要跟踪它并记住消息的当前所有者。</p>
<p><code>XPENDING</code>命令是检查待处理消息列表的接口，因此它是一个非常重要的命令，用于观察和了解消费者组正在发生的事情：哪些客户端是活跃的，哪些消息在等待消费，或者查看是否有空闲的消息。此外，该命令与<code>XCLAIM</code>一起使用，用于实现长时间故障的消费者的恢复，因此不处理某些消息：不同的消费者可以认领该消息并继续处理。这在<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/streams-intro.html">Redis Streams介绍</a>和<code>XCLAIM</code>命令页面中有更好的解释，这里不再介绍。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; XGROUP CREATE mystream group55 0-0</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; XREADGROUP GROUP group55 consumer-123 COUNT 1 STREAMS mystream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mystream&quot;</span></span><br><span class="line">   2) 1) 1) 1526984818136-0</span><br><span class="line">         2) 1) <span class="string">&quot;duration&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1532&quot;</span></span><br><span class="line">            3) <span class="string">&quot;event-id&quot;</span></span><br><span class="line">            4) <span class="string">&quot;5&quot;</span></span><br><span class="line">            5) <span class="string">&quot;user-id&quot;</span></span><br><span class="line">            6) <span class="string">&quot;7782813&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XRANGE</p>
<p>命令介绍：此命令返回流中满足给定ID范围的条目。范围由最小和最大ID指定。所有ID在指定的两个ID之间或与其中一个ID相等（闭合区间）的条目将会被返回。</p>
<p><code>XRANGE</code>命令有许多用途：</p>
<ul>
<li>返回特定时间范围的项目。这是可能的，因为流的ID<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/streams-intro.html">与时间相关</a>。</li>
<li>增量迭代流，每次迭代只返回几个项目。但它在语义上比<code>SCAN</code>函数族强大很多。</li>
<li>从流中获取单个条目，提供要获取两次的条目的ID：作为查询间隔的开始和结束。</li>
</ul>
<p>该命令还有一个倒序命令，以相反的顺序返回项目，叫做<code>XREVRANGE</code>，除了返回顺序相反以外，它们是完全相同的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; XRANGE somestream - +</span><br><span class="line">1) 1) 1526985054069-0</span><br><span class="line">   2) 1) <span class="string">&quot;duration&quot;</span></span><br><span class="line">      2) <span class="string">&quot;72&quot;</span></span><br><span class="line">      3) <span class="string">&quot;event-id&quot;</span></span><br><span class="line">      4) <span class="string">&quot;9&quot;</span></span><br><span class="line">      5) <span class="string">&quot;user-id&quot;</span></span><br><span class="line">      6) <span class="string">&quot;839248&quot;</span></span><br><span class="line">2) 1) 1526985069902-0</span><br><span class="line">   2) 1) <span class="string">&quot;duration&quot;</span></span><br><span class="line">      2) <span class="string">&quot;415&quot;</span></span><br><span class="line">      3) <span class="string">&quot;event-id&quot;</span></span><br><span class="line">      4) <span class="string">&quot;2&quot;</span></span><br><span class="line">      5) <span class="string">&quot;user-id&quot;</span></span><br><span class="line">      6) <span class="string">&quot;772213&quot;</span></span><br><span class="line">... other entries here ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>XREAD</p>
<p>命令介绍：从一个或者多个流中读取数据，仅返回ID大于调用者报告的最后接收ID的条目。此命令有一个阻塞选项，用于等待可用的项目，类似于<code>BRPOP</code>或者<code>BZPOPMIN</code>等等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; XREAD COUNT 2 STREAMS mystream writers 0-0 0-0</span><br><span class="line">1) 1) <span class="string">&quot;mystream&quot;</span></span><br><span class="line">   2) 1) 1) 1526984818136-0</span><br><span class="line">         2) 1) <span class="string">&quot;duration&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1532&quot;</span></span><br><span class="line">            3) <span class="string">&quot;event-id&quot;</span></span><br><span class="line">            4) <span class="string">&quot;5&quot;</span></span><br><span class="line">            5) <span class="string">&quot;user-id&quot;</span></span><br><span class="line">            6) <span class="string">&quot;7782813&quot;</span></span><br><span class="line">      2) 1) 1526999352406-0</span><br><span class="line">         2) 1) <span class="string">&quot;duration&quot;</span></span><br><span class="line">            2) <span class="string">&quot;812&quot;</span></span><br><span class="line">            3) <span class="string">&quot;event-id&quot;</span></span><br><span class="line">            4) <span class="string">&quot;9&quot;</span></span><br><span class="line">            5) <span class="string">&quot;user-id&quot;</span></span><br><span class="line">            6) <span class="string">&quot;388234&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;writers&quot;</span></span><br><span class="line">   2) 1) 1) 1526985676425-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;Virginia&quot;</span></span><br><span class="line">            3) <span class="string">&quot;surname&quot;</span></span><br><span class="line">            4) <span class="string">&quot;Woolf&quot;</span></span><br><span class="line">      2) 1) 1526985685298-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;Jane&quot;</span></span><br><span class="line">            3) <span class="string">&quot;surname&quot;</span></span><br><span class="line">            4) <span class="string">&quot;Austen&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XREADGROUP</p>
<p>命令介绍：<code>XREADGROUP</code>命令是<code>XREAD</code>命令的特殊版本，支持消费者组。在阅读本页之前，你可能必须先理解<code>XREAD</code>命令才有意义。</p>
<p>此外，如果你是Stream新手，我们建议阅读我们的<a target="_blank" rel="noopener" href="http://redis.jianyue.wiki/topics/streams-intro.html">Redis Streams简介</a>。 确保在介绍中理解消费者组的概念，以便遵循此命令的工作原理将更加简单。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>XREVRANGE</p>
<p>命令介绍：此命令与<code>XRANGE</code>完全相同，但显著的区别是以相反的顺序返回条目，并以相反的顺序获取开始-结束参数：在<code>XREVRANGE</code>中，你需要先指定<strong>结束ID</strong>，再指定<strong>开始ID</strong>，该命令就会从<strong>结束ID</strong>侧开始生成两个ID之间（或完全相同）的所有元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; XREVRANGE writers + - COUNT 2</span><br><span class="line">1) 1) 1526985723355-0</span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;Ngozi&quot;</span></span><br><span class="line">      3) <span class="string">&quot;surname&quot;</span></span><br><span class="line">      4) <span class="string">&quot;Adichie&quot;</span></span><br><span class="line">2) 1) 1526985712947-0</span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;Agatha&quot;</span></span><br><span class="line">      3) <span class="string">&quot;surname&quot;</span></span><br><span class="line">      4) <span class="string">&quot;Christie&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XTRIM</p>
<p>命令介绍：<code>XTRIM</code>将流裁剪为指定数量的项目，如有需要，将驱逐旧的项目（ID较小的项目）。此命令被设想为接受多种修整策略，但目前只实现了一种，即<code>MAXLEN</code>，并且与<code>XADD</code>中的<code>MAXLEN</code>选项完全相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; XADD mystream * field1 A field2 B field3 C field4 D</span><br><span class="line"><span class="string">&quot;1539863719429-0&quot;</span></span><br><span class="line">redis&gt; XTRIM mystream MAXLEN 2</span><br><span class="line">ERR Unknown or disabled <span class="built_in">command</span> <span class="string">&#x27;XTRIM&#x27;</span></span><br><span class="line">redis&gt; XRANGE mystream - +</span><br><span class="line">1) 1) <span class="string">&quot;1539863719429-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;A&quot;</span></span><br><span class="line">      3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">      4) <span class="string">&quot;B&quot;</span></span><br><span class="line">      5) <span class="string">&quot;field3&quot;</span></span><br><span class="line">      6) <span class="string">&quot;C&quot;</span></span><br><span class="line">      7) <span class="string">&quot;field4&quot;</span></span><br><span class="line">      8) <span class="string">&quot;D&quot;</span></span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/12/Redis%E5%91%BD%E4%BB%A4/" data-id="cll0ae7xb000ayurf93661bs0" data-title="Redis命令" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Blog/" rel="tag">Blog</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/08/02/Pika%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E6%BB%A1%E6%81%A2%E5%A4%8D%E6%96%B9%E6%A1%88/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Pika磁盘容量满恢复方案
        
      </div>
    </a>
  
  
    <a href="/2023/07/12/pika_exporter%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%96%87%E6%A1%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Pika_exporter本地启动文档</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blog/" rel="tag">Blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Blog/" style="font-size: 10px;">Blog</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/06/Pika%E7%9A%84Zset%E8%8C%83%E5%9B%B4%E5%88%A0%E9%99%A4%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">Pika的Zset范围删除性能优化方案</a>
          </li>
        
          <li>
            <a href="/2023/08/02/Pika%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E6%BB%A1%E6%81%A2%E5%A4%8D%E6%96%B9%E6%A1%88/">Pika磁盘容量满恢复方案</a>
          </li>
        
          <li>
            <a href="/2023/07/12/Redis%E5%91%BD%E4%BB%A4/">Redis命令</a>
          </li>
        
          <li>
            <a href="/2023/07/12/pika_exporter%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%96%87%E6%A1%A3/">Pika_exporter本地启动文档</a>
          </li>
        
          <li>
            <a href="/2023/07/11/Blackwidow%E9%87%8D%E6%9E%84%E5%9B%BE/">Blackwidow代码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>