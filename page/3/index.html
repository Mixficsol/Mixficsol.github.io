<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hdu1312" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1312/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.015Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1312/">hdu1312</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 10 &#x2F; 21</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=1312">https://acm.dingbacode.com/showproblem.php?pid=1312</a></p>
<blockquote>
<p>Red and Black</p>
<p>Time Limit: 2000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 40902    Accepted Submission(s): 24844</p>
<p>Problem Description<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black &gt; &gt; tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.</p>
<p>Write a program to count the number of black tiles which he can reach by repeating the moves described above. </p>
<p>Input<br>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the &gt; numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p>
<p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as &gt; &gt; &gt; follows.</p>
<p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set) </p>
<p>Output<br>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile<br>(including itself). </p>
<p>Sample Input</p>
<p>6 9</p>
<p>….#.</p>
<p>…..#</p>
<p>……</p>
<p>……</p>
<p>……</p>
<p>……</p>
<p>……</p>
<p>#@…#</p>
<p>.#..#.</p>
<p>11 9</p>
<p>.#………</p>
<p>.#.#######.</p>
<p>.#.#…..#.</p>
<p>.#.#.###.#.</p>
<p>.#.#..@#.#.</p>
<p>.#.#####.#.</p>
<p>.#…….#.</p>
<p>.#########.</p>
<p>………..</p>
<p>11 6</p>
<p>..#..#..#..</p>
<p>..#..#..#..</p>
<p>..#..#..###</p>
<p>..#..#..#@.</p>
<p>..#..#..#..</p>
<p>..#..#..#..</p>
<p>7 7</p>
<p>..#.#..</p>
<p>..#.#..</p>
<p>###.###</p>
<p>...@…</p>
<p>###.###</p>
<p>..#.#..</p>
<p>..#.#..</p>
<p>0 0</p>
<p>Sample Output</p>
<p>45</p>
<p>59</p>
<p>6</p>
<p>13</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>题目大意是寻找人能到达的最多黑砖块的数目，是个bfs模板吧可以说，利用struct存x，y坐标，然后放到queue里面，对于队列中出来的每一个点<br>判断其位置是否在边界外以及是否碰到了红砖块，还有就是判断这个点是否被用过(这里得重视，写代码时答案错误改了好久就是这里的问题)都满足条件的话就<br>cnt++，其他的就没什么了，主要是很久没写bfs的题目今天练一下手。</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string Map[<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> used[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> sx, sy, cnt, n, m;</span><br><span class="line"><span class="type">int</span> dirx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> diry[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coordinate</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  coordinate start, next;</span><br><span class="line">  start.x = sx;</span><br><span class="line">  start.y = sy;</span><br><span class="line">  queue&lt;coordinate&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(start);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    start = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      next.x = start.x + dirx[i];</span><br><span class="line">      next.y = start.y + diry[i];</span><br><span class="line">      <span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; m &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; n &amp;&amp; Map[next.x][next.y] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !used[next.x][next.y]) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">	used[next.x][next.y] = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  string s1 = <span class="string">&quot;@&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123;</span><br><span class="line">    format(used);</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      cin &gt;&gt; Map[i];</span><br><span class="line">      k = Map[i].<span class="built_in">find</span>(s1);</span><br><span class="line">      <span class="keyword">if</span> (k &lt; n &amp;&amp; k != <span class="number">-1</span>) &#123;</span><br><span class="line">        sx = i;</span><br><span class="line">	sy = k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1312/" data-id="clgk9rvoi000znerf0tkv49xt" data-title="hdu1312" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1427" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1427/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.015Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1427/">hdu1427</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 11 &#x2F; 4</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=1427">https://acm.dingbacode.com/showproblem.php?pid=1427</a><br><img width="1014" alt="截屏2021-11-04 21 19 46" src="https://user-images.githubusercontent.com/73943232/140320355-dd698f56-1812-4204-8007-6dbf485a7617.png"></p>
<blockquote>
<p>速算24点</p>
<p>Time Limit: 2000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 8026    Accepted Submission(s): 2092</p>
<p>Problem Description</p>
<p>速算24点相信绝大多数人都玩过。就是随机给你四张牌，包括A(1),2,3,4,5,6,7,8,9,10,J(11),Q(12),K(13)。要求只用’+’,’-‘,’*’,’&#x2F;‘运算符以及括号改变运算顺序，使得最终运算结果为24(每个数必须且仅能用一次)。游戏很简单，但遇到无解的情况往往让人很郁闷。你的任务就是针对每一组随机产生的四张牌，判断是否有解。我们另外规定，整个计算过程中都不能出现小数。</p>
<p>Input</p>
<p>每组输入数据占一行，给定四张牌。</p>
<p>Output</p>
<p>每一组输入数据对应一行输出。如果有解则输出”Yes”，无解则输出”No”。</p>
<p>Sample Input</p>
<p>A 2 3 6</p>
<p>3 3 8 8</p>
<p>Sample Output</p>
<p>Yes</p>
<p>No</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目是一个dfs题，题目要求是给你四个数问你能不能通过加减乘除括号等操作使其计算结果为24，加减乘除的话就简单的dfs就行了，但是这里有个括号的选择，那我们就需要<br>考虑操作数之间的关系，首先除数不能为0以及商不能有余数，如果某一个数和下个数之间有括号隔开那么此时的sum值不算，sum的值直到括号里面的数都算完为止才进行计算，当然<br>对于一副扑克牌我们还需要进行对花色进行的赋值操作.</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="string">&quot;10&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (s[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> x, <span class="type">int</span> index1)</span> </span>&#123;  <span class="comment">// 当前的值  下一个操作数的值  下一个操作数的索引</span></span><br><span class="line">  <span class="keyword">if</span> (index1 == <span class="number">4</span>) &#123; <span class="comment">// 到最后一个操作数</span></span><br><span class="line">    <span class="keyword">if</span> (sum + x == <span class="number">24</span> || sum - x == <span class="number">24</span> || sum * x == <span class="number">24</span>) &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">0</span> &amp;&amp; sum % x == <span class="number">0</span> &amp;&amp; sum / x == <span class="number">24</span>) &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(sum + x, a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>); <span class="comment">// 当前的值和下一个操作数在同一括号内</span></span><br><span class="line">  <span class="built_in">solve</span>(sum - x, a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">solve</span>(sum * x, a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="number">0</span> &amp;&amp; sum % x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">solve</span>(sum / x, a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(sum, x + a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>); <span class="comment">// 当前值和下个操作数不在一个括号内</span></span><br><span class="line">  <span class="built_in">solve</span>(sum, x - a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">solve</span>(sum, x * a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[index1 + <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; x % a[index1 + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">solve</span>(sum, x / a[index1 + <span class="number">1</span>], index1 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; s) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="built_in">get_sum</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      a[i] = <span class="built_in">get_sum</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="built_in">solve</span>(a[<span class="number">1</span>], a[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!flag &amp;&amp; <span class="built_in">next_permutation</span>(a + <span class="number">1</span>, a + <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1427/" data-id="clgk9rvoi0011nerfersp9qkq" data-title="hdu1427" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1429" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1429/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.015Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1429/">hdu1429</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 11 &#x2F; 4</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=1429">https://acm.dingbacode.com/showproblem.php?pid=1429</a></p>
<blockquote>
<p>胜利大逃亡(续)</p>
<p>Time Limit: 4000&#x2F;2000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 14029    Accepted Submission(s): 5055</p>
<p>Problem Description</p>
<p>Ignatius再次被魔王抓走了(搞不懂他咋这么讨魔王喜欢)……</p>
<p>这次魔王汲取了上次的教训，把Ignatius关在一个n*m的地牢里，并在地牢的某些地方安装了带锁的门，钥匙藏在地牢另外的某些地方。刚开始Ignatius被关在(sx,sy)的位置，离开地牢的门在(ex,ey)的位置。Ignatius每分钟只能从一个坐标走到相邻四个坐标中的其中一个。魔王每t分钟回地牢视察一次，若发现Ignatius不在原位置便把他拎回去。经过若干次的尝试，Ignatius已画出整个地牢的地图。现在请你帮他计算能否再次成功逃亡。只要在魔王下次视察之前走到出口就算离开地牢，如果魔王回来的时候刚好走到出口或还未到出口都算逃亡失败。</p>
<p>Input</p>
<p>每组测试数据的第一行有三个整数n,m,t(2&lt;&#x3D;n,m&lt;&#x3D;20,t&gt;0)。接下来的n行m列为地牢的地图，其中包括: . 代表路</p>
<ul>
<li>代表墙@ 代表Ignatius的起始位置^ 代表地牢的出口A-J 代表带锁的门,对应的钥匙分别为a-j,a-j 代表钥匙，<br>对应的门分别为A-J,每组测试数据之间有一个空行。</li>
</ul>
<p>Output</p>
<p>针对每组测试数据，如果可以成功逃亡，请输出需要多少分钟才能离开，如果不能则输出-1。</p>
<p>Sample Input</p>
<p>4 5 17</p>
<p>@A.B.</p>
<p>a*.*.</p>
<p>*..*^</p>
<p>c..b*</p>
<p>4 5 16</p>
<p>@A.B.</p>
<p>a*.*.</p>
<p>*..*^</p>
<p>c..b*</p>
<p>Sample Output</p>
<p>16</p>
<p>-1</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目虽然是一个bfs的题目，但是里面穿插了状态压缩的思想，题目除了说了一般bfs里面有的墙不能走的条件外还加了一个用钥匙打开的门的选项，这里我是在结构体里面多<br>加了一个变量k来判断此时能不能打开门，如果我们捡到一把钥匙，那我们对其进行<code> b.k = b.k | (1 &lt;&lt; (map1[b.x][b.y] - &#39;a&#39;));</code> 操作，使其相应位数上的数<br>变为1，比如说我有a,b,e这三把钥匙，那么我此时的k的二进制就表示…10011，用了位运算就巧妙的解决了钥匙问题，如果我们碰到一个门，那么进行<code> int k = b.k &amp; (1 &lt;&lt; (map1[b.x][b.y] - &#39;A&#39;));</code> 判断，如果k不为0就证明有这个钥匙，因为1 &amp; 0 &#x3D;&#x3D; 0， 1 &amp; 1 &#x3D;&#x3D; 1，如果有钥匙那么它对应位数上的数就是1，进行&amp;运算就不会等于0.这里的vis数组我定义为3维的，因为<br>多了钥匙这个状态，对于每一个点，访问的时候钥匙的数量也是不一定的，而且这个数组的大小是2^0到2^9的值相加，为1000左右，此时为拥有全部钥匙。因为题目中钥匙的种类是’a’到’j’刚好9位，<br>如果钥匙种类更大就不能再用数组存了.</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t, sx, sy, ex, ey, flag, ans;</span><br><span class="line"><span class="type">int</span> dir[][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">25</span>][<span class="number">25</span>][<span class="number">5000</span>];</span><br><span class="line"><span class="type">char</span> map1[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Mix</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="type">int</span> time;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node a, b;</span><br><span class="line">  queue&lt;node&gt; q;</span><br><span class="line">  a.x = sx;</span><br><span class="line">  a.y = sy;</span><br><span class="line">  a.time = a.k = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(a);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    a = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.time &gt;= t) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.x == ex &amp;&amp; a.y == ey) &#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      ans = a.time;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      b.x = a.x + dir[i][<span class="number">0</span>];</span><br><span class="line">      b.y = a.y + dir[i][<span class="number">1</span>];</span><br><span class="line">      b.time = a.time + <span class="number">1</span>;</span><br><span class="line">      b.k = a.k;</span><br><span class="line">      <span class="keyword">if</span> (b.x &gt;= <span class="number">0</span> &amp;&amp; b.x &lt; n &amp;&amp; b.y &gt;= <span class="number">0</span> &amp;&amp; b.y &lt; m &amp;&amp; map1[b.x][b.y] != <span class="string">&#x27;*&#x27;</span> &amp;&amp; !vis[b.x][b.y][b.k]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= map1[b.x][b.y] &amp;&amp; map1[b.x][b.y] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">	  b.k = b.k | (<span class="number">1</span> &lt;&lt; (map1[b.x][b.y] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">	  vis[b.x][b.y][b.k] = <span class="number">1</span>;</span><br><span class="line">	  q.<span class="built_in">push</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= map1[b.x][b.y] &amp;&amp; map1[b.x][b.y] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">	  <span class="type">int</span> k = b.k &amp; (<span class="number">1</span> &lt;&lt; (map1[b.x][b.y] - <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	  <span class="keyword">if</span> (k) &#123;</span><br><span class="line">	    vis[b.x][b.y][b.k] = <span class="number">1</span>;</span><br><span class="line">	    q.<span class="built_in">push</span>(b);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  vis[b.x][b.y][b.k] = <span class="number">1</span>;</span><br><span class="line">	  q.<span class="built_in">push</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; t) &#123;</span><br><span class="line">    flag = ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">	  cin &gt;&gt; c;</span><br><span class="line">	  map1[i][j] = c;</span><br><span class="line">	  <span class="keyword">if</span> (c == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">	    sx = i;</span><br><span class="line">	    sy = j;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">	    ex = i;</span><br><span class="line">	    ey = j;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">bfs</span>();</span><br><span class="line">      format(vis);</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1429/" data-id="clgk9rvoj0015nerfec5u43rq" data-title="hdu1429" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1074(状压DP + 字典序)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1074(%E7%8A%B6%E5%8E%8BDP%20+%20%E5%AD%97%E5%85%B8%E5%BA%8F)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.014Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1074(%E7%8A%B6%E5%8E%8BDP%20+%20%E5%AD%97%E5%85%B8%E5%BA%8F)/">hdu1074(状压DP+字典序)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 03 &#x2F; 04</p>
<p>[参考链接]<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37493070/article/details/77336109">https://blog.csdn.net/qq_37493070/article/details/77336109</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>Doing Homework</p>
<p>Ignatius has just come back school from the 30th ACM&#x2F;ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test, 1 day for 1 point. And as you know, doing homework always takes a long time. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.</p>
<p>Input<br>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case start with a positive integer N(1&lt;&#x3D;N&lt;&#x3D;15) which indicate the number of homework. Then N lines follow. Each line contains a string S(the subject’s name, each string will at most has 100 characters) and two integers D(the deadline of the subject), C(how many days will it take Ignatius to finish this subject’s homework).<br>Note: All the subject names are given in the alphabet increasing order. So you may process the problem much easier.</p>
<p>Output </p>
<p>For each test case, you should output the smallest total reduced score, then give out the order of the subjects, one subject in a line. If there are more than one orders, you should output the alphabet smallest one.</p>
<p>Sample Input</p>
<p>2</p>
<p>3 </p>
<p>Computer 3 3 </p>
<p>English 20 1 </p>
<p>Math 3 2 </p>
<p>3 </p>
<p>Computer 3 3 </p>
<p>English 6 3 </p>
<p>Math 6 3</p>
</blockquote>
<blockquote>
<p>Sample Output </p>
<p>2 </p>
<p>Computer </p>
<p>Math </p>
<p>English </p>
<p>3 </p>
<p>Computer </p>
<p>English </p>
<p>Math</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目其实只是一个状压压缩dp的入门题，但是我刚开始写的时候却困难重重，首先是这个题的题解刚开始看不懂，然后前前后后花了一个多小时去理解，题目的意思是一个学生要写作业<br>每科作业有两个属性，一个是完成该作业需要的时间，一个是这个作业的截止时间，问在多科作业中怎么写才能使扣的分数最少(ex：如果一个作业需要两天写完，但是截止时间是1天，那么<br>写完就会扣一分，超出几天写完就是扣几分，所以我们需要合理规划写作业顺序）题目还说了各科作业以字典序增大的顺序给出，需要我们在扣分一样多的情况下输出最小字典序的写作业顺序<br>这里我们对于每一科作业写完还是没写完用二进制位表示，假如有三门作业，101表示第1,3门作业写完了，第二门没写完，110，表示第1,2门作业写完了，第三门作业没写完。那么从000到<br>111我们需要遍历这么多次，dp思想的思路是：若要求1011的最优解，那么就可能是从1001,1010,0011这三个状态递推过来的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task</span> &#123;</span><br><span class="line">  string name; <span class="comment">// 课程名字</span></span><br><span class="line">  <span class="type">int</span> cost; <span class="comment">// 课程作业写完需要的时间</span></span><br><span class="line">  <span class="type">int</span> dead; <span class="comment">// 该课程还有几天需要交</span></span><br><span class="line">&#125; work[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">property</span> &#123;</span><br><span class="line">  <span class="type">int</span> father; <span class="comment">// 父节点</span></span><br><span class="line">  <span class="type">int</span> course; <span class="comment">//记录课程名字</span></span><br><span class="line">  <span class="type">int</span> score;  <span class="comment">// 记录已经扣掉的分数</span></span><br><span class="line">  <span class="type">int</span> time;   <span class="comment">// 做完作业需要的时间</span></span><br><span class="line">&#125; dp[<span class="number">1</span> &lt;&lt; <span class="number">15</span>]; <span class="comment">//该状态下完成的任务扣分的最优解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> t, n;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    format(dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; work[i].name &gt;&gt; work[i].dead &gt;&gt; work[i].cost; <span class="comment">//记录各个属性值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; end; i++) &#123; <span class="comment">// 这里枚举所有的情况从什么都没做的00000到都做了的11111</span></span><br><span class="line">      dp[i].score = INF; <span class="comment">// 初始化dp为最大值因为题目要求最小值</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 这里因为题目的输入是由字典序逐渐增大来给的，所以要以最小字典序输出得从最左边(最后一门课）开始遍历1000，这里的1就是最后一门课，0001这里</span></span><br><span class="line">        <span class="type">int</span> temp = <span class="number">1</span> &lt;&lt; j;             <span class="comment">// 的1就是第一节课</span></span><br><span class="line">	<span class="keyword">if</span> (temp &amp; i) &#123; <span class="comment">// 确认前面的状态是什么，假如这里的i的二进制表示是1011，那么做完括号中的运算后他的值可能是1010，1001, 0011，这三种情况</span></span><br><span class="line">	  <span class="type">int</span> rec = i - temp; <span class="comment">// 这里的减法就是把回到前一个状态，例如i是1011，temp是0010，那么减完就是1001，回到上面三种情况中的一种</span></span><br><span class="line">	  <span class="type">int</span> res = dp[rec].time + work[j].cost - work[j].dead; <span class="comment">// res代表要扣的分数=之前写完作业已经用掉的天数 + 当前这个作业需要用的天数 - 当前这个作业需要的截止时间</span></span><br><span class="line">	  <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    res = <span class="number">0</span>;  <span class="comment">// 这种出现在截止时间特别长时，例如之前写作业用掉一天，当前作业需要2天，这个作业需要的截止时间是第100天，那么此时我们认为是不扣分的因为做完这个作业才第三天</span></span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span> (res + dp[rec].score &lt; dp[i].score) &#123; <span class="comment">// 如果出现了最优的扣分情况就赋值给当前状态下的dp</span></span><br><span class="line">	    dp[i].score = res + dp[rec].score; <span class="comment">// 最优扣分 = 之前的扣分 + 这次要扣的分数</span></span><br><span class="line">	    dp[i].father = rec; <span class="comment">// 当前作业的子节点就是之前作业的状态，例如当前最优状态是1011，是由1001这个状态得来的，那么1001就是1011的父节点</span></span><br><span class="line">	    dp[i].course = j;  <span class="comment">// 记录当前写的科目作业名字</span></span><br><span class="line">	    dp[i].time = dp[rec].time + work[j].cost; <span class="comment">// 计算写完这个作业已经用掉了多少天 = 之前作业需要的时间 + 当前作业需要的时间</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; dp[end - <span class="number">1</span>].score &lt;&lt; endl; <span class="comment">// 计算出总共扣的分数（end- 1)这个二进制就1111111，代表所有的作业都完成了</span></span><br><span class="line">   stack&lt;<span class="type">int</span>&gt; q; </span><br><span class="line">   <span class="type">int</span> x = end - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (dp[x].time) &#123; <span class="comment">// 从最后完成的作业开始往前找父节点</span></span><br><span class="line">     q.<span class="built_in">push</span>(dp[x].course); <span class="comment">// 将最后完成的存入栈中，栈最上面的是最先完成的</span></span><br><span class="line">     x = dp[x].father;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">     <span class="type">int</span> y = q.<span class="built_in">top</span>();</span><br><span class="line">     cout &lt;&lt; work[y].name &lt;&lt; endl; <span class="comment">// 依次打印出栈</span></span><br><span class="line">     q.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1074(%E7%8A%B6%E5%8E%8BDP%20+%20%E5%AD%97%E5%85%B8%E5%BA%8F)/" data-id="clgk9rvoc000enerf3k4022e3" data-title="hdu1074(状压DP+字典序)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1043" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1043/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.014Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1043/">hdu1043</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 11 &#x2F; 3</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img width="1016" alt="截屏2021-11-03 21 21 13" src="https://user-images.githubusercontent.com/73943232/140067565-de68de31-3127-42db-90b9-e4435c0d2bd3.png">

<blockquote>
<p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=1043">https://acm.dingbacode.com/showproblem.php?pid=1043</a></p>
<p>Eight</p>
<p>Time Limit: 10000&#x2F;5000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 45011    Accepted Submission(s): 11275<br>Special Judge</p>
<p>Problem Description</p>
<p>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: </p>
<p>1  2  3  4<br>5  6  7  8<br>9 10 11 12<br>13 14 15  x  </p>
<p>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: </p>
<p>1  2  3  4   &amp;emsp;&amp;ensp;   1  2  3  4  &amp;emsp;&amp;ensp;    1  2  3  4   &amp;emsp;&amp;ensp;   1  2  3  4 </p>
<p>5  6  7  8   &amp;emsp;&amp;ensp;   5  6  7  8  &amp;emsp;&amp;ensp;    5  6  7  8   &amp;emsp;&amp;ensp;   5  6  7  8 </p>
<p>9  x 10 12   &amp;ensp;   9 10  x 12  &amp;ensp;    9 10 11 12   &amp;ensp;   9 10 11 12 </p>
<p>13 14 11 15  &amp;emsp;  13 14 11 15 &amp;emsp;  13 14  x 15  &amp;emsp;  13 14 15 x </p>
<pre><code>      r-&gt;           d-&gt;           r-&gt; 
</code></pre>
<p>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively.<br>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course).<br>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement.</p>
<p>Input </p>
<p>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle </p>
<p>1 2 3<br>x 4 6<br>7 5 8  </p>
<p>is described by this list: </p>
<p>1 2 3 x 4 6 7 5 8 </p>
<p>Output </p>
<p>You will print to standard output either the word &#96;&#96;unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases.</p>
<p>Sample Input </p>
<p>2  3  4  1  5  x  7  6  8</p>
<p>Sample Output </p>
<p>ullddrurdllurdruldr</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目是一个八数码问题，搞了我三天时间，八数码问题类似于九宫格，也是排列组合问题中的一种，这个题目要求把一个状态的九宫格还原到初始状态下的九宫格所经历<br>的路径，这里我用的两个结构体，一个记录结点数和路径，另一个就是记录每一次的九宫格地图已经0在九宫格中的位置，还有此状态下的康拓展开值，康拓展开类似一种哈希<br>函数，空间换时间，把每一种排列对应于一个值，这里思路还是bfs把每一次向四周遍历后的值进行康拓展开计算看是否遍历过，如果没有则设此结点的父节点为遍历前的状态<br>最后根据给定状态下的结点一步步还原到最初状态.</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Mix</span> &#123;</span><br><span class="line">  <span class="type">char</span> way;  <span class="comment">// 记录路径</span></span><br><span class="line">  <span class="type">int</span> fath; <span class="comment">// 记录父节点</span></span><br><span class="line">&#125; node1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Axl</span> &#123;</span><br><span class="line">  <span class="type">int</span> s[<span class="number">10</span>]; <span class="comment">// 记录此时的排列</span></span><br><span class="line">  <span class="type">int</span> n;    <span class="comment">// 表示0在九宫格中的位置</span></span><br><span class="line">  <span class="type">int</span> son; <span class="comment">// 表示此排列在字典序中的位置</span></span><br><span class="line">&#125; node2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125; &#125;;  <span class="comment">// 方向数组</span></span><br><span class="line"><span class="type">int</span> fac[<span class="number">10</span>];</span><br><span class="line">node1 Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fibonacci</span><span class="params">()</span> </span>&#123;  <span class="comment">// 计算斐波拉契数组</span></span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cantor</span><span class="params">(<span class="type">int</span> s[])</span> </span>&#123;  <span class="comment">// 康拓展开</span></span><br><span class="line">  <span class="type">int</span> ans, k;</span><br><span class="line">  ans = k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] &gt; s[j]) &#123;</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += k * fac[<span class="number">8</span> - i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  queue&lt;node2&gt; q;</span><br><span class="line">  node2 x, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    x.s[i] = a[i];  <span class="comment">// 赋值初始路径</span></span><br><span class="line">  &#125;</span><br><span class="line">  x.n = <span class="number">8</span>;  <span class="comment">// 0在九宫格中的位置</span></span><br><span class="line">  x.son = <span class="number">0</span>; <span class="comment">// 子节点刚开始是初始值排列为0</span></span><br><span class="line">  Node[x.son].fath = <span class="number">0</span>;  <span class="comment">// 子节点的父节点为0初始值</span></span><br><span class="line">  q.<span class="built_in">push</span>(x);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      y = x;</span><br><span class="line">      <span class="type">int</span> tx = x.n % <span class="number">3</span> + dir[i][<span class="number">0</span>];</span><br><span class="line">      <span class="type">int</span> ty = x.n / <span class="number">3</span> + dir[i][<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; <span class="number">3</span> &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        y.n = ty * <span class="number">3</span> + tx;</span><br><span class="line">	<span class="type">int</span> temp = y.s[y.n];</span><br><span class="line">	y.s[y.n] = y.s[x.n];</span><br><span class="line">	y.s[x.n] = temp;</span><br><span class="line">	y.son = <span class="built_in">cantor</span>(y.s);</span><br><span class="line">	<span class="keyword">if</span> (Node[y.son].fath == <span class="number">-1</span>) &#123;</span><br><span class="line">	  Node[y.son].fath = x.son;</span><br><span class="line">	  <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">	    Node[y.son].way = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">	    Node[y.son].way = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">	    Node[y.son].way = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">	    Node[y.son].way = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> str[<span class="number">10</span>], a[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">char</span> ch[<span class="number">50</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    a[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    Node[i].fath = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Fibonacci</span>();</span><br><span class="line">  <span class="built_in">bfs</span>(a);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">gets</span>(ch) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; ch[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch[i] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        str[j++] = <span class="number">9</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ch[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[i] &lt;= <span class="string">&#x27;8&#x27;</span>) &#123;</span><br><span class="line">        str[j++] = ch[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x = <span class="built_in">cantor</span>(str);  <span class="comment">// 求出初态康拓值</span></span><br><span class="line">    <span class="keyword">if</span> (Node[x].fath == <span class="number">-1</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;unsolvable&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">      cout &lt;&lt; Node[x].way;</span><br><span class="line">      x = Node[x].fath;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1043/" data-id="clgk9rvod000hnerf5mx29sy2" data-title="hdu1043" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1195" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1195/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.014Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1195/">hdu1195</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 10 &#x2F; 28</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=1195">https://acm.dingbacode.com/showproblem.php?pid=1195</a></p>
<blockquote>
<p>Open the Lock</p>
<p>Time Limit: 2000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 9291    Accepted Submission(s): 4098</p>
<p>Problem Description<br>Now an emergent task for you is to open a password lock. The password is consisted of four digits. Each digit is numbered from 1 to 9.<br>Each time, you can add or minus 1 to any digit. When add 1 to ‘9’, the digit will change to be ‘1’ and when minus 1 to ‘1’, the digit will change to be ‘9’. You can also exchange the digit with its neighbor. Each action will take one step.</p>
<p>Now your task is to use minimal steps to open the lock.</p>
<p>Note: The leftmost digit is not the neighbor of the rightmost digit.</p>
<p>Input</p>
<p>The input file begins with an integer T, indicating the number of test cases.<br>Each test case begins with a four digit N, indicating the initial state of the password lock. Then followed a line with anotther four dight M, indicating the password which can open the lock. There is one blank line after each test case.</p>
<p>Output<br>For each test case, print the minimal steps in one line.  </p>
<p>Sample Input<br>2<br>1234<br>2144<br>1111<br>9999  </p>
<p>Sample Output<br>2<br>4</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题是从一个初始四位数密码得到一个目标密码所需要的步数，对于密码锁可以进行加减操作已经两位直接换位操作，对于每一个种操作我们都应该放入队列中进行bfs<br>加减操作利用for循环对每一位进行操作，然后放入队列中，并用vis数组判断，然后找到后返回步骤数</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">11</span>], b[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> now[<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> flag;</span><br><span class="line">  node x, y;</span><br><span class="line">  queue&lt;node&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    x.now[i] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ans[i] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x.step = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(x);</span><br><span class="line">  format(vis);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.now[i] != ans[i]) &#123;</span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> x.step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      y = x;</span><br><span class="line">      <span class="keyword">if</span> (x.now[i] == <span class="number">9</span>) &#123;</span><br><span class="line">        y.now[i] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	y.now[i] = x.now[i] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!vis[y.now[<span class="number">0</span>]][y.now[<span class="number">1</span>]][y.now[<span class="number">2</span>]][y.now[<span class="number">3</span>]]) &#123;</span><br><span class="line">        vis[y.now[<span class="number">0</span>]][y.now[<span class="number">1</span>]][y.now[<span class="number">2</span>]][y.now[<span class="number">3</span>]] = <span class="number">1</span>;</span><br><span class="line">	y.step = x.step + <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      y = x;</span><br><span class="line">      <span class="keyword">if</span> (x.now[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        y.now[i] = <span class="number">9</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y.now[i] = x.now[i] - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!vis[y.now[<span class="number">0</span>]][y.now[<span class="number">1</span>]][y.now[<span class="number">2</span>]][y.now[<span class="number">3</span>]]) &#123;</span><br><span class="line">        vis[y.now[<span class="number">0</span>]][y.now[<span class="number">1</span>]][y.now[<span class="number">2</span>]][y.now[<span class="number">3</span>]] = <span class="number">1</span>;</span><br><span class="line">	y.step = x.step + <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      y = x;</span><br><span class="line">      y.now[i] = x.now[i + <span class="number">1</span>];</span><br><span class="line">      y.now[i + <span class="number">1</span>] = x.now[i];</span><br><span class="line">      <span class="keyword">if</span> (!vis[y.now[<span class="number">0</span>]][y.now[<span class="number">1</span>]][y.now[<span class="number">2</span>]][y.now[<span class="number">3</span>]]) &#123;</span><br><span class="line">        vis[y.now[<span class="number">0</span>]][y.now[<span class="number">1</span>]][y.now[<span class="number">2</span>]][y.now[<span class="number">3</span>]] = <span class="number">1</span>;</span><br><span class="line">	y.step = x.step + <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1195/" data-id="clgk9rvod000jnerffxdn1py1" data-title="hdu1195" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1213(并查集)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1213(%E5%B9%B6%E6%9F%A5%E9%9B%86)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.014Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1213(%E5%B9%B6%E6%9F%A5%E9%9B%86)/">hdu1213</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 03 &#x2F; 24</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>Problem Descrption</p>
<p>Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.<br>One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.<br>For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.</p>
<p>Input</p>
<p>The input starts with an integer T(1&lt;&#x3D;T&lt;&#x3D;25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;&#x3D;N,M&lt;&#x3D;1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!&#x3D;B), that means friend A and friend B know each other. There will be a blank line between two cases.</p>
<p>Output</p>
<p>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.</p>
<p>Sample Input</p>
<p>2</p>
<p>5 3</p>
<p>1 2</p>
<p>2 3</p>
<p>4 5</p>
<p>5 1<br>2 5</p>
<p>Sample Output</p>
<p>2</p>
<p>4</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这是一个基本的并查集的题目，题意是在聚会上，相互认识或者有共同朋友的人坐同一桌，给出t组数据，n表示总共有几个人，m表示有多少个认识关系 需要求现场需要布置多少张桌子，<br>我的思路是如果A-&gt;B表示A B两人相互认识，那么就应该把他们放进同一个集合里面，这也是并查集的思想，也类似一种建树的步骤，最终需要确定有多少个<br>根节点，即需要摆多少张桌子.</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) &#123;</span><br><span class="line">    s[i] = i;	<span class="comment">//初始化</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s[i] == i ? i : <span class="built_in">find_set</span>(s[i]); <span class="comment">//寻找出根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  x = <span class="built_in">find_set</span>(x);</span><br><span class="line">  y = <span class="built_in">find_set</span>(y);</span><br><span class="line">  <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    s[x] =  s[y];	 <span class="comment">//合并节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> t, x, y, n, m, cnt;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="built_in">union_set</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == i) &#123;</span><br><span class="line">        cnt++;	</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1213(%E5%B9%B6%E6%9F%A5%E9%9B%86)/" data-id="clgk9rvof000onerfbi06df38" data-title="hdu1213" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1241" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1241/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.014Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1241/">hdu1241</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 10 &#x2F; 28</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=1241">https://acm.dingbacode.com/showproblem.php?pid=1241</a><br><img width="1015" alt="截屏2021-10-28 20 03 46" src="https://user-images.githubusercontent.com/73943232/139251966-7d33c2f8-83f2-4532-bf57-27502e60389e.png"></p>
<blockquote>
<p>Oil Deposits</p>
<p>Time Limit: 2000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 68079    Accepted Submission(s): 39302</p>
<p>Problem Description<br>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. </p>
<p>Input</p>
<p>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m &#x3D; 0 it signals the end of the input; otherwise 1 &lt;&#x3D; m &lt;&#x3D; 100 and 1 &lt;&#x3D; n &lt;&#x3D; 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either <code>*&#39;, representing the absence of oil, or </code>@’, representing an oil pocket.</p>
<p>Output</p>
<p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p>
<p>Sample Input</p>
<p>1 1</p>
<p>*</p>
<p>3 5</p>
<p>*@*@*</p>
<p>**@**</p>
<p>*@*@*</p>
<p>1 8</p>
<p>@@****@*</p>
<p>5 5 </p>
<p> ****@</p>
<p>*@@*@</p>
<p>*@**@</p>
<p>@@@*@</p>
<p>@@**@</p>
<p>0 0 </p>
<p>Sample Output</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>2</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>这个题目是一个经典的八连通问题，题目要求的是总共有几个油坑，我使用的是dfs，我们可以对每一个点进行遍历，从某个点遍历时当他的点是@时，我们把他设为#理解为这个点走过了<br>然后利用一个计数器计数，得到答案，我刚开始不理解void dfs这个函数怎么结束，因为我没有加return，后面才知道在一个for循环内如果没有一个满足的条件，就不会进入下一个dfs<br>此时函数就回到上一个,一直到最开始的函数结束.</p>
</blockquote>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> map1[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> dx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> dy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (map1[dx][dy] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">      map1[dx][dy] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(dx, dy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, m, cnt;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; map1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map1[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">	  map1[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	  <span class="built_in">dfs</span>(i, j);</span><br><span class="line">	  cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1241/" data-id="clgk9rvog000rnerf5l6phw9y" data-title="hdu1241" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP第六章--存储器的层次结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/CSAPP%E7%AC%AC%E5%85%AD%E7%AB%A0--%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.013Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/CSAPP%E7%AC%AC%E5%85%AD%E7%AB%A0--%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">存储器的层次结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<pre><code>我们依赖于一个简单的计算机系统模型，CPU执行指令，而存储器系统为CPU存放指令和数据.在简单模型中，存储器系统是一个线性的字节数组.而CPU能够在一个常数时间内访问每个存储器的位置.
实际上，存储器系统是一个具有不同容量，成本和访问时间的存储设备的层次结构.CPU寄存器保存着最常用的数据.靠近CPU的小的，快速的高速缓存存储器作为一部分储存在相对慢速的主储存器中数据和指令的缓冲区域,主存缓存存储在容量较大的，慢速磁盘上的数据.
 作为一个程序员，如果你的程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在0个周期内就能访问到它们.如果存储在高速缓存中，需要4~75个周期.如果存储在主存中,需要上百个周期.而如果存储在磁盘上，需要大约几千万个周期！
本章我们会看看基本的存储技术——SRAM存储器，DRAM存储器，ROM存储器以及旋转和固态的硬盘
</code></pre>
<h3 id="6-1存储技术"><a href="#6-1存储技术" class="headerlink" title="6.1存储技术"></a>6.1存储技术</h3><blockquote>
<p>早期的计算机只有几千字节的随机访问存储器，目前磁盘的容量以每两年加倍的速度增长.</p>
</blockquote>
<h3 id="6-1-1-随机访问存储器"><a href="#6-1-1-随机访问存储器" class="headerlink" title="6.1.1 随机访问存储器"></a>6.1.1 随机访问存储器</h3><blockquote>
<p>随机访问存储器(RAM)分为两类：静态的和动态的.静态RAM(SRAM)比动态RAM(DRAM)更快，但也贵得多.SRAM用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下.DRAM用来作为主存以及图形系统的帧缓冲区.一个桌面系统的SRAM不会超过几兆字节，但是DRAM却有几百或几千兆字节.</p>
</blockquote>
<h4 id="1-静态RAM"><a href="#1-静态RAM" class="headerlink" title="1.静态RAM"></a>1.静态RAM</h4><blockquote>
<p>SRAM将每个位存储在一个双稳态的存储器单元里面.每个单元是用一个六晶体管电路来实现的，由于SRAM存储器单元的双稳态特性，只要有电，它就会永远地保持它的值.即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值.</p>
</blockquote>
<h4 id="2-动态RAM"><a href="#2-动态RAM" class="headerlink" title="2.动态RAM"></a>2.动态RAM</h4><blockquote>
<p>DRAM将每个位存储为对一个电容的充电.与SRAM不同，DRAM存储器单元对干扰非常敏感.当电容的电压被扰乱之后，它就永远不会恢复了.暴露在光线下会导致电容电压改变.实际上，数码照相机和摄像机中的传感器本质上就是DRAM单元的阵列.</p>
</blockquote>
<h4 id="3-SRAM与DRAM"><a href="#3-SRAM与DRAM" class="headerlink" title="3.SRAM与DRAM"></a>3.SRAM与DRAM</h4><blockquote>
<p>只要有供电，SRAM就会保持不变，与DRAM不同，它不需要刷新.SRAM的存取比DRAM快.SRAM对诸如光和电噪声这样的干扰不敏感.代价是SRAM单元比DRAM单元使用更多的晶体管，因而密集度低，而且更贵，功耗更大.<br><img src="https://user-images.githubusercontent.com/73943232/159165290-5c0f0639-cd5b-4554-a3ee-c94b397c56e1.jpg" alt="891C4CF1FB7459F4EF7793DE8A03F93E"></p>
</blockquote>
<h4 id="4-内存模块"><a href="#4-内存模块" class="headerlink" title="4.内存模块"></a>4.内存模块</h4><blockquote>
<p>DRAM芯片封装在内存模块中，它插在主板的扩展槽上.Core i7系统使用的240个引脚的双列直插内存模块，它以64位位块传送数据到内存控制器和从内存控制器传出数据.</p>
</blockquote>
<h4 id="5-ROM"><a href="#5-ROM" class="headerlink" title="5.ROM"></a>5.ROM</h4><blockquote>
<p>如果断电，DRAM和SRAM会丢失它们的消息.从这个意义上来说,它们是易失的.另一方面，非易失性存储器即时在关电后，仍然保存着它们的信息.闪存是一类非易失性存储器，基于EEPROM,它已经成为了一种重要的存储技术.闪存无处不在，为大量的电子设备提供快速而持久的非易失性存储，包括数码相机，手机，音乐播放器，笔记本，一种新型的基于闪存的磁盘驱动器,称为固态硬盘，它能提供相对于传统旋转磁盘的一种更快速，更强健和更低能耗的选择.存储在ROM设备中的程序通常被称为固件.当一个计算机系统通电以后，它会运行存储在ROM中的固件，一些系统在固件中提供了少量基本的输入输出函数—例如PC的BIOS例程.复杂的设备，像图形卡和磁盘驱动控制器，也依赖固件翻译来自CPU的I&#x2F;O请求.</p>
</blockquote>
<h4 id="6-访问主存"><a href="#6-访问主存" class="headerlink" title="6.访问主存"></a>6.访问主存</h4><blockquote>
<p>数据流通过称为总线的共享电子电路在处理器和DRAM主存之间来来回回.每次CPU和主存之间的数据传送都是通过一系列步骤完成的，这些步骤称为总线事务.读事务从主存传送数据到CPU,写事务从CPU传送数据到主存.总线是一组并行的导线，能携带地址，数据和控制信号.取决于总线的设计，数据和地址信号可以共享同一组导线，也可以使用不同的.同时，两个以上的设备也能共享同一总线.控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型.<br><img src="https://user-images.githubusercontent.com/73943232/159165284-2bae89b3-3738-4164-8361-f5fed06a1360.jpg" alt="9FD746A8A5D46F9AACC93BCD0F49B9D8"></p>
</blockquote>
<h3 id="6-1-2-磁盘存储"><a href="#6-1-2-磁盘存储" class="headerlink" title="6.1.2 磁盘存储"></a>6.1.2 磁盘存储</h3><blockquote>
<p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千兆字节，而基于RAM的存储器只能有几百或几千兆字节.不过，从磁盘上读信息的时间为毫秒级，比DRAM读慢了10万倍，比从SRAM读慢了10万倍.</p>
</blockquote>
<h4 id="1-磁盘构造"><a href="#1-磁盘构造" class="headerlink" title="1.磁盘构造"></a>1.磁盘构造</h4><blockquote>
<p>磁盘是由盘片构成的，每个盘片有两面或者称为表面，表面覆盖着磁性记录材料.盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，每个表面是由一组称为磁道的同心圆组成的，每个磁道被划分为一组扇区，每个扇区包含相等数量的数据位(通常是512字节)，扇区之间由一些间隙分隔开，这些间隙中不存储数据位.间隙存储用来标识扇区的格式化位.磁盘是由一个或多个叠放在一起的盘片组成的,它们被封装在一个密封的包装里，整个装置通常被称为磁盘驱动器,我们通常称为磁盘.有时，我们会称磁盘为旋转磁盘，以使之区别于闪存的固态硬盘(SSD)，SSD是没有移动部分的.</p>
</blockquote>
<h4 id="2-磁盘容量"><a href="#2-磁盘容量" class="headerlink" title="2.磁盘容量"></a>2.磁盘容量</h4><blockquote>
<p>一个磁盘上可以记录的最大位数称为它的最大容量.磁盘容量是由以下技术因素决定的：记录密度，磁道密度，面密度，所以磁盘容量 &#x3D; 字节数 * 平均扇区数 * 磁道数 * 表面数 * 盘片数<br><img src="https://user-images.githubusercontent.com/73943232/159165268-246dff2c-5de8-4c50-b09d-487acadb8f94.jpg" alt="E390C408397147A42387628577AF247B"></p>
</blockquote>
<h4 id="3-磁盘操作"><a href="#3-磁盘操作" class="headerlink" title="3.磁盘操作"></a>3.磁盘操作</h4><blockquote>
<p>磁盘用读&#x2F;写头来读写存储在磁性表面的位，而读写头连接到一个传动臂一段，通过沿着半径轴前后移动这个传动臂，驱动器可以将读&#x2F;写头定位在盘面上的任何磁道上.这样的机械运动称为寻道.</p>
</blockquote>
<h3 id="6-1-3-固态硬盘"><a href="#6-1-3-固态硬盘" class="headerlink" title="6.1.3 固态硬盘"></a>6.1.3 固态硬盘</h3><blockquote>
<p>固态硬盘是一种基于闪存的存储技术，SSD封装到I&#x2F;O总线上标准硬盘插槽，行为就和其他硬盘一样，处理来自CPU的读写逻辑磁盘块的请求.一个SSD封装由一个或多个闪存芯片和闪存翻译层组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件&#x2F;固件设备,扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问.<br><img src="https://user-images.githubusercontent.com/73943232/159165233-13b4cca1-f078-4f5d-8bad-0d97d30e3227.jpg" alt="2B022C1CC490E166CAD1D3D698646F97"><br><img src="https://user-images.githubusercontent.com/73943232/159165248-ee9c098a-6342-4d7b-84de-6fbf39925d8f.jpg" alt="0B3381B21D181E3D3F2B1296D0CFCE47"></p>
</blockquote>
<h3 id="6-1-4-存储技术趋势"><a href="#6-1-4-存储技术趋势" class="headerlink" title="6.1.4 存储技术趋势"></a>6.1.4 存储技术趋势</h3><blockquote>
<p>不同的存储技术有不同的价格和性能折中，SRAM比DRAM快一点，而DRAM比磁盘要快很多，另一方面，快速存储总是比慢速存储要贵的.SRAM每字节的造价比DRAM高，DRAM的造价又比磁盘高得多.SSD位于DRAM和旋转磁盘之间.内存和磁盘技术的一个基本事实：增加密度(从而降低成本)比降低访问时间容易得多.DRAM和磁盘的性能滞后于CPU的性能.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/CSAPP%E7%AC%AC%E5%85%AD%E7%AB%A0--%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" data-id="clgk9rvo70004nerf7khx92e1" data-title="存储器的层次结构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/" rel="tag">blog</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSAPP第十一章--网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/CSAPP%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0--%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.013Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/CSAPP%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0--%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h2 id="CSAPP第十一章–网络编程"><a href="#CSAPP第十一章–网络编程" class="headerlink" title="CSAPP第十一章–网络编程"></a>CSAPP第十一章–网络编程</h2><h3 id="11-1客户端-服务器编程模型"><a href="#11-1客户端-服务器编程模型" class="headerlink" title="11.1客户端-服务器编程模型"></a>11.1客户端-服务器编程模型</h3><blockquote>
<p>每个网络应用都是基于客户端-服务器模型的，一个应用是由一个服务器进程和一个或者多个客户端进程组成.服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务.例如，一个Web服务器管理着一组磁盘文件，它会代表客户端进行检索和执行.客户端-服务器模型中的基本操作是事务.一个客户端-服务器事务由以下四步组成：</p>
<p>1.当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务.例如，当Web浏览器需要一个文件时，它就发送一个请求给Web服务器.</p>
<p>2.服务器收到请求后，解释它，并以适当的方式操作它的资源.例如，当Web服务器收到浏览器发出的请求后，它就读一个磁盘文件.</p>
<p>3.服务器给客户端发送一个响应，并等待下一个请求.例如，Web服务器将文件发送回客户端.</p>
<p>4.客户端收到响应并处理它.例如,当Web浏览器收到来自服务器的一页后，就在屏幕上显示此页.</p>
<p>认识到客户端和服务器是进程，而不是常提到的机器或者主机，这是很重要的.一台主机可以同时运行许多不同的客户端和服务器，而且一个客户端和服务器的事务可以在同一台或是不同的主机上.<br><img src="https://user-images.githubusercontent.com/73943232/159924015-d236ebfb-b349-45de-bfb0-2d9fb76bfca8.jpg" alt="4C6C748BB11CB59ACD6F92D341B77366"></p>
</blockquote>
<h3 id="11-2网络"><a href="#11-2网络" class="headerlink" title="11.2网络"></a>11.2网络</h3><blockquote>
<p>对主机而言，网络只是又一种I&#x2F;O设备，是数据源和数据接收方，一个插到I&#x2F;O总线扩展槽的适配器提供了到网络的物理接口.从网络上接收到的数据从适配器经过I&#x2F;O和内存总线复制到内存，通常是通过DMA传送.相似的，数据也能从内存复制到网络.</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/73943232/159924023-b9d692a6-92d5-4eb9-a4e1-31a1c515af75.jpg" alt="539DC5EB0C289450BD24160876A25B9B"></p>
<blockquote>
<p>物理上而言，网络是一个按照地理远近组成的层次系统.最低处是LAN(局域网),在一个建筑或者校园范围内.目前最流行的局域网技术是以太网.一个以太网端包括一些电缆和一个叫做集线器的小盒子.每根电缆一端连接到主机的适配器，而另一端则连接到集线器的一个端口上.集线器不加分辨地将从一个端口上收到的每个位复制到其他所有的端口上.因此，每台主机都能看到每个位.<br>每个以太网适配器都有一个全球唯一的48位地址，它储存在这个适配器的非易失性存储器上，一台主机可以发送一段位(帧)到这个网段内的其他任何主机.每个帧包括一些固定数量的头部位，用来标识此帧的源和目的地址以及此帧的长度，此后紧随的就是数据位的有效载荷.每个主机适配器都能看到这个帧,但是只有目的主机实际读取它.使用一些电缆和叫做网桥的小盒子，多个以太网可以连接成较大的局域网,称为桥接以太网.在一个桥接以太网里，一些电缆连接网桥与网桥，而另外一些连接网桥和集线器.<br>在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器的特殊计算机连接起来，组成一个互联网络.每台路由器对于它所连接的每个网络都有一个端口.路由器也能连接高速点到点电话连接，这是称为WAN.<br>互联网络至关重要的特性是，它能采用完全不同和不兼容技术的各种局域网和广域网组成.每台主机和其他每台主机都是物理相连的，但是如何能够让某台源主机跨过所有这些不兼容的网络发送数据位到另一台目的主机呢？<br>解决办法是一层运行在每台主机和路由器上的协议软件，它消除了不同网络之间的差异.这个软件实现一种协议，这种协议控制主机和路由器如何协同工作来实现数据传输.这种协议必须提供两种基本能力.</p>
<p>1.命名机制.不同的局域网技术有不同和不兼容的方式来为主机分配地址.每台主机会被分配至少一个这种互联网络地址，这个地址唯一地标识了这台主机</p>
<p>2.传送机制.在电缆上编码位和将这些位封装成帧方面,不同的联网技术有不同的和不兼容的方式.互联网络协议通过定义一种把数据位捆扎成不连续的片(包)的统一方式，从而消除了这些差异.一个包是由包头和有效载荷组成的，其中包头包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/73943232/159924041-47994a73-2e1e-4d27-98c8-efe741d28d30.jpg" alt="B4E79F558DA1ED9D782E161114D88354"><img src="https://user-images.githubusercontent.com/73943232/159924046-5888f393-bdc6-437a-b4d9-adbb55be67ce.jpg" alt="B14E309FBAC70C6BF58EB764975C568D"></p>
<p><img src="https://user-images.githubusercontent.com/73943232/159924067-3a24dcbf-c1f1-4f3b-a225-1d3719b67e81.jpg" alt="C6D64E897B41655062F4689EE29CE10F"></p>
<h3 id="11-3全球IP英特网"><a href="#11-3全球IP英特网" class="headerlink" title="11.3全球IP英特网"></a>11.3全球IP英特网</h3><blockquote>
<p>每台因特网主机都运行实现TCP&#x2F;IP协议.因特网的客户端和服务器混合使用套接字接口函数和UnixI&#x2F;O函数来进行通信，TCP&#x2F;IP实际是一个协议族，其中每一个都提供不同的功能.例如，IP协议提供基本的命名方法和递送机制.IP机制从某种意义上而言是不可靠的，因为，如果数据报在网络中丢失或者重复，它并不会试图修复.TCP是一个构建在IP之上的复杂协议，提供了进程间可靠的全双工连接.我们可以把因特网看做一个世界范围的主机集合，满足以下特性:</p>
<p>1.主机集合被映射为一组32位的IP地址</p>
<p>2.这组IP地址被映射为一组称为因特网域名的标识符</p>
<p>3.因特网主机上的进程能够通过连接和任何其他因特网主机上的进程通信</p>
</blockquote>
<h2 id="11-3-3因特网连接"><a href="#11-3-3因特网连接" class="headerlink" title="11.3.3因特网连接"></a>11.3.3因特网连接</h2><p>因特网客户端和服务器通过在连接上发送和接收字节流来通信.从连接一对进程的意义上而言，连接是点对点的.从数据可以同时双向流动的角度来说，它是全双工的.一个套接字是连接的一个端点.每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成的，用“地址:端口”表示.当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口.然而，服务器套接字地址中的端口通常是某个知名端口，是和这个服务相对应的.例如，Web服务器通常使用端口80.</p>
<p><img src="https://user-images.githubusercontent.com/73943232/159924335-41848f19-11e5-431e-aea2-78a84dd08a83.jpg" alt="64C2FADA35A7101F3AF127569F854BF3"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/CSAPP%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0--%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="clgk9rvo80005nerfbe6md5xi" data-title="网络编程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/" rel="tag">blog</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/README/" rel="tag">README</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/README/" style="font-size: 10px;">README</a> <a href="/tags/algorithm/" style="font-size: 20px;">algorithm</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/17/poj2418(map%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2)/">poj2418(map输出字符串)</a>
          </li>
        
          <li>
            <a href="/2023/04/17/poj3041%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/">poj3041</a>
          </li>
        
          <li>
            <a href="/2023/04/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">数据库连接池</a>
          </li>
        
          <li>
            <a href="/2023/04/17/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE/">链式前向星存图</a>
          </li>
        
          <li>
            <a href="/2023/04/17/hdu2193(AVL%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6)/">hdu2193(AVL树的高度)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>