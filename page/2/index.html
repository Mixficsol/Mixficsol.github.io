<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hdu4585(利用map排序)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu4585(%E5%88%A9%E7%94%A8map%E6%8E%92%E5%BA%8F)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.017Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu4585(%E5%88%A9%E7%94%A8map%E6%8E%92%E5%BA%8F)/">hdu4584(利用map排序)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 04 &#x2F; 22<br><img width="987" alt="截屏2022-04-22 11 19 49" src="https://user-images.githubusercontent.com/73943232/164589725-e550d2b6-3b80-4cec-84ed-775114327335.png"></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Shaolin"><a href="#Shaolin" class="headerlink" title="Shaolin"></a>Shaolin</h2><blockquote>
<p>Time Limit: 3000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 65535&#x2F;32768 K (Java&#x2F;Others)</p>
<p>Total Submission(s): 6467    Accepted Submission(s): 2804</p>
</blockquote>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Shaolin temple is very famous for its Kongfu monks.A lot of young men go to Shaolin temple every year, trying to be a monk there. The master of Shaolin evaluates a young man mainly by his talent on understanding the Buddism scripture, but fighting skill is also taken into account.<br>When a young man passes all the tests and is declared a new monk of Shaolin, there will be a fight , as a part of the welcome party. Every monk has an unique id and a unique fighting grade, which are all integers. The new monk must fight with a old monk whose fighting grade is closest to his fighting grade. If there are two old monks satisfying that condition, the new monk will take the one whose fighting grade is less than his.<br>The master is the first monk in Shaolin, his id is 1，and his fighting grade is 1,000,000,000.He just lost the fighting records. But he still remembers who joined Shaolin earlier, who joined later. Please recover the fighting records for him.</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>There are several test cases.<br>In each test case:<br>The first line is a integer n (0 &lt;n &lt;&#x3D;100,000),meaning the number of monks who joined Shaolin after the master did.(The master is not included).Then n lines follow. Each line has two integer k and g, meaning a monk’s id and his fighting grade.( 0&lt;&#x3D; k ,g&lt;&#x3D;5,000,000)<br>The monks are listed by ascending order of jointing time.In other words, monks who joined Shaolin earlier come first.<br>The input ends with n &#x3D; 0.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>A fight can be described as two ids of the monks who make that fight. For each test case, output all fights by the ascending order of happening time. Each fight in a line. For each fight, print the new monk’s id first ,then the old monk’s id.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>
<p>3</p>
<p>2 1</p>
<p>3 3</p>
<p>4 2</p>
<p>0 </p>
</blockquote>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>
<p>2 1</p>
<p>3 2</p>
<p>4 2</p>
</blockquote>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><blockquote>
<p>这个题目意思是少林寺每个和尚有两个属性，一个是独有的id，一个是战斗等级，每个和尚进来都要与一个战斗等级最接近的和尚对决，题目的要求是给出每个和尚进来时的id和战斗等级<br>需要打印出每组和尚对决的id，刚开始只有一个和尚，id是1，战斗力1000000000，我们知道map是默认利用key进行升序排序的，我们可以利用这一点进行排序，用例输入id和战斗等级<br>我们把他们插入map里面，然后利用迭代器寻找到他们的位置，在找到的位置前后进行大小比较.</p>
</blockquote>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, x, y;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    mp[<span class="number">1000000000</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      mp[y] = x;</span><br><span class="line">      map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(y);</span><br><span class="line">      <span class="type">int</span> ans;</span><br><span class="line">      <span class="keyword">if</span> (it == mp.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        ans = (++it)-&gt;second;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it2 = it;</span><br><span class="line">        it2--;</span><br><span class="line">        it++;</span><br><span class="line">        <span class="keyword">if</span> (y - it2-&gt;first &lt;= it-&gt;first - y) &#123;</span><br><span class="line">          ans = it2-&gt;second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ans = it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu4585(%E5%88%A9%E7%94%A8map%E6%8E%92%E5%BA%8F)/" data-id="clgk9v48f001zpxrfdbs14ahi" data-title="hdu4584(利用map排序)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1520(树形DP)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1520(%E6%A0%91%E5%BD%A2DP)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.016Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1520(%E6%A0%91%E5%BD%A2DP)/">hdu1520(树形DP)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 03 &#x2F; 04</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>Description</p>
<p>There is going to be a party to celebrate the 80-th Anniversary of the Ural State University. The University has a hierarchical structure of employees. It means that the supervisor relation forms a tree rooted at the rector V. E. Tretyakov. In order to make the party funny for every one, the rector does not want both an employee and his or her immediate supervisor to be present. The personnel office has evaluated conviviality of each employee, so everyone has some number (rating) attached to him or her. Your task is to make a list of guests with the maximal possible sum of guests’ conviviality ratings.</p>
<p>Input</p>
<p>Employees are numbered from 1 to N. A first line of input contains a number N. 1 &lt;&#x3D; N &lt;&#x3D; 6 000. Each of the subsequent N lines contains the conviviality rating of the corresponding employee. Conviviality rating is an integer number in a range from -128 to 127. After that go N – 1 lines that describe a supervisor relation tree. Each line of the tree specification has the form:<br>L K<br>It means that the K-th employee is an immediate supervisor of the L-th employee. Input is ended with the line<br>0 0 </p>
<p>Output</p>
<p>Output should contain the maximal sum of guests’ ratings.</p>
<p>Sample Input</p>
<p>7</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1 3</p>
<p>2 3</p>
<p>6 4</p>
<p>7 4</p>
<p>4 5</p>
<p>3 5</p>
<p>0 0</p>
<p>Sample Output</p>
<p>5</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>给你一棵关系树，让你从中选择若干个人，这些人之间不能有直接的上下级关系，要求最后的到的权值最大.这里我用到的是树形DP，把这些人的上下级关系利用一颗<br>树表示，从根节点开始遍历，每次对这个结点进行选择或不选择的判断然后对他的子节点进行dfs，到底端时开始返回值，最终只需要解决根节点选择或不选择的问题<br>这里要注意的是当i结点不选择时，他的子节点也可以是选择或者不选择从中利用一个max取到最大值，而对于已经选择的结点，那么它的子节点是一定不能选择的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, -1, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">7000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N]; <span class="comment">// 用来存每个结点的子节点</span></span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>]; <span class="comment">// dp[i][1]选择第i结点的最优解，dp[i][0]不选第i结点的最优解</span></span><br><span class="line"><span class="type">int</span> father[N]; <span class="comment">// 存取每个结点指向的父节点</span></span><br><span class="line"><span class="type">int</span> value[N]; <span class="comment">// 存取每个结点的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">  dp[root][<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 不选根节点的情况</span></span><br><span class="line">  dp[root][<span class="number">1</span>] = value[root]; <span class="comment">// 选择根节点的情况</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[root].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">int</span> son = v[root][i];  <span class="comment">// 提取出子节点</span></span><br><span class="line">    <span class="built_in">dfs</span>(son);  <span class="comment">// 对子节点dfs</span></span><br><span class="line">    dp[root][<span class="number">0</span>] += <span class="built_in">max</span>(dp[son][<span class="number">0</span>], dp[son][<span class="number">1</span>]); <span class="comment">//根节点不选（子节点选或不选）</span></span><br><span class="line">    dp[root][<span class="number">1</span>] += dp[son][<span class="number">0</span>]; <span class="comment">//选择根节点且子节点不选</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, x, y, z;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; value[i]; <span class="comment">// 存入各个节点的值</span></span><br><span class="line">      format(father); <span class="comment">// 初始化父节点使其为-1</span></span><br><span class="line">      v[i].<span class="built_in">clear</span>();  <span class="comment">// 初始化容器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y &amp;&amp; x &amp;&amp; y) &#123;</span><br><span class="line">      father[x] = y;  <span class="comment">// 将x的父节点定义为y</span></span><br><span class="line">      v[y].<span class="built_in">push_back</span>(x); <span class="comment">// 将x存进y节点容器中</span></span><br><span class="line">    &#125;</span><br><span class="line">    z = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (father[z] != <span class="number">-1</span>) &#123;</span><br><span class="line">      z = father[z];   <span class="comment">// 找到根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(z);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[z][<span class="number">0</span>], dp[z][<span class="number">1</span>]) &lt;&lt; endl;  <span class="comment">// 从根节点判断答案</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1520(%E6%A0%91%E5%BD%A2DP)/" data-id="clgk9v4880015pxrf5jte5p2d" data-title="hdu1520(树形DP)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1532(Dinic算法求网络最大流)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1532(Dinic%E7%AE%97%E6%B3%95%E6%B1%82%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.016Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1532(Dinic%E7%AE%97%E6%B3%95%E6%B1%82%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81)/">hdu1532</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 03 &#x2F; 21</p>
<p>[参考链接]<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39861441/article/details/87566503">https://blog.csdn.net/qq_39861441/article/details/87566503</a></p>
<p>[学习视频]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1j64y1R7yK/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1j64y1R7yK/?spm_id_from=333.788.recommend_more_video.-1</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img width="889" alt="截屏2022-03-21 20 32 08" src="https://user-images.githubusercontent.com/73943232/159261634-083ad032-f2e6-49da-a0da-2cba87013a31.png">

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目是最大流的入门题，题意是题中N为水沟数，M为水沟的顶点，接下来Si,Ei,Ci分别是水沟的起点，终点以及其容量。求源点1到终点M的最大流速。做题之前我们需要知道三个属性分别是容量，空闲量<br>以及流量，容量指的是一个水管单位时间能流过的最大的水量，流量指的是单位时间内实际流过水管的水量，空闲量就是容量-流量即单位时间内还可以流过的水量.这题用的是Dinic算法，时间复杂度是O(V^2*E)<br>这里我们需要知道一个定理就从源流出的流量一定会等于在终点得到的流量(即没有水管漏水的情况下)Dinic的思路是构造一条反向边先BFS找到所有的增广路(即构造Level图)然后利用<br>dfs进行求堵塞流，阻塞流指的是使所有水流不再能流过的流，阻塞流不一定是最大流，但是最大流一定是阻塞流.<br><img src="https://user-images.githubusercontent.com/73943232/159265117-07c2a6af-3e8c-4924-be72-8863124589f1.jpg" alt="9D048AA77612CC74254576FE78610D6A"></p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map1[<span class="number">210</span>][<span class="number">210</span>]; <span class="comment">//点i到j的空闲量</span></span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">int</span> dis[<span class="number">210</span>]; <span class="comment">// 用于构造Level图</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;  <span class="comment">// 用来构造Level图，即第几层</span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  format(dis);</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (map1[t][i] &amp;&amp; !dis[i]) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">	dis[i] = dis[t] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> cap)</span> </span>&#123; <span class="comment">//v是当前的点，cap是容量</span></span><br><span class="line">  <span class="keyword">if</span> (v == m) &#123;</span><br><span class="line">    <span class="keyword">return</span> cap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> tp = cap; <span class="comment">// tp是空闲量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; tp; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map1[v][i] &amp;&amp; dis[i] == dis[v] + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">int</span> t = <span class="built_in">dfs</span>(i, <span class="built_in">min</span>(tp, map1[v][i]));</span><br><span class="line">      map1[v][i] -= t;</span><br><span class="line">      map1[i][v] += t; <span class="comment">// 反向边的建立</span></span><br><span class="line">      tp -= t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cap - tp; <span class="comment">//容量-空闲量即就是流量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">    flow += <span class="built_in">dfs</span>(<span class="number">1</span>, INF);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; flow &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">    format(map1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">      map1[x][y] += z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dinic</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1532(Dinic%E7%AE%97%E6%B3%95%E6%B1%82%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81)/" data-id="clgk9v4880017pxrf76mc2mex" data-title="hdu1532" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1710(二叉树已知两序求一序)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1710(%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%B2%E7%9F%A5%E4%B8%A4%E5%BA%8F%E6%B1%82%E4%B8%80%E5%BA%8F)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.016Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1710(%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%B2%E7%9F%A5%E4%B8%A4%E5%BA%8F%E6%B1%82%E4%B8%80%E5%BA%8F)/">hdu1710(二叉树已知两序求一序)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 03 &#x2F; 28</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Binary-Tree-Traversals"><a href="#Binary-Tree-Traversals" class="headerlink" title="Binary Tree Traversals"></a>Binary Tree Traversals</h3><blockquote>
<p>Time Limit: 1000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 32768&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 2198    Accepted Submission(s): 964</p>
<p>Problem Description<br>A binary tree is a finite set of vertices that is either empty or consists of a root r and two disjoint binary trees called the left and right subtrees. There are three most important ways in which the vertices of a binary tree can be systematically traversed or ordered. They are preorder, inorder and postorder. Let T be a binary tree with root r and subtrees T1,T2.<br>In a preorder traversal of the vertices of T, we visit the root r followed by visiting the vertices of T1 in preorder, then the vertices of T2 in preorder.<br>In an inorder traversal of the vertices of T, we visit the vertices of T1 in inorder, then the root r, followed by the vertices of T2 in inorder.<br>In a postorder traversal of the vertices of T, we visit the vertices of T1 in postorder, then the vertices of T2 in postorder and finally we visit r.<br>Now you are given the preorder sequence and inorder sequence of a certain binary tree. Try to find out its postorder sequence. </p>
<p>Input</p>
<p>The input contains several test cases. The first line of each test case contains a single integer n (1&lt;&#x3D;n&lt;&#x3D;1000), the number of vertices of the binary tree. Followed by two lines, respectively indicating the preorder sequence and inorder sequence. You can assume they are always correspond to a exclusive binary tree. </p>
<p>Output</p>
<p>For each test case print a single line specifying the corresponding postorder sequence. </p>
<p>Sample Input</p>
<p>  9<br>1 2 4 7 3 5 8 9 6</p>
<p>4 7 2 1 8 5 9 3 6</p>
<p>Sample Output</p>
<p>7 4 2 8 9 5 6 3 1</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目是已知二叉树的先序和中序求后序，由于我们知道二叉树先序遍历中访问顺序是根左右，而中序遍历中访问顺序是左根右，由此我们可以区分出左子树和右子树的序列，例如先序<br>遍历是1 2 4 7 3 5 8 9 6中序遍历是4 7 2 (1) 8 5 9 3 6可以看出1的左端是左子树，右端是右子树，进行递归我们可以构造出二叉树，从而进行后序遍历的输出,需要注意的是<br>已知先序后序是不能推导出中序的，因为没有办法确认左子树以及右子树.下面是两种情况的序列推导.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>   <span class="comment">//已知先序中序求后序</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pre[maxn];</span><br><span class="line"><span class="type">int</span> in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  tree *l;</span><br><span class="line">  tree *r;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line">tree *root;</span><br><span class="line"></span><br><span class="line"><span class="function">tree *<span class="title">create_tree</span><span class="params">(<span class="type">int</span> *pre, <span class="type">int</span> *in, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  tree *s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">      s = (tree *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(tree));   <span class="comment">// 分配内存空间</span></span><br><span class="line">      s-&gt;data = in[i]; </span><br><span class="line">      s-&gt;l = <span class="built_in">create_tree</span>(pre + <span class="number">1</span>, in, i);  <span class="comment">//构建左子树</span></span><br><span class="line">      s-&gt;r = <span class="built_in">create_tree</span>(pre + i + <span class="number">1</span>, in + i + <span class="number">1</span>, n - i - <span class="number">1</span>);   <span class="comment">//构建右子树</span></span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(tree *h)</span> </span>&#123;  <span class="comment">// 输出后序遍历</span></span><br><span class="line">  <span class="keyword">if</span> (h != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">Print</span>(h-&gt;l);</span><br><span class="line">    <span class="built_in">Print</span>(h-&gt;r);</span><br><span class="line">    <span class="keyword">if</span> (h == root) &#123;</span><br><span class="line">      cout &lt;&lt; h-&gt;data &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; h-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">    root = <span class="literal">NULL</span>;  <span class="comment">// 将根节点设置为空值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; pre[i];  <span class="comment">// 输入先序序列</span></span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; in[i];  <span class="comment">// 输入中序序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    root = <span class="built_in">create_tree</span>(pre, in, n);  <span class="comment">// 开始建树</span></span><br><span class="line">    <span class="built_in">Print</span>(root);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>   <span class="comment">//已知中序后序求先序</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in[maxn];</span><br><span class="line"><span class="type">int</span> aft[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  tree *l;</span><br><span class="line">  tree *r;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line">tree *root;</span><br><span class="line"></span><br><span class="line"><span class="function">tree *<span class="title">create_tree</span><span class="params">(<span class="type">int</span> *in, <span class="type">int</span> *aft, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  tree *s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (in[i] == aft[n - <span class="number">1</span>]) &#123;</span><br><span class="line">      s = (tree *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(tree));</span><br><span class="line">      s-&gt;data = in[i];</span><br><span class="line">      s-&gt;l = <span class="built_in">create_tree</span>(in, aft, i);</span><br><span class="line">      s-&gt;r = <span class="built_in">create_tree</span>(in + i + <span class="number">1</span>, aft + i, n - i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(tree *h)</span> </span>&#123;  <span class="comment">// 输出先序遍历</span></span><br><span class="line">  <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;	</span><br><span class="line">  &#125;	</span><br><span class="line">  cout &lt;&lt; h-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="built_in">Print</span>(h-&gt;l);</span><br><span class="line">  <span class="built_in">Print</span>(h-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; aft[i];</span><br><span class="line">    &#125;</span><br><span class="line">    root = <span class="built_in">create_tree</span>(in, aft, n);</span><br><span class="line">    <span class="built_in">Print</span>(root);</span><br><span class="line">  &#125;	 </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1710(%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%B2%E7%9F%A5%E4%B8%A4%E5%BA%8F%E6%B1%82%E4%B8%80%E5%BA%8F)/" data-id="clgk9v4890019pxrf22mw8vl6" data-title="hdu1710(二叉树已知两序求一序)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1873" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1873/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.016Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1873/">hdu1873</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 10 &#x2F; 20</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img width="1021" alt="截屏2021-10-21 10 07 50" src="https://user-images.githubusercontent.com/73943232/138202366-a77c115c-e641-4d18-9b7d-0aebb41047eb.png">


<blockquote>
<p>Problem Description<br>看病要排队这个是地球人都知道的常识。<br>不过经过细心的0068的观察，他发现了医院里排队还是有讲究的。0068所去的医院有三个医生（汗，这么少）同时看病。而看病的人病情有轻重，所以不能根据简单的先来先服务的原则。所以医院对每种病情规定了10种不同的优先级。级别为10的优先权最高，级别为1的优先权最低。医生在看病时，则会在他的队伍里面选择一个优先权最高的人进行诊治。如果遇到两个优先权一样的病人的话，则选择最早来排队的病人。<br>现在就请你帮助医院模拟这个看病过程。</p>
<p>Input</p>
<p>输入数据包含多组测试，请处理到文件结束。<br>每组数据第一行有一个正整数N(0&lt;N&lt;2000)表示发生事件的数目。<br>接下来有N行分别表示发生的事件。<br>一共有两种事件：<br>1:”IN A B”,表示有一个拥有优先级B的病人要求医生A诊治。(0&lt;A&lt;&#x3D;3,0&lt;B&lt;&#x3D;10)<br>2:”OUT A”,表示医生A进行了一次诊治，诊治完毕后，病人出院。(0&lt;A&lt;&#x3D;3)<br>Output<br>对于每个”OUT A”事件，请在一行里面输出被诊治人的编号ID。如果该事件时无病人需要诊治，则输出”EMPTY”。<br>诊治人的编号ID的定义为：在一组测试中，”IN A B”事件发生第K次时，进来的病人ID即为K。从1开始编号。</p>
<p>Sample Input</p>
<p>7</p>
<p>IN 1 1</p>
<p>IN 1 2</p>
<p>OUT 1</p>
<p>OUT 2</p>
<p>IN 2 1</p>
<p>OUT 2</p>
<p>OUT 1</p>
<p>2<br>IN 1 1</p>
<p>OUT 1</p>
<p>Sample Output</p>
<p>2</p>
<p>EMPTY</p>
<p>3</p>
<p>1</p>
<p>1</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目是一个优先队列的题目，但是我们得进行自定义排序，利用符号的重载我们可以定义排序规则,对于排序的重载我们一般是  重载 &lt; 符号，这里首先是按照等级进行排序，等级高的排列在前面，等级相同则按照来的顺序进行排列,我们可以利用一个结构体存取每一个病人的信息，然后利用STL里面的priority_queue进行排序来解题。</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> id, lev;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lev == x.lev) &#123;</span><br><span class="line">      <span class="keyword">return</span> id &gt; x.id; <span class="comment">// 等级相同按照id升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lev &lt; x.lev;  <span class="comment">// 等级不同优先按照等级降序排列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, x, cnt;</span><br><span class="line">  node k;</span><br><span class="line">  string s;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    priority_queue &lt;node&gt; q[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="string">&quot;IN&quot;</span>) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; k.lev;</span><br><span class="line">	k.id = cnt++;</span><br><span class="line">	q[x - <span class="number">1</span>].<span class="built_in">push</span>(k);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span> (q[x - <span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">	  cout &lt;&lt; <span class="string">&quot;EMPTY&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  cout &lt;&lt; q[x - <span class="number">1</span>].<span class="built_in">top</span>().id &lt;&lt; endl;</span><br><span class="line">	  q[x - <span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1873/" data-id="clgk9v489001bpxrffxv46wxh" data-title="hdu1873" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu2089(数位DP)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu2089(%E6%95%B0%E4%BD%8DDP)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.016Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu2089(%E6%95%B0%E4%BD%8DDP)/">hdu2089(数位DP)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 3 &#x2F; 3</p>
<p>[参考资料链接]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/young-children/articles/11351588.html">https://www.cnblogs.com/young-children/articles/11351588.html</a></p>
<p>[参考资料链接]<a target="_blank" rel="noopener" href="https://blog.csdn.net/dgq8211/article/details/9296953">https://blog.csdn.net/dgq8211/article/details/9296953</a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 </p>
</blockquote>
<blockquote>
<p>Input</p>
<p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 </p>
</blockquote>
<blockquote>
<p>Output</p>
<p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置</p>
</blockquote>
<blockquote>
<p>Sample Input<br>1 100</p>
</blockquote>
<blockquote>
<p>Sample Output</p>
<p>80</p>
</blockquote>
<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><blockquote>
<p>给定一个区间，求出当中的数不含4以及62的数字有多少个</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这是一个数位dp的模板题目，首先我们需要用一个dp数组来解题,dp[i]表示i位数中符合要求的数字个数，例如求1~324中符合<br>要求的数字，我们用一个digit数组把324拆开，从百位开始遍历，这里我着重讲一下这个limit(最高标记位）例如当前我取到<br>的百位数字是3，那么我的下一位也就是十位只能最大取到2，那么这种情况我们的limit设置为1，但是如果我们这时候取到的百<br>位的数字是2，那么是不是我们的十位随便取多少都可以，最大可以取到9，这时我们把limit设置为0，所以我们规定当当前数位<br>已经取到最大的值时，下一个数位的limit设置为1，当前数位的limit也设置为1，若当前数位为0，那个此数位和下一个数位的<br>limit都设置为0，还有一种情况就是当前数位的limit是1，但未取到最大值则下一个数位的limit就还是0总结下来就得到了代码<br>块中 limit &amp;&amp; num &#x3D;&#x3D; i这个来设置下一个数位的limit</p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, -1, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[LEN][<span class="number">2</span>];  <span class="comment">// dp[i]是i位数中符合要求的数字个数</span></span><br><span class="line"><span class="type">int</span> digit[LEN]; <span class="comment">// 用来存各个数位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> limit, <span class="type">int</span> state)</span> </span>&#123; <span class="comment">// len表示当前数位大小，limit表示最高标记位，state表示前一位是否为6</span></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, num; <span class="comment">// ans用来记录答案，num用来记录当前数位可以取到的最大的值</span></span><br><span class="line">  <span class="keyword">if</span> (!len) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!limit &amp;&amp; dp[len][state] != <span class="number">-1</span>) &#123; <span class="comment">// 若当前数位可以取到最大值9，并且dp数组有值就直接返回值</span></span><br><span class="line">    <span class="keyword">return</span> dp[len][state];</span><br><span class="line">  &#125;</span><br><span class="line">  num = limit ? digit[len] : <span class="number">9</span>;  <span class="comment">// 这里的limit是0表示当前数位未取到最大值所以下一位一定可以取最大值，若当前数位以及取到最大值则下一个数位上能取到的最大值就是题目给的那个数位值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i== <span class="number">4</span> || state &amp;&amp; i == <span class="number">2</span>) &#123;  <span class="comment">// 若数位上是4或者62则跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">dfs</span>(len - <span class="number">1</span>, limit &amp;&amp; num == i, i == <span class="number">6</span>); <span class="comment">// 缩小len，判断下一位的limit值，判断此时数位是否是6</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!limit) &#123;</span><br><span class="line">    dp[len][state] = ans; <span class="comment">// 若当前数位能取到最大值则赋值dp</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (num) &#123;</span><br><span class="line">    digit[++len] = num % <span class="number">10</span>; <span class="comment">//给digit存值</span></span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  format(dp);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">solve</span>(m) - <span class="built_in">solve</span>(n - <span class="number">1</span>) &lt;&lt; endl; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu2089(%E6%95%B0%E4%BD%8DDP)/" data-id="clgk9v48a001fpxrf1gbe1vmt" data-title="hdu2089(数位DP)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu2037(贪心区间调度)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu2037(%E8%B4%AA%E5%BF%83%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.016Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu2037(%E8%B4%AA%E5%BF%83%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6)/">hdu2037(贪心区间调度)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h3 id="日期-2022-x2F-05-x2F-10"><a href="#日期-2022-x2F-05-x2F-10" class="headerlink" title="日期 2022 &#x2F; 05 &#x2F; 10"></a>日期 2022 &#x2F; 05 &#x2F; 10<img width="1021" alt="截屏2022-05-10 21 10 43" src="https://user-images.githubusercontent.com/73943232/167636340-06f7661c-aeb6-4299-89cd-a96f2a99d752.png"></h3><p>[题目链接]<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2037">http://acm.hdu.edu.cn/showproblem.php?pid=2037</a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#$%^&amp;*%…”<br>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的&gt;《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目） </p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;&#x3D;100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;&#x3D;i&lt;&#x3D;n)，分别表示第i个&gt;节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n&#x3D;0表示输入结束，不做处理。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p>
</blockquote>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote>
<p>12</p>
<p>1 3</p>
<p>3 4</p>
<p>0 7</p>
<p>3 8</p>
<p>15 19</p>
<p>15 20</p>
<p>10 15</p>
<p>8 18</p>
<p>6 12</p>
<p>5 10</p>
<p>4 14</p>
<p>2 9</p>
<p>0</p>
</blockquote>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote>
<p>5</p>
</blockquote>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><blockquote>
<p>这个题目是一道贪心类型的题目，意思是给定n个有起始时间和终止时间的节目，问你如何规划可以看最多数量的节目，我们可以根据每个节目的终止时间来进行升序排序，即结束时间<br>越早的节目，这样的前提下我们可以看的节目是最多的，因此对于排序后的结果，我们利用下一个节目的start时间和当前节目的end进行比较，如果start&lt;&#x3D;end则证明可以看，同时<br>我们把下一个节目的end时间做上标记，方便与下次的节目进行比较，利用结构体存属性值，cnt变量进行计数得到答案.</p>
</blockquote>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">int</span> start;</span><br><span class="line"> <span class="type">int</span> end;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">node Node[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> node&amp; a, <span class="type">const</span> node&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cin &gt;&gt; Node[i].start &gt;&gt; Node[i].end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(Node, Node + n ,cmp);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Node[i].start &gt;= index) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        index = Node[i].end;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu2037(%E8%B4%AA%E5%BF%83%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6)/" data-id="clgk9v48b001hpxrf8dlk6cdn" data-title="hdu2037(贪心区间调度)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1253" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1253/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.015Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1253/">hdu1253</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 10 &#x2F; 29</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=1253">https://acm.dingbacode.com/showproblem.php?pid=1253</a><br><img width="1003" alt="截屏2021-10-29 17 58 12" src="https://user-images.githubusercontent.com/73943232/139415736-05163321-bd0e-4c14-bc71-1cbf1f73115b.png"></p>
<blockquote>
<p>胜利大逃亡</p>
<p>Time Limit: 4000&#x2F;2000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 55557    Accepted Submission(s): 19048</p>
<p>Problem Description</p>
<p>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.</p>
<p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.<br><img width="947" alt="截屏2021-10-29 17 59 23" src="https://user-images.githubusercontent.com/73943232/139415916-dfa8cd57-d231-4fd9-98da-013f5b2f2803.png"></p>
</blockquote>
<blockquote>
<p>Input</p>
<p>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;&#x3D;A,B,C&lt;&#x3D;50,1&lt;&#x3D;T&lt;&#x3D;1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)</p>
<p>特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.</p>
<p>Output</p>
<p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p>
<p>Sample Input</p>
<p>1</p>
<p>3 3 4 20</p>
<p>0 1 1 1</p>
<p>0 0 1 1</p>
<p>0 1 1 1</p>
<p>1 1 1 1</p>
<p>1 0 0 1</p>
<p>0 1 1 1</p>
<p>0 0 0 0</p>
<p>0 1 1 0</p>
<p>0 1 1 0</p>
<p>Sample Output</p>
<p>11</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目是一个三维的bfs，题目要求就是在规定时间内能不能走出迷宫，这里得用一个三维map记录地图，并且向六个方向遍历<br>我在写的时候忘记<code>cpp(b.x &gt;= 0 &amp;&amp; b.x &lt; A &amp;&amp; b.y &gt;= 0 &amp;&amp; b.y &lt; B &amp;&amp; b.z &gt;= 0 &amp;&amp; b.z &lt; C &amp;&amp; map1[b.x][b.y][b.z] == 0)</code><br>这个判断代码是得放在遍历方向之前还是之后，后面想了一下你每次遍历出一个方向的点得经过判断才能放入队列中所以是后者，这里我本来还想用一个vis数组判断每个点是否走过<br>后面发现其实你把每次走过的点设置为墙就可以了，这样就节约了空间的开销.</p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A, B, C, T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> map1[<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"><span class="type">int</span> dir[][<span class="number">3</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">0</span> ,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node a, b;</span><br><span class="line">  queue&lt;node&gt; q;</span><br><span class="line">  a.x = <span class="number">0</span>;</span><br><span class="line">  a.y = <span class="number">0</span>;</span><br><span class="line">  a.z = <span class="number">0</span>;</span><br><span class="line">  a.step = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(a);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    a = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.x == A - <span class="number">1</span> &amp;&amp; a.y == B - <span class="number">1</span> &amp;&amp; a.z == C - <span class="number">1</span> &amp;&amp; a.step &lt;= T) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      b.x = a.x + dir[i][<span class="number">0</span>];</span><br><span class="line">      b.y = a.y + dir[i][<span class="number">1</span>];</span><br><span class="line">      b.z = a.z + dir[i][<span class="number">2</span>];</span><br><span class="line">      b.step = a.step + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (b.x &gt;= <span class="number">0</span> &amp;&amp; b.x &lt; A &amp;&amp; b.y &gt;= <span class="number">0</span> &amp;&amp; b.y &lt; B &amp;&amp; b.z &gt;= <span class="number">0</span> &amp;&amp; b.z &lt; C &amp;&amp; map1[b.x][b.y][b.z] == <span class="number">0</span>) &#123;</span><br><span class="line">        map1[b.x][b.y][b.z] = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line">  <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; T;</span><br><span class="line">    format(vis);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; B; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; C; k++) &#123;</span><br><span class="line">	  cin &gt;&gt; map1[i][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1253/" data-id="clgk9v484000tpxrf6n6gc9sh" data-title="hdu1253" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1281" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1281/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.015Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1281/">hdu1281</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2021 &#x2F; 10 &#x2F; 28</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[题目链接]<a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=2181">https://acm.dingbacode.com/showproblem.php?pid=2181</a></p>
<blockquote>
<p>哈密顿绕行世界问题</p>
<p>Time Limit: 3000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 32768&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 13292    Accepted Submission(s): 7578</p>
<p>Problem Description<br>一个规则的实心十二面体，它的 20个顶点标出世界著名的20个城市，你从一个城市出发经过每个城市刚好一次后回到出发的城市。 </p>
<p>Input<br>前20行的第i行有3个数,表示与第i个城市相邻的3个城市.第20行以后每行有1个数m,m&lt;&#x3D;20,m&gt;&#x3D;1.m&#x3D;0退出.</p>
<p>Output<br>输出从第m个城市出发经过每个城市1次又回到m的所有路线,如有多条路线,按字典序输出,每行1条路线.每行首先输出是第几条路线.然后个一个: 后列出经过的城市.参看Sample output</p>
<p>Sample Input</p>
<p>2 5 20</p>
<p>1 3 12</p>
<p>2 4 10</p>
<p>3 5 8</p>
<p>1 4 6</p>
<p>5 7 19</p>
<p>6 8 17</p>
<p>4 7 9</p>
<p>8 10 16</p>
<p>3 9 11</p>
<p>10 12 15</p>
<p>2 11 13</p>
<p>12 14 20</p>
<p>13 15 18</p>
<p>11 14 16</p>
<p>9 15 17</p>
<p>7 16 18</p>
<p>14 17 19</p>
<p>6 18 20</p>
<p>1 13 19</p>
<p>5</p>
<p>0</p>
</blockquote>
<blockquote>
<p>Sample Output</p>
<p>1:  5 1 2 3 4 8 7 17 18 14 15 16 9 10 11 12 13 20 19 6 5</p>
<p>2:  5 1 2 3 4 8 9 10 11 12 13 20 19 18 14 15 16 17 7 6 5</p>
<p>3:  5 1 2 3 10 9 16 17 18 14 15 11 12 13 20 19 6 7 8 4 5</p>
<p>4:  5 1 2 3 10 11 12 13 20 19 6 7 17 18 14 15 16 9 8 4 5</p>
<p>5:  5 1 2 12 11 10 3 4 8 9 16 15 14 13 20 19 18 17 7 6 5</p>
<p>6:  5 1 2 12 11 15 14 13 20 19 18 17 16 9 10 3 4 8 7 6 5</p>
<p>7:  5 1 2 12 11 15 16 9 10 3 4 8 7 17 18 14 13 20 19 6 5</p>
<p>8:  5 1 2 12 11 15 16 17 18 14 13 20 19 6 7 8 9 10 3 4 5</p>
<p>9:  5 1 2 12 13 20 19 6 7 8 9 16 17 18 14 15 11 10 3 4 5</p>
<p>10:  5 1 2 12 13 20 19 18 14 15 11 10 3 4 8 9 16 17 7 6 5</p>
<p>11:  5 1 20 13 12 2 3 4 8 7 17 16 9 10 11 15 14 18 19 6 5</p>
<p>12:  5 1 20 13 12 2 3 10 11 15 14 18 19 6 7 17 16 9 8 4 5</p>
<p>13:  5 1 20 13 14 15 11 12 2 3 10 9 16 17 18 19 6 7 8 4 5</p>
<p>14:  5 1 20 13 14 15 16 9 10 11 12 2 3 4 8 7 17 18 19 6 5</p>
<p>15:  5 1 20 13 14 15 16 17 18 19 6 7 8 9 10 11 12 2 3 4 5</p>
<p>16:  5 1 20 13 14 18 19 6 7 17 16 15 11 12 2 3 10 9 8 4 5</p>
<p>17:  5 1 20 19 6 7 8 9 10 11 15 16 17 18 14 13 12 2 3 4 5</p>
<p>18:  5 1 20 19 6 7 17 18 14 13 12 2 3 10 11 15 16 9 8 4 5</p>
<p>19:  5 1 20 19 18 14 13 12 2 3 4 8 9 10 11 15 16 17 7 6 5</p>
<p>20:  5 1 20 19 18 17 16 9 10 11 15 14 13 12 2 3 4 8 7 6 5</p>
<p>21:  5 4 3 2 1 20 13 12 11 10 9 8 7 17 16 15 14 18 19 6 5</p>
<p>22:  5 4 3 2 1 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5</p>
<p>23:  5 4 3 2 12 11 10 9 8 7 6 19 18 17 16 15 14 13 20 1 5</p>
<p>24:  5 4 3 2 12 13 14 18 17 16 15 11 10 9 8 7 6 19 20 1 5</p>
<p>25:  5 4 3 10 9 8 7 6 19 20 13 14 18 17 16 15 11 12 2 1 5</p>
<p>26:  5 4 3 10 9 8 7 17 16 15 11 12 2 1 20 13 14 18 19 6 5</p>
<p>27:  5 4 3 10 11 12 2 1 20 13 14 15 16 9 8 7 17 18 19 6 5</p>
<p>28:  5 4 3 10 11 15 14 13 12 2 1 20 19 18 17 16 9 8 7 6 5</p>
<p>29:  5 4 3 10 11 15 14 18 17 16 9 8 7 6 19 20 13 12 2 1 5</p>
<p>30:  5 4 3 10 11 15 16 9 8 7 17 18 14 13 12 2 1 20 19 6 5</p>
<p>31:  5 4 8 7 6 19 18 17 16 9 10 3 2 12 11 15 14 13 20 1 5</p>
<p>32:  5 4 8 7 6 19 20 13 12 11 15 14 18 17 16 9 10 3 2 1 5</p>
<p>33:  5 4 8 7 17 16 9 10 3 2 1 20 13 12 11 15 14 18 19 6 5</p>
<p>34:  5 4 8 7 17 18 14 13 12 11 15 16 9 10 3 2 1 20 19 6 5</p>
<p>35:  5 4 8 9 10 3 2 1 20 19 18 14 13 12 11 15 16 17 7 6 5</p>
<p>36:  5 4 8 9 10 3 2 12 11 15 16 17 7 6 19 18 14 13 20 1 5</p>
<p>37:  5 4 8 9 16 15 11 10 3 2 12 13 14 18 17 7 6 19 20 1 5</p>
<p>38:  5 4 8 9 16 15 14 13 12 11 10 3 2 1 20 19 18 17 7 6 5</p>
<p>39:  5 4 8 9 16 15 14 18 17 7 6 19 20 13 12 11 10 3 2 1 5</p>
<p>40:  5 4 8 9 16 17 7 6 19 18 14 15 11 10 3 2 12 13 20 1 5</p>
<p>41:  5 6 7 8 4 3 2 12 13 14 15 11 10 9 16 17 18 19 20 1 5</p>
<p>42:  5 6 7 8 4 3 10 9 16 17 18 19 20 13 14 15 11 12 2 1 5</p>
<p>43:  5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5</p>
<p>44:  5 6 7 8 9 16 17 18 19 20 1 2 12 13 14 15 11 10 3 4 5</p>
<p>45:  5 6 7 17 16 9 8 4 3 10 11 15 14 18 19 20 13 12 2 1 5</p>
<p>46:  5 6 7 17 16 15 11 10 9 8 4 3 2 12 13 14 18 19 20 1 5</p>
<p>47:  5 6 7 17 16 15 11 12 13 14 18 19 20 1 2 3 10 9 8 4 5</p>
<p>48:  5 6 7 17 16 15 14 18 19 20 13 12 11 10 9 8 4 3 2 1 5</p>
<p>49:  5 6 7 17 18 19 20 1 2 3 10 11 12 13 14 15 16 9 8 4 5</p>
<p>50:  5 6 7 17 18 19 20 13 14 15 16 9 8 4 3 10 11 12 2 1 5</p>
<p>51:  5 6 19 18 14 13 20 1 2 12 11 15 16 17 7 8 9 10 3 4 5</p>
<p>52:  5 6 19 18 14 15 11 10 9 16 17 7 8 4 3 2 12 13 20 1 5</p>
<p>53:  5 6 19 18 14 15 11 12 13 20 1 2 3 10 9 16 17 7 8 4 5</p>
<p>54:  5 6 19 18 14 15 16 17 7 8 9 10 11 12 13 20 1 2 3 4 5</p>
<p>55:  5 6 19 18 17 7 8 4 3 2 12 11 10 9 16 15 14 13 20 1 5</p>
<p>56:  5 6 19 18 17 7 8 9 16 15 14 13 20 1 2 12 11 10 3 4 5</p>
<p>57:  5 6 19 20 1 2 3 10 9 16 15 11 12 13 14 18 17 7 8 4 5</p>
<p>58:  5 6 19 20 1 2 12 13 14 18 17 7 8 9 16 15 11 10 3 4 5</p>
<p>59:  5 6 19 20 13 12 11 10 9 16 15 14 18 17 7 8 4 3 2 1 5</p>
<p>60:  5 6 19 20 13 14 18 17 7 8 4 3 10 9 16 15 11 12 2 1 5</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目是求从一个城市出发，经过每一个不同的城市然后最终回到这个城市的路线打印出来并按照字典序排序，我们先用一个map1数组将每座城市相邻的城市存起来，然后从目标城市开始遍历<br>dfs的思想，如果城市经过的话就标记为1，不过要注意是字典序，这里的样例好像都是升序排序的，但是为了避免意外，在拿到数据的时候我们应该先进行排序，然后利用ans数组存取路线，当路线<br>达到20并且最后可以回到目标城市的时候输出。</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, cnt, k;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">21</span>], map1[<span class="number">21</span>][<span class="number">3</span>], vis[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">19</span> &amp;&amp; map1[x][i] == m) &#123;</span><br><span class="line">      cout &lt;&lt; ++cnt &lt;&lt; <span class="string">&quot;:  &quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!vis[map1[x][i]]) &#123;</span><br><span class="line">      vis[map1[x][i]] = <span class="number">1</span>;</span><br><span class="line">      ans[y + <span class="number">1</span>] = map1[x][i];</span><br><span class="line">      <span class="built_in">dfs</span>(map1[x][i], y + <span class="number">1</span>);</span><br><span class="line">      vis[map1[x][i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    cin &gt;&gt; map1[i][<span class="number">0</span>] &gt;&gt; map1[i][<span class="number">1</span>] &gt;&gt; map1[i][<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; m &amp;&amp; m) &#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    vis[m] = <span class="number">1</span>;</span><br><span class="line">    ans[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="built_in">dfs</span>(m, k);</span><br><span class="line">    format(vis);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1281/" data-id="clgk9v485000vpxrf57vl9j2z" data-title="hdu1281" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hdu1285(拓扑排序+优先队列)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/17/hdu1285(%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F+%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)/" class="article-date">
  <time class="dt-published" datetime="2023-04-17T02:24:04.015Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/17/hdu1285(%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F+%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)/">hdu1285(拓扑排序+优先队列)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>日期 2022 &#x2F; 03 &#x2F; 22</p>
<p>[参考链接]<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012860063/article/details/38018811">https://blog.csdn.net/u012860063/article/details/38018811</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="确定比赛名次"><a href="#确定比赛名次" class="headerlink" title="确定比赛名次"></a>确定比赛名次</h3><blockquote>
<p>Time Limit: 2000&#x2F;1000 MS (Java&#x2F;Others)    Memory Limit: 65536&#x2F;32768 K (Java&#x2F;Others)</p>
<p>Total Submission(s): 10604    Accepted Submission(s): 4150</p>
<p>Problem Description</p>
<p>有N个比赛队（1&lt;&#x3D;N&lt;&#x3D;500）。编号依次为1。2，3..N进行比赛，比赛结束后。裁判委员会要将全部參赛队伍从前往后依次排名，但如今裁判委员会不能直接获得每一个队的比赛成绩。仅仅知道每场比赛的结果，即P1赢P2，用P1。P2表示，排名时P1在P2之前。如今请你编程序确定排名。</p>
<p>Input</p>
<p>输入有若干组，每组中的第一行为二个数N（1&lt;&#x3D;N&lt;&#x3D;500），M；当中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1。P2表示即P1队赢了P2队。</p>
<p>Output</p>
<p>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。其它说明：符合条件的排名可能不是唯一的。此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p>
<p>Sample Input</p>
<p>4 3</p>
<p>1 2</p>
<p>2 3</p>
<p>4 3</p>
<p>Sample Output</p>
<p>1 2 4 3 </p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>这个题目是个拓扑排序加上优先队列的，我们知道拓扑排序的话我们需要先找到入度为0的点放进队列作为起点，这个题目规定了输出按照字典序，所以我们引进了优先队列，能够自动帮我们<br>排好序，第二步，我们假定队首元素为a，第二步就是把a的所有邻居点的入度减1，并把入度减为0的点放进队列，这里注意：没有减为0的点不能放进队列，继续操作直至队列为空</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(x, y, z) for (int x = y; x &lt;= z; x++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec(x, y, z) for (int x = y; x &gt;= z; x--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> format(a) memset (a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap(a, b) (a ^= b ^= a ^= b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q; <span class="comment">//升序队列，小顶堆</span></span><br><span class="line"><span class="type">int</span> map1[<span class="number">517</span>][<span class="number">517</span>];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">517</span>];</span><br><span class="line"><span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[i]) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(i); <span class="comment">// 找到入度为0的点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> head = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (sum != n) &#123;</span><br><span class="line">      cout &lt;&lt; head &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      sum++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!map1[head][i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;	</span><br><span class="line">      &#125;</span><br><span class="line">      cnt[i]--; <span class="comment">//将队首邻近的点的入度减去1</span></span><br><span class="line">      <span class="keyword">if</span> (!cnt[i]) &#123;  <span class="comment">// 入度为0的点放进队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">    format(cnt);</span><br><span class="line">    format(map1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="keyword">if</span> (map1[x][y]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      map1[x][y] = <span class="number">1</span>;</span><br><span class="line">      cnt[y]++; <span class="comment">// 这里相当于记录点的入度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/17/hdu1285(%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F+%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)/" data-id="clgk9v486000xpxrfdj0cdvhb" data-title="hdu1285(拓扑排序+优先队列)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/README/" rel="tag">README</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/README/" style="font-size: 10px;">README</a> <a href="/tags/algorithm/" style="font-size: 20px;">algorithm</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/17/poj2418(map%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2)/">poj2418(map输出字符串)</a>
          </li>
        
          <li>
            <a href="/2023/04/17/poj3041%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/">poj3041</a>
          </li>
        
          <li>
            <a href="/2023/04/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">数据库连接池</a>
          </li>
        
          <li>
            <a href="/2023/04/17/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE/">链式前向星存图</a>
          </li>
        
          <li>
            <a href="/2023/04/17/hdu2193(AVL%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6)/">hdu2193(AVL树的高度)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>